<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MP有限状态自动机和AC自动机</title>
      <link href="/posts/2853a062.html"/>
      <url>/posts/2853a062.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note primary flat"><h2 id="模式匹配自动机"><a href="#模式匹配自动机" class="headerlink" title="模式匹配自动机"></a>模式匹配自动机</h2></div><p>什么是有限状态自动机？<br>定义n个不同状态，记为{1,2…n}，在状态i时输入s，达到状态j，记为goto(i,s)&#x3D;j<br>对于字符串s而言，在一个状态i下输入一个字符ch，也会达到一个<mark class="hl-label blue">指定状态</mark> ：<br>假定新的状态为串s[1,i]+ch的<mark class="hl-label red">最长相等前后缀</mark> ，便能够用这个状态机模拟KMP算法匹配字符串的过程。<br>当字符集仅为a、b时，有：<br><img src="/study/youxian.png" alt="自动机"><br>其中goto(4,a)&#x3D;3，也就是说abab+a的<mark class="hl-label red">最长相等前后缀</mark> 对应的状态是<mark class="hl-label blue">状态3</mark> ，也即表示字符串“aba”的状态。<br>似乎这样就足够了。<br>我们获得了goto函数，定义为：</p><blockquote><p>goto(Si,a)：串s[1,i]a的最长相等前后缀。</p></blockquote><p>为了得到这个goto函数的值，我们需要定义fail函数：</p><blockquote><p>fail(Si):串s[1,i]的最长相等前后缀。</p></blockquote><p>因为得到goto(i,a)的前提是，知道s[1,i]的<mark class="hl-label red">最长相等前后缀s\[1,j]</mark> ：若s[j+1]与a相同，则goto(i,a)&#x3D;j+1，否则求s[1,j]的最长相等前后缀，直到长度为0。<br>为了表示“s[j+1]与a相同”这一条件，定义函数：</p><blockquote><p>follow(Si, a):状态Si输入a后，来到下一个状态。</p></blockquote><p>对于字符串abcde，follow(0,a)&#x3D;1,follow(1,b)&#x3D;2,follow(2,c)&#x3D;3…以此类推，而其他值未定义。<br>到这里，goto函数就可表示为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">state <span class="title">go_to</span><span class="params">(state s,<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">follow</span>(s,ch)未定义)</span><br><span class="line">    &#123;</span><br><span class="line">        s=fail[s];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">follow</span>(s,ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>若s为模式串的状态，ch为s的后继字符，则这一goto值可当做新的fail值。</p><p>未定义状态，比如follow(0,b),计为0可不可行？<br>与之配套地，fail(0),计为0，也就是说空串的<mark class="hl-label red">最长相等前后缀长度</mark> 为0。<br>若fail(0)记为-1，则follow(s&#x3D;&#x3D;-1,ch)将陷入故障状态：没有状态被记为-1。<br>问题出现了！函数不得不进入死循环：因为s一直为0。<br>破环方式也很简单：</p><blockquote><p>引入状态-1，未定义状态记为-1，fail(0)&#x3D;-1，follow(-1,任何字符)&#x3D;0。</p></blockquote><p>这样，当计算ab+c的<mark class="hl-label red">最长相等前后缀</mark> 时，便能够得到go_to(2,c)&#x3D;0。<br>类似地，计算fail的函数为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Compute_fail</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fail</span>(s0) = ⊥;</span><br><span class="line">    s = s0;</span><br><span class="line">    <span class="keyword">for</span>( i =<span class="number">1</span> to |P| )&#123;</span><br><span class="line">        s = <span class="built_in">goto</span>(s, P[i]);</span><br><span class="line">        <span class="built_in">fail</span>(si) = s ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>goto和fail数组的关系：fail反映模式串中的某部分字符串的<mark class="hl-label red">最长相等前后缀</mark> ，goto反映文本串和模式串的匹配情况。诚然，fail数组可以通过goto函数得到，但记录一些中间状态有利于加速算法。<br>匹配函数为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Match</span>(t)</span><br><span class="line">&#123;</span><br><span class="line">    s= s0;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> to |T|)&#123;</span><br><span class="line">        <span class="keyword">if</span>( s 是终止状态 )</span><br><span class="line">           <span class="keyword">return</span> 匹配!</span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            s=<span class="built_in">goto</span>(s,T[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;     </span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note primary flat"><h2 id="MP有限状态自动机"><a href="#MP有限状态自动机" class="headerlink" title="MP有限状态自动机"></a>MP有限状态自动机</h2></div><p><del>我们都知道mp的c++写法。</del><br>基于以上定义，我们<del>艰难地</del>知道mp的有限状态自动机写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> state int</span></span><br><span class="line">string P; <span class="comment">//模式串</span></span><br><span class="line">string T;</span><br><span class="line">state fail[<span class="number">1000005</span>];</span><br><span class="line">state edge[<span class="number">1000005</span>][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">state <span class="title">follow</span><span class="params">(state s,<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(edge[s][ch-<span class="string">&#x27;A&#x27;</span>]==s<span class="number">+1</span>) <span class="keyword">return</span> s<span class="number">+1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">state <span class="title">go_to</span><span class="params">(state s,<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">follow</span>(s,ch)==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=fail[s];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">follow</span>(s,ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fail[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    state s_=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;P.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        s_=<span class="built_in">go_to</span>(s_,P[i]);</span><br><span class="line">        fail[<span class="built_in">state</span>(i)]=s_;</span><br><span class="line">        </span><br><span class="line">           <span class="keyword">if</span>(fail[s_]!=<span class="number">-1</span>&amp;&amp;P[s_<span class="number">+1</span>]-<span class="string">&#x27;A&#x27;</span>==P[i<span class="number">+1</span>]-<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            fail[<span class="built_in">state</span>(i)]=fail[s_];</span><br><span class="line">        &#125;<span class="comment">//！！！K优化！！！</span></span><br><span class="line">        </span><br><span class="line">        edge[i<span class="number">-1</span>][P[i] - <span class="string">&#x27;A&#x27;</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">match</span><span class="params">()</span></span>&#123;</span><br><span class="line">    state s_=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;T.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        s_=<span class="built_in">go_to</span>(s_,T[i]);</span><br><span class="line">        <span class="keyword">if</span>(s_==<span class="built_in">state</span>(P.<span class="built_in">size</span>()<span class="number">-1</span>))&#123;</span><br><span class="line">            cout&lt;&lt;i-P.<span class="built_in">size</span>()<span class="number">+2</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;T&gt;&gt;P;</span><br><span class="line">    P=<span class="string">&quot; &quot;</span>+P;</span><br><span class="line">    T=<span class="string">&quot; &quot;</span>+T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_fail</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">match</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;P.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    cout&lt;&lt;fail[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>洛谷提交情况如下： <a class="btn-beautify " href="https://www.luogu.com.cn/record/182533994"   title="洛谷"><span>洛谷</span></a><br>这是一种没有任何实战意义的写法。<br>需要注意俩点：</p><blockquote><p>if(edge[s][ch-‘A’]&#x3D;&#x3D;s+1) return s+1;</p></blockquote><p>只有计算fail函数时，遍历过某个字符时，才连一条edge边。<br>也就是说，在未遍历时，字符串abc的follow(0,a)&#x3D;-1,follow(1,b)&#x3D;-1,follow(1,c)&#x3D;-1,而当遍历<strong>过</strong>b时，follow(0,a)&#x3D;1,follow(1,b)&#x3D;2,follow(1,c)&#x3D;-1。这样做的原因是，若模式串天然有follow边，则fail数组的值会依次为-1,1,2,3,4…</p><blockquote><p>if(fail[s_]!&#x3D;-1&amp;&amp;P[s_+1]-‘A’&#x3D;&#x3D;P[i+1]-‘A’){<br>fail[state(i)]&#x3D;fail[s_]; }</p></blockquote><p>这是knuth优化。对于字符串aaaa，mp的fail数组是0,1,2,3而kmp的fail数组是0,0,0,3。<br>因为kmp的fail数组不能很好地反映字符串的前后缀的关系，而我们通常需要利用这种关系，故现常用mp，且把mp称为kmp。</p><p>MP算法是一个O(m+n)的算法，证明如下：</p><blockquote><p>1.在check函数中，对文本串扫描一遍，无回头扫描，消耗O(n)<br>2.自动机向右的移动距离 &gt;&#x3D; 向左移动的距离&gt;&#x3D;调用fail的次数，而向右的移动距离&#x3D; 对文本串扫描的距离&#x3D;n，故调用fail的次数&#x3D;O(n)<br>3.构造fail数组时，向右的移动距离&#x3D; 对模式串扫描的距离&#x3D;m，即Fail构造复杂度的复杂度为O(m)</p></blockquote><p>综合为O(m+n)。实际上，除了aaab匹配aaaaaaaa这种极端数据外，mp和暴力算法复杂度接近：随机情况下，暴力的复杂度也接近O(m+n)，在数据随机生成的情况下，暴力匹配也基本很快就会失配。</p><div class="note primary flat"><h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2></div><p>虽然MP有限状态自动机看起来多此一举，但可以很便捷地理解AC自动机。<br>AC自动机要完成以下任务，对于一系列字符串t1，t2，t3，判断他们在文本串s中是否出现。<br>当然，可以跑3次mp算法，但这太过于漫长。<br>AC自动机需要利用字典树 <a class="btn-beautify " href="https://www.luogu.com.cn/problem/P8306"   title="字典树"><span>字典树</span></a>。<br>建树如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> noww)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s[noww].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(AC_[now].a[s[noww][i]-<span class="string">&#x27;a&#x27;</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">            now=AC_[now].a[s[noww][i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            AC_[now].a[s[noww][i] - <span class="string">&#x27;a&#x27;</span>] = ++cnt;</span><br><span class="line">            now=AC_[now].a[s[noww][i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    AC_[now].end.<span class="built_in">push_back</span>(noww);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当我们建立好字典树时，也需要fail数组的值：<br>注意：AC自动机的fail数组，其前缀和后缀未必出现在同一模式串上。如：<br><img src="/study/zidian.png" alt="字典树"><br>fail(7)&#x3D;8,虽然6来自单词iris，4来自单词is。这样做的目的是，当匹配到iris时，也能匹配到可能的模式串is。<br>这就需要我们打一个标记，来记录“is”是不是模式串。<br>和上面同样的问题，计算fail就需要利用之前的fail值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AC_[<span class="number">0</span>].fail=<span class="number">0</span>; <span class="comment">//0的fail是0</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(AC_[<span class="number">0</span>].a[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            AC_[AC_[<span class="number">0</span>].a[i]].fail=<span class="number">0</span>;  <span class="comment">//第一层字母的fail是0，因为不存在最长相等前后缀</span></span><br><span class="line">            q.<span class="built_in">push</span>(AC_[<span class="number">0</span>].a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按层由浅到深递增填写fail函数</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> iq=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(AC_[iq].a[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                AC_[AC_[iq].a[i]].fail=AC_[AC_[iq].fail].a[i]; <span class="comment">//只计算一次，就能得到fail函数</span></span><br><span class="line">                q.<span class="built_in">push</span>(AC_[iq].a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                AC_[iq].a[i]=AC_[AC_[iq].fail].a[i]; <span class="comment">//将AC自动机转化为模式匹配自动机，全部字母都对应跳转边，比AC自动机需要更多的空间</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模式匹配自动机</strong>带来的优化:<br>当文本串是“iris<strong>i</strong>s”时，因为AC_[7].fail&#x3D;8,goto(8,i)&#x3D;0,follow(0,i)&#x3D;4，故新的状态为4。<br>否则，计算goto(8,i)&#x3D;0,再计算goto(0,i)&#x3D;4，就需要经过不止两次goto，而非固定的<strong>一次</strong>goto。<br>时间复杂度分析：</p><blockquote><p>AC自动机构造算法时间复杂为 O(|P|)，|P|模式集合中模式的长度之和</p></blockquote><blockquote><p>模式匹配搜索时间复杂 O(n + occ)，occ为模式出现次数(因为状态需要通过fail函数跳跃)</p></blockquote><p>问题：T&#x3D;aaaaaaaa，P&#x3D;{a,aa,aaa,aaaa,aaaa}时，搜索复杂度是多少？</p><p>check函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ss.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        now=AC_[now].a[ss[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=now;j!=<span class="number">0</span>&amp;&amp;AC_[j].end!=<span class="number">-1</span>;j=AC_[j].fail)&#123;</span><br><span class="line">            ans+=AC_[j].end;</span><br><span class="line">            AC_[j].end=<span class="number">-1</span>;  <span class="comment">//防止重复计数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><a class="btn-beautify " href="https://www.luogu.com.cn/record/182415813"   title="AC自动机简单版"><span>AC自动机简单版</span></a><p>优化：<br>使用拓扑排序，不进行fail跳跃(以下check是统计出现了几次，上面check是统计出现了几种)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">topu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="type">int</span> iq=q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">        jishu[AC_[iq].num]+=AC_[iq].ans;</span><br><span class="line">    AC_[AC_[iq].fail].ans+=AC_[iq].ans;</span><br><span class="line">    in[AC_[iq].fail]--;</span><br><span class="line">    <span class="keyword">if</span>(in[AC_[iq].fail]==<span class="number">0</span>) q.<span class="built_in">push</span>(AC_[iq].fail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ss.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        now=AC_[now].a[ss[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">            AC_[now].ans++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topu</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a class="btn-beautify " href="https://www.luogu.com.cn/record/182422907"   title="AC自动机"><span>AC自动机</span></a><p>设n为文本长度，k是模式数量，则：<br>最好匹配次数为n<br>最坏匹配次数为(1+n)*n&#x2F;2+n²-nk<br>AC自动机</p><div class="note primary flat"><h2 id="比特并行算法"><a href="#比特并行算法" class="headerlink" title="比特并行算法"></a>比特并行算法</h2></div><p>比特并行：一个机器字操作，能对所有比特进行改变。</p><h4 id="非确定自动机NFA"><a href="#非确定自动机NFA" class="headerlink" title="非确定自动机NFA"></a>非确定自动机NFA</h4><p>MP的非确定自动机：<br>同一时刻，不只有最长的前缀被匹配，更短的前缀也同时被匹配。<br>在DFA中，活跃状态只有一个，其他状态通过“后缀链”连接；而NFA中，他们都是活跃状态(空前缀永远是匹配的；每次匹配，都能得到一系列活跃状态的集合(用机器字代表这些集合，机器字的每一个比特代表一个前缀是否匹配))。<br>NFA中没有必要有后缀链存在，而是只存在向前的链接。</p><h4 id="举例：shift-and算法"><a href="#举例：shift-and算法" class="headerlink" title="举例：shift-and算法"></a>举例：shift-and算法</h4><p>文本串为ababb，模式串为abab，则状态变化为：</p><table><thead><tr><th>轮次\前缀</th><th>a</th><th>ab</th><th>aba</th><th>abab</th></tr></thead><tbody><tr><td>初始D表</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>输入a后D表</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>输入b后D表</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>输入a后D表</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>输入b后D表</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>输入b后D表</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>形式化：设B[a]表示a在模式串存在的位置，即{1,0,1,0}，B[b]表示b在模式串存在的位置，即{0,1,0,1}，每次变化计为：<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>D</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mi>D</mi><mo>&gt;&gt;</mo><mn>1</mn><mo stretchy="false">)</mo><mrow><mo stretchy="false">|</mo></mrow><mn>1</mn><mo>按位与</mo><mi>B</mi><mo stretchy="false">[</mo><msub><mi>t</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">]</mo></math><br>第一次移位得到可能活跃的集合，第二次取交得到活跃的集合。<br>shift-or：以0代表匹配，1代表不匹配。B[a]表示a<strong>不在</strong>模式串存在的位置，即{0,1,0,1}，B[b]表示b在模式串存在的位置，即{1,0,1,0}(D向量初始全1)：<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>D</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mi>D</mi><mo>&gt;&gt;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>按位或</mo><mi>B</mi><mo stretchy="false">[</mo><msub><mi>t</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">]</mo></math></p><mark class="hl-label red">注意：字符串是小端顺序，D、B向量是大端顺序：以上移位都应该向左移位</mark> <h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>比特并行算法能很好地处理通配符匹配问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line">string P;</span><br><span class="line">string T;</span><br><span class="line">bitset&lt;1000005&gt; B[<span class="number">256</span>];</span><br><span class="line">bitset&lt;1000005&gt; D=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;P&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;P.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        B[P[i]][i]=<span class="number">1</span>;</span><br><span class="line">        B[(<span class="type">int</span>)<span class="string">&#x27;-&#x27;</span>][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(P[i]==<span class="string">&#x27;a&#x27;</span>||P[i]==<span class="string">&#x27;b&#x27;</span>)&#123;   <span class="comment">//-和任意字符匹配，*和a，b匹配：当然，也可以随意指定</span></span><br><span class="line">            B[(<span class="type">int</span>)<span class="string">&#x27;*&#x27;</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(P[i]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            B[(<span class="type">int</span>)<span class="string">&#x27;a&#x27;</span>][i]=B[(<span class="type">int</span>)<span class="string">&#x27;b&#x27;</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(P[i]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">256</span>;j++)&#123;</span><br><span class="line">                B[j][i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        D=D&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        D[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        D=D&amp;B[T[i]];</span><br><span class="line">        <span class="keyword">if</span>(D[P.<span class="built_in">size</span>()<span class="number">-1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;success at &quot;</span>&lt;&lt;i-P.<span class="built_in">size</span>()<span class="number">+1</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;fail&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a-a*cc</span></span><br><span class="line"><span class="comment">//*a-b--</span></span><br><span class="line"><span class="comment">//匹配成功</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>NFA需要硬件支持并行机制，空间占用小；<br>DFA只需要串行操作，空间占用大。<br>参考资料：<br>1.<a href="https://blog.csdn.net/aoke1952/article/details/101609109" title="" target="">kmp和mp</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BM算法(手算版)</title>
      <link href="/posts/f093fa41.html"/>
      <url>/posts/f093fa41.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note primary flat"><h2 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h2></div><p>BM算法是一种字符串匹配的算法。<br>与KMP相比，BM算法不扫描全部输入字符，平均匹配时间c·n, 常量 c &lt;1 (随机或真实文本), 但最坏情况是O(n·m).<br>可以将BM算法的最坏情况改进到O(n)：通过记录文本后缀中最长的模式后缀。<br>要使用BM算法，需要知道两个信息：<br><strong>1.用于坏字符规则的bc数组</strong><br><strong>2.用于好后缀规则的gs数组</strong></p><div class="note info flat"><h2 id="坏字符规则"><a href="#坏字符规则" class="headerlink" title="坏字符规则"></a>坏字符规则</h2></div><p>坏字符规则分为两种情况：<br>1.失配位置指向的<mark class="hl-label red">文本串中对应的字符</mark> ，不存在于模式串中。<br><img src="/study/huai2.png" alt="坏字符"><br>如上图所示，在这种情况下，直接将整个模式串移动到<mark class="hl-label red">失配位置</mark> 之后。</p><p>2.失配位置指向的<mark class="hl-label red">文本串中对应的字符</mark> ，存在于模式串中，且在<mark class="hl-label red">失配位置</mark> 的左边。<br><img src="/study/huai1.png" alt="坏字符"><br>如上图所示，在这种情况下，将模式串中的<mark class="hl-label red">文本串中对应的字符</mark> 放在<mark class="hl-label red">失配位置</mark> 上。<br>需要注意两个问题：<br>1.这个“模式串中的<mark class="hl-label red">文本串中对应的字符</mark> ”，是整个模式串从<strong>右往左数</strong>的第一个符合的字符。否则会造成过度左移。<br>2.模式串中最后一个字符，不能和任何的<mark class="hl-label red">失配位置</mark> 匹配。这是因为“失配”的前提是有匹配，而右边第一个字符必然被匹配；否则在右边第一个字符失配，那说明所需要的字符不是这个右边的第一个字符。故最后一个字符对应的位置是从右边数<strong>第二个符合数</strong>的位置。<br>如字符串“GCAGAGAG”的坏字符表为(从0开始计数,<strong>从右往左</strong>数)：</p><table><thead><tr><th>char</th><th>A</th><th>C</th><th>G</th><th>T</th></tr></thead><tbody><tr><td>bc[char]</td><td>1</td><td>6</td><td><mark class="hl-label blue">2</mark> </td><td>8</td></tr></tbody></table><p>坏字符表不是一直有效的。如果坏字符表中记载的位置，在<mark class="hl-label red">失配位置</mark> 的<strong>右边</strong>，那么可能会造成负位移或原地不动。<br>一个解决方法是，记载每次<mark class="hl-label red">失配位置</mark> 的<strong>左边</strong>的第一个符合的字符：但这很麻烦。<br>这并不是说位移就是上表的值。位移&#x3D; <strong>bc[char]-失配位置Z</strong>。(从右往左数，0开始)</p><div class="note info flat"><h2 id="好后缀规则"><a href="#好后缀规则" class="headerlink" title="好后缀规则"></a>好后缀规则</h2></div><p>好后缀规则分为3种情况：<br><img src="/study/hao.png" alt="坏字符"><br>rule3：</p><blockquote><p>如图14.1，目前匹配好的后缀u，在模式串中存在。如果有多个，则取最靠右的且c！&#x3D;a的那个，并将其对齐。</p></blockquote><p>rule2：</p><blockquote><p>如图14.2，目前匹配的好后缀u，在模式串中其他位置<strong>不存在</strong>。但它的后缀，和模式串的前缀相同。如果有多个满足的后缀，则取最长的那个后缀，并将其对齐。</p></blockquote><p>rule1：</p><blockquote><p><del>如图14.？</del>，目前匹配的好后缀u，在模式串中其他位置<strong>不存在</strong>。且它的每一个后缀，和模式串的前缀都<strong>不相同</strong>。这种情况下，直接将整个模式串移动到当前的<strong>最右端</strong>之后。</p></blockquote><p>好后缀规则和坏字符规则是可以同时使用的，我们每次取俩者中<strong>最大</strong>的那个。<br>如坏字符规则一样，好后缀也有自己的表，叫做gs数组。要想得到gs数组，首先要利用suff数组。</p><blockquote><p>suff数组:存储从字符s[i]向左开始计数的，和模式串最右边字符开始的匹配的字符个数。</p></blockquote><p>如字符串“GCAGAGAG”的suff为(从0开始计数)：</p><table><thead><tr><th>G</th><th>C</th><th>A</th><th>G</th><th>A</th><th>G</th><th>A</th><th>G</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>0</td><td>2</td><td>0</td><td>4</td><td>0</td><td>8</td></tr></tbody></table><p>从右往左看：<br>从G开始，GAGAGACG与GAGAAGACG匹配，个数是8，故填8。<br>从A开始，没有字符匹配(因为右边第一个字符是G)，故填0。<br>从G开始，GAGA(下一个是C)与GAGA(下一个是G)匹配，个数是4，故填4。<br>从A开始，没有字符匹配(因为右边第一个字符是G)，故填0。<br>从G开始，GA(下一个是C)与GA(下一个是G)匹配，个数是2，故填2。<br>从A开始，没有字符匹配(因为右边第一个字符是G)，故填0。<br>从C开始，没有字符匹配(因为右边第一个字符是G)，故填0。<br>从G开始，G(下一个是末尾)与G(下一个是A)匹配，个数是1，故填1。</p><p>接下来，我们依次处理rule1，rule2，rule3，来获得gs数组。<br>为什么是这个顺序：因为rule1位移&gt;rule2位移&gt;rule3位移，大的值被小的值取代，才不会造成<strong>过度右移</strong>。<br>具体的理解，可以见<a class="btn-beautify " href="https://www.cnblogs.com/YWT-Real/p/17120732.html"   title="高效字符串匹配算法"><span>高效字符串匹配算法</span></a><br><font color=red>施加rule1：</font><br>所有的项均有最大位移8(字符串长)：</p><table><thead><tr><th>G</th><th>C</th><th>A</th><th>G</th><th>A</th><th>G</th><th>A</th><th>G</th></tr></thead><tbody><tr><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td></tr></tbody></table><p><font color=red>施加rule2：</font><br>step1：从右往左扫描模式串，找到第一个下标(下标<strong>从左往右</strong>数，从0开始计。略过最右边的数)+1&#x3D;suff[i]的位置。对上面的例子来说，这个位置是“i&#x3D;0”，对应的是最左边的字符G。<br>step2：从左往右扫描字符串，将扫描过的位置对应的gs数组改为“当前值-suff[i]”，直到剩下suff[i]个字符。<br>step3：step继续向左，step2继续向右，直到扫描完成。</p><table><thead><tr><th>G</th><th>C</th><th>A</th><th>G</th><th>A</th><th>G</th><th>A</th><th>G</th></tr></thead><tbody><tr><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>8</td></tr></tbody></table><p><font color=red>施加rule3：</font><br>从左往右扫描字符串(略过最右边那个)，将gs[suff[i]]改为i(下标从右往左数，以0开始):</p><p>变化1：</p><table><thead><tr><th><mark class="hl-label blue">G</mark> </th><th>C</th><th>A</th><th>G</th><th>A</th><th>G</th><th>A</th><th>G</th></tr></thead><tbody><tr><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td><mark class="hl-label blue">7</mark> </td><td>8</td></tr></tbody></table><p>变化2：</p><table><thead><tr><th>G</th><th>C</th><th>A</th><th><mark class="hl-label blue">G</mark> </th><th>A</th><th>G</th><th>A</th><th>G</th></tr></thead><tbody><tr><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td><mark class="hl-label blue">4</mark> </td><td>7</td><td><mark class="hl-label red">5</mark> </td></tr></tbody></table><p>变化3：</p><table><thead><tr><th>G</th><th>C</th><th>A</th><th>G</th><th>A</th><th><mark class="hl-label blue">G</mark> </th><th>A</th><th>G</th></tr></thead><tbody><tr><td>7</td><td>7</td><td>7</td><td><mark class="hl-label blue">2</mark> </td><td>7</td><td>4</td><td>7</td><td><mark class="hl-label red">3</mark> </td></tr></tbody></table><p>变化4：</p><table><thead><tr><th>G</th><th>C</th><th>A</th><th>G</th><th>A</th><th>G</th><th><mark class="hl-label blue">A</mark> </th><th>G</th></tr></thead><tbody><tr><td>i&#x3D;0</td><td>i&#x3D;1</td><td>i&#x3D;2</td><td>i&#x3D;3</td><td>i&#x3D;4</td><td>i&#x3D;5</td><td>i&#x3D;6</td><td>i&#x3D;7</td></tr><tr><td>7</td><td>7</td><td>7</td><td>2</td><td>7</td><td>4</td><td>7</td><td><mark class="hl-label blue">1</mark> </td></tr></tbody></table><div class="note primary flat"><h2 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h2></div><p><img src="/study/shili1.png" alt="实例"><br>向右位移&#x3D;max(bc[A]-Z,gs[7])&#x3D;max(1-0,1)&#x3D;1;<br><img src="/study/shili2.png" alt="实例"><br>向右位移&#x3D;max(bc[C]-Z,gs[5])&#x3D;max(6-2,4)&#x3D;4;<br><img src="/study/shili3.png" alt="实例"><br>向右位移&#x3D;max(0,<mark class="hl-label blue">gs[-1---->0]</mark> )&#x3D;max(0,7)&#x3D;7;<br><img src="/study/shili4.png" alt="实例"><br>向右位移&#x3D;max(bc[C]-Z,gs[5])&#x3D;max(6-2,4)&#x3D;4;<br><img src="/study/shili5.png" alt="实例"><br>向右位移&#x3D;max(bc[C]-Z,gs[6])&#x3D;max(6-1,<strong>7</strong>)&#x3D;<strong>7</strong>;<br>附：对于字符串aaaaaa，其gs数组为{6,6,6,6,6，6}—&gt;{1,2,3,4,5,6}—–&gt;{1,2,3,4,5,6}。</p><div class="note primary flat"><h2 id="与kmp比较"><a href="#与kmp比较" class="headerlink" title="与kmp比较"></a>与kmp比较</h2></div><p>1.KMP算法的实际性能不好，一般实际中不用<br>2.BM速度快，但最快的BM类算法不是完整BM算法而是简化的版本(复杂度和效率的折中版本)<br>若模式串长为m，文本串长为n：<br>BM算法最好情况下比较m次，最坏情况下比较(n-m+1)*m次<br>MP算法最好情况下比较m次，最坏情况下比较(n-m+1)*m次<br>平均比较次数：？</p><p>参考内容：<br>1.<a href="https://blog.csdn.net/EQUINOX1/article/details/133256159" title="" target="">BM-c++</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：入侵检测系统</title>
      <link href="/posts/8c8bc191.html"/>
      <url>/posts/8c8bc191.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note primary flat"><h2 id="入侵检测系统概念"><a href="#入侵检测系统概念" class="headerlink" title="入侵检测系统概念"></a>入侵检测系统概念</h2></div><p>入侵：未经授权的计算机使用者以及不正当使用(misuse)计算机的合法用户(内部威胁)，危害或试图危害资源的完整性、保密性、可用性的行为。<br>入侵检测：通过监测计算机系统的某些信息，加以分析，检测入侵行为，并作出反应。<br>入侵检测系统：实现入侵检测功能的硬件与软件。<br>核心问题：降低误报率<br>结构：<br><img src="/study/ruqin.png" alt="入侵检测"><br>事件产生器（Event generater， E-box）收集入侵检测事件,并提供给IDS其他部件处理。事件可以是网络活动，也可是系统调用序列等系统信息。<br>事件分析器（Analysis engine, A-box）对输入的事件进行分析并检测入侵。<br>事件数据库（Event database, D-box）存储和管理E-boxes 和 A-boxes 产生的大量数据，用于IDS(入侵检测系统)的训练和证据保存。<br>事件响应器（Response unit, C-box）对入侵做出响应，包括向管理员发出警告，切断入侵连接，根除入侵者留下的后门以及数据恢复等。<br>分类：<br>误用检测(基于特征的检测)：判别当前行为是否符合<strong>已知攻击的知识库</strong>中记录的的攻击模式。机制：状态模型、专家系统、正则表达式匹配<br>异常检测(基于行为的检测)：建立用户的正常使用模式知识库，标识出不符合正常模式的行为。机制：统计、机器学习方法<br>混合检测</p><div class="note warning flat"><h2 id="入侵检测系统评价标准"><a href="#入侵检测系统评价标准" class="headerlink" title="入侵检测系统评价标准"></a>入侵检测系统评价标准</h2></div><p>处理高速网络流量的能力<br>自身抗攻击的能力<br>误报率和漏报率<br>协同事件的能力<br>检测新攻击的能力</p><div class="note primary flat"><h2 id="误报率-混淆矩阵"><a href="#误报率-混淆矩阵" class="headerlink" title="误报率-混淆矩阵"></a>误报率-混淆矩阵</h2></div><p><img src="/study/yic.png" alt="入侵检测"><br>误报率：误报的数量(正常情况下报告攻击，攻击情况下报告正常)占所有正常事件的比例。即蓝色部分占据的面积(正确的true，错误的false)。<br>现实中，攻击行为占比很少(TP+FN)。导致正确率很高的检测器可能有较高的误报率。<br>准确率：p&#x3D;(TP+TN)&#x2F;(TP+TN+FP+FN)，预测对的占总样本总数的比率<br>精确率：p&#x3D;TP&#x2F;(TP+FP)，预测为<strong>攻击</strong>，且预测对了占总预测为攻击的比率<br>漏报率：p&#x3D;FN&#x2F;(TP+FN)<br>报警的准确度：p&#x3D;TN&#x2F;(TN+FP)<br><strong>误报率</strong>：p&#x3D;FP&#x2F;(TN+FP)<br>(为什么误报率是最重要的指标？)</p><div class="note primary flat"><h2 id="网络入侵检测系统Snort"><a href="#网络入侵检测系统Snort" class="headerlink" title="网络入侵检测系统Snort"></a>网络入侵检测系统Snort</h2></div><p>开放型系统，采用误用检测，包含：网络包的解析器、检测引擎、日志和报警子系统。利用libpcap库作为捕获数据包的工具。<br>特点：<br>主要数据源：网络数据包<br>设计原则：简单、灵活、高性能<br>对包的处理：1.协议分析；2.模式匹配(单模式匹配、多模式匹配)、正则表达式匹配、非精确模式匹配(什么样的协议，检测什么样的内容。先进行协议分析：分层解析各层包头，从链路层，到传输层，直到应用层，协议分析可以显著地缩小检测模式范围，从而减少内容检查，提高了入侵检测的效率。分析内容(时间占比大)：先匹配出现概率小的，后匹配出现概率大的，先匹配关键字，后匹配变量。)<br>特征描述语言：可描述攻击行为(误用检测)<br>插件子系统：实现系统功能扩展<br>规则:<br>由规则头，规则选项构成。规则头指明协议和源目标IP地址等，对包进行简单处理；规则选项指明包数据中搜索的内容，对包进行细致处理。<br>最重要的两个规则选项：<br>content: 用于匹配固定字符串，适合匹配简单的特征。<br>pcre: 用于匹配复杂的模式，支持正则表达式，适合匹配灵活多变的攻击 payload。<br>结合使用: 将 content 和 pcre 结合使用，可以提高检测的准确性。例如，使用 content 匹配关键字，使用 pcre 匹配变量部分。</p><div class="note warning flat"><h2 id="针对IDS的拒绝服务类攻击"><a href="#针对IDS的拒绝服务类攻击" class="headerlink" title="针对IDS的拒绝服务类攻击"></a>针对IDS的拒绝服务类攻击</h2></div><p>问题：<br>IDS要在高速的网络上工作，使得DPI(深度网络数据包检测,深入到数据包的载荷处理。DPI的中心问题：高效多正则表达式匹配。虽然识别多表达式的DFA只对输入扫描一次 但两个DFA的合并，状态数可能为二者之积。)处理能力显著下降，发生丢包、漏报。且攻击模式更加复杂。<br>攻击：<br>超载攻击：<br>当网络流量超过IDS的处理能力时(如大量的复杂正则匹配)，IDS的处理能力将急剧下降甚至完全瘫痪。攻击者通过某些手段使网络流量达到饱和，迫使IDS大量丢包。这种攻击还可针对目标IDS系统采用的检测算法进行算法攻击。<br>资源耗尽攻击：<br>通过发送大量残缺TCP数据段以及IP分片耗尽IDS的存储资源(IDS需要存储一些中间状态)，使IDS不能正常工作。<br>算法复杂攻击：<br>使DPI算法进入最坏情况，造成拒绝服务。目前除了通过修改算法还没有其他有效的方法。<br>提高性能：<br>提高单机检测性能：<br>采用高效检测算法，如多模式匹配&#x2F;多正则表达式匹配算法<br>采用高性能硬件<br>多机并行：<br>网络流量的分割<br>处理任务的分割</p><div class="note primary flat"><h2 id="加密流量处理"><a href="#加密流量处理" class="headerlink" title="加密流量处理"></a>加密流量处理</h2></div><p>IDS可以检测包头，但无法深入检查。<br>解决方式：<br>SSL&#x2F;TLS解密（中间人方式）</p><blockquote><p>不安全：被加密的数据被解密</p></blockquote><p>元数据分析（Metadata Analysis）</p><blockquote><p>分析HTTPS流量的元数据（例如，SNI、流量模式、连接频率等）</p></blockquote><p>基于行为的异常检测（Anomaly-Based Detection）</p><blockquote><p>对正常流量模式建模，来识别与正常行为偏差较大的活动</p></blockquote><blockquote><p>恶意软件、数据泄露</p></blockquote><p>EDR（Endpoint Detection and Response，端点检测和响应）</p><blockquote><p>EDR部署在客户端设备上，可以直接查看未加密的流量和活动</p></blockquote><div class="note primary flat"><h2 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h2></div><p>模式匹配算法：<br>Brute Force算法，最坏情况 O(nm)<br>KMP算法<br>AC多模式匹配算法<br>Boyer-Moore算法<br>现代技术：<br>后缀树与后缀自动机<br>基于因子识别的算法<br>Bit并行算法与非标准模式匹配<br>应用领域：<br>病毒扫描、入侵检测、搜索引擎、大数据处理</p><p>参考资料：<br>1.<a href="https://catcoder.blog.csdn.net/article/details/95623289?fromshare=blogdetail&sharetype=blogdetail&sharerId=95623289&sharerefer=PC&sharesource=lemonsed&sharefrom=from_link" title="" target="">混淆矩阵</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：buffer overflow attack</title>
      <link href="/posts/1e6d162f.html"/>
      <url>/posts/1e6d162f.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note primary flat"><h2 id="堆栈构造"><a href="#堆栈构造" class="headerlink" title="堆栈构造"></a>堆栈构造</h2></div><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">静态存储</button><button type="button" class="tab " data-href="1-2">可变存储</button><button type="button" class="tab " data-href="1-3">函数调用</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>text segment存放代码；<br>data segment存放初始化了的静态变量；<br>BSS segment存放未初始化的静态变量。</p></div><div class="tab-item-content" id="1-2"><p>Heap存放需要长期保存的变量；<br>Stack存放临时变量。</p></div><div class="tab-item-content" id="1-3"><p>调用函数时，如f(int a,int b)：<br>则b放在大的正地址如ebp+12，a放在小的正地址如ebp+8，临时变量放在负地址如ebp-4。旧的ebp放在ebp+0，返回地址放在ebp+4。<br>这些数据构成一个<strong>栈帧</strong>。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2></div><p><img src="/study/neicun.png" alt="内存"></p><div class="note primary flat"><h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2></div><p><img src="/study/gj.png" alt="攻击"></p><blockquote><p>攻击原理：栈溢出时，能把以前的数据覆盖。</p></blockquote><blockquote><p>-攻击步骤1：在return address和攻击代码之间可写NOP；如果return address域指向的地址高于其自身的地址，则程序会沿着NOP走到攻击代码。(攻击代码足够短的话，也能放在return address之前)<br>-攻击步骤2：确定return address到栈底的偏移量，在这里将存放新的返回地址。<br>-攻击步骤3：在堆栈空间内找到存放攻击代码(操作寄存器的汇编代码)的地址。</p></blockquote><p>注意：字符串中的0会将字符串截断。解决：寄存器与寄存器自身异或获得数据0。<br>例子：<br><img src="/study/shell.png" alt="shell"><br>execve()的三个参数分别为”&#x2F;bin&#x2F;sh”、”&#x2F;bin&#x2F;sh NULL”、NULL，分别存在ebx,ecx,edx中，execve()函数本身的代码放在eax中。<br>上述代码激活时，栈会随代码运行而发生变化，当寄存器内的值都准备妥当时，通过汇编指令int 0x80启动execve()函数。<br><img src="/study/code.png" alt="code"></p><div class="note warning flat"><h2 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h2></div><h4 id="开放商方法"><a href="#开放商方法" class="headerlink" title="开放商方法"></a>开放商方法</h4><p>使用安全的函数</p><h4 id="OS方法"><a href="#OS方法" class="headerlink" title="OS方法"></a>OS方法</h4><p>ASLR：地址随机化(每次启动程序时，栈和堆的地址不固定。可高度随机化，也可以几种情况轮换)。这时，ebp(定位return address)和malicious code的位置难以确定。<br>应对方法：重复运行攻击代码</p><h4 id="编译器方法"><a href="#编译器方法" class="headerlink" title="编译器方法"></a>编译器方法</h4><p>stack-Guard：编译器使用一些guard值插入栈的内部，自动检测栈数据有没有被溢出数据覆盖<br><img src="/study/stack.png" alt="guard"></p><h4 id="shell方法"><a href="#shell方法" class="headerlink" title="shell方法"></a>shell方法</h4><p>当检测到真实的id(用户id)跳入到有效id时，自动降回更低的id<br>应对方法：运行攻击部分之前，将自己的real id设置为0</p><h4 id="硬件方法"><a href="#硬件方法" class="headerlink" title="硬件方法"></a>硬件方法</h4><p>Non-Executable Stack：禁止在栈内运行代码<br>应对方法：return-to-libc攻击</p><div class="note primary flat"><h2 id="return-to-libc攻击-考试重点"><a href="#return-to-libc攻击-考试重点" class="headerlink" title="return-to-libc攻击 考试重点"></a>return-to-libc攻击 <strong>考试重点</strong></h2></div><p>原理：利用已有的系统函数(比如system)，结合缓冲区的溢出。</p><blockquote><p>-攻击步骤1：找到system()和exit()函数的位置。<br>-攻击步骤2：找到字符串“bin&#x2F;sh”的位置，作为参数(将“bin&#x2F;sh”设置为环境变量：这会导致“bin&#x2F;sh”被压入栈中)。<br>-攻击步骤3：为system()设置好栈结构(准备好参数，返回地址：这里返回地址写的是exit()函数的地址)。<br>详细见<a class="btn-beautify " href="https://blog.csdn.net/sinat_38816924/article/details/106222286"   title="return-to-libc攻击"><span>return-to-libc攻击</span></a>(压栈时，eip等也会压入)</p></blockquote><p>更优的方法：</p><div class="note primary flat"><h2 id="return-oriented-programing攻击"><a href="#return-oriented-programing攻击" class="headerlink" title="return-oriented programing攻击"></a>return-oriented programing攻击</h2></div><p>原理：将系统中的多个片段指令，以一定顺序组织在一起。<br>例子：<br>需执行r1-&gt;r2-&gt;r3三段代码，他们的地址分别为a1、a2、a3，则栈内从下到上为a1、a2、a3、正常返回地址，并且三个程序的最后一句为ret指令。</p><div class="note primary flat"><h2 id="jmp-oriented-programing攻击"><a href="#jmp-oriented-programing攻击" class="headerlink" title="jmp-oriented programing攻击"></a>jmp-oriented programing攻击</h2></div><p>例子：<br>以上个攻击为例，栈内从下到上为a1、a2、a3、正常返回地址，三个程序的最后一句为相对跳转(jmp [dx])指令跳到<strong>调度器</strong>。<br>JOP攻击需要结合调度器，来实现“dx&#x3D;dx+4；jmp[dx]”的控制。<br>如何初始化dx：设置好esp的位置后，执行pop dx</p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：门限秘密分享</title>
      <link href="/posts/a91656d0.html"/>
      <url>/posts/a91656d0.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note primary flat"><h2 id="t-n-门限方案"><a href="#t-n-门限方案" class="headerlink" title="(t-n)门限方案"></a>(t-n)门限方案</h2></div><p>n个人中的t个人能还原秘密。</p><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">用对称密钥实现</button><button type="button" class="tab " data-href="1-2">shamir方案实现</button><button type="button" class="tab " data-href="1-3">使用几何学实现</button><button type="button" class="tab " data-href="1-4">基于中国剩余定理</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>略</p></div><div class="tab-item-content" id="1-2"><p>用拉格朗日插值定理实现。<strong>考试重点</strong><br>t-1阶的多项式P(x)，P(0)&#x3D;s秘密。<br>所有运算都是模p的，且s，n＜p。<br>表达式：<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&#x3D;</mo><munderover><mo data-mjx-texclass="OP">∑</mo><mrow><mi>i</mi><mo>&#x3D;</mo><mn>0</mn></mrow><mrow><mi>n</mi></mrow></munderover><msub><mi>y</mi><mrow><mi>i</mi></mrow></msub><msub><mi>l</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>,</mo><mo>其中</mo><msub><mi>l</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&#x3D;</mo><munderover><mo data-mjx-texclass="OP">∏</mo><mrow><mi>j</mi><mo>&#x3D;</mo><mn>0</mn><mo>,</mo><mi>j</mi><mo>!</mo><mo>&#x3D;</mo><mi>i</mi></mrow><mrow><mi>n</mi></mrow></munderover><mfrac><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><msub><mi>x</mi><mrow><mi>j</mi></mrow></msub><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>i</mi></mrow></msub><mo>−</mo><msub><mi>x</mi><mrow><mi>j</mi></mrow></msub><mo stretchy="false">)</mo></mrow></mfrac></math><br>例子：<br>p&#x3D;7,f(1)&#x3D;2,f(2)&#x3D;1,f(4)&#x3D;5:<br>ff(1)&#x3D;2*(x-2)<em>(x-4)&#x2F;(1-2)(1-4)&#x3D;10</em>(x-2)<em>(x-4);<br>ff(2)&#x3D;1</em>(x-1)<em>(x-4)&#x2F;(2-1)(2-4)&#x3D;3</em>(x-1)<em>(x-4);<br>ff(3)&#x3D;5</em>(x-1)<em>(x-2)&#x2F;(4-1)(4-2)&#x3D;30</em>(x-1)*(x-2);<br>相加得：x²-4x+5(mod 7)</p></div><div class="tab-item-content" id="1-3"><p>略</p></div><div class="tab-item-content" id="1-4"><p>任选n个俩俩互质的数，任意k个数的乘积＞m，s＜m。<br>原理：少于k个时，得到的s‘比真正的s小，不能唯一地确认真正的s。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：量子密钥协商</title>
      <link href="/posts/29d1b803.html"/>
      <url>/posts/29d1b803.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note info flat"><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2></div><p>在量子理论中，用向量表示0比特和1比特。<br>量子比特qubit的叠加可能性：a<em>0+b</em>1，其中a²+b²&#x3D;1。测量此比特，得到1比特的可能性。(a,b为几率幅，结果为0的可能性为a²，结果为1的可能性为b²。a，b是复数)<br>测量对qubit的影响：使叠加态<strong>不可逆地</strong>坍缩到测出的态。<br>不可克隆：不能精确复制量子态，但能移动。<br>光子通过光栅，是对光子的测量。光子通过光栅后，光子偏振方向与光栅方向相同。<br>如果偏振方向和光栅方向的角度为a，则该光子通过光栅的可能性为cos²a。<br><img src="/study/qiet.png" alt="窃听"></p><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">BB84协议实现密钥分配</button><button type="button" class="tab " data-href="1-2">B92协议(更优)</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p><img src="/study/guangzi.png" alt="BB84"><br>光子的编码方式：以一个方向代表1，与其<strong>垂直</strong>的方向代表0。BB84只采用两种：x或者＋。(垂直的或45°倾斜的)</p><blockquote><p>1.A选择一个比特b。</p></blockquote><blockquote><p>2.A选择一个发送方式：x或者＋。</p></blockquote><blockquote><p>3.B选择一个接收方式：x或者＋。</p></blockquote><blockquote><p>4.A公布发送方式，B公布接收方式。如果两个方式不同，则抛弃接收结果。</p></blockquote><p>重复以上过程4N次，最终，A有2N比特，B有2N比特，随机选择N比特作为秘密(如果两方的N比特完全一致，则大概率认为没有窃听者存在(如果窃听者选择了错误的接收方式，则会破坏信息，使接收方有一定的概率接收到错误结果))。</p></div><div class="tab-item-content" id="1-2"><p>使用非正交基，-表示0，&#x2F;表示1。</p><blockquote><p>1.A选择一个比特b。</p></blockquote><blockquote><p>2.编码后，发给B。</p></blockquote><blockquote><p>3.B随机地使用×或者+来测量b，如果用+测得|，则是1(用＋测量-时，测得0，用+测量&#x2F;时，测得0或者1。故出现|则说明是1)，如果用×测得\，则是0。其他情况即为不确定的测量结果。</p></blockquote><blockquote><p>4.B公布不确定的测量结果，用BB84方法检查窃听者。</p></blockquote><table><thead><tr><th></th><th>-</th><th>&#x2F;</th></tr></thead><tbody><tr><td>+</td><td>-</td><td>+</td></tr><tr><td>×</td><td>×</td><td>&#x2F;</td></tr></tbody></table></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：安全策略</title>
      <link href="/posts/a5baeaeb.html"/>
      <url>/posts/a5baeaeb.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note warning flat"><h2 id="什么是安全策略"><a href="#什么是安全策略" class="headerlink" title="什么是安全策略"></a>什么是安全策略</h2></div><p>计算机安全的一般定义：你可以依赖计算机，且计算机如你预料的那样行动。<br>不同的计算机对安全有更精确的划分，描述这种安全的方式叫做安全策略。<br>安全机制：实现安全策略的机制。<br>攻击破坏安全机制，使计算机在预料之外行动。</p><div class="note warning flat"><h2 id="计算机安全基本问题"><a href="#计算机安全基本问题" class="headerlink" title="计算机安全基本问题"></a>计算机安全基本问题</h2></div><p>在什么条件下，一个计算机算法可判定一个计算机系统是否安全？<br>结论：安全模型表达能力越强，验证安全性越难。简单模型描述能力有限，但存在有效验证安全性的方法。</p><div class="note primary flat"><h2 id="访问控制模型"><a href="#访问控制模型" class="headerlink" title="访问控制模型"></a>访问控制模型</h2></div><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">访问控制矩阵ACM</button><button type="button" class="tab " data-href="1-2">Haarrion-Ruzzo-Ullman模型</button><button type="button" class="tab " data-href="1-3">Take-Grant模型</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>保护状态：涉及安全保护的状态<br>ACM是描述当前保护状态的最精确的模型，主体与主体之间也存在不同权限。</p><table><thead><tr><th></th><th>文件f</th><th>文件g</th><th>进程p</th><th>进程q</th></tr></thead><tbody><tr><td>进程p</td><td>读写</td><td>读写</td><td>读写添加创建</td><td><strong>写</strong></td></tr><tr><td>进程q</td><td>读写</td><td>读写</td><td><strong>读</strong></td><td>读写添加创建</td></tr></tbody></table><p>ACM的行称为能力表，ACM的列称为访问控制列表(常用)。</p></div><div class="tab-item-content" id="1-2"><p>基本命令：创建主体客体、删除主客体、增加权限，删除权限。<br>单步命令：包含一条基本命令(基本命令不可直接调用)的命令。单步命令系统的可靠性问题可判定。</p><blockquote><p>证明：<br>1.delete操作可忽略：因为状态数固定<br>2.所有create合并成一个：最多增加一个主客体，因为只考虑r权限是否泄漏<br>3.故系统规模是有限的，命令总数k≤命令种类数*(主体+1)*(客体+1)，可用穷举方式判定</p></blockquote><p>条件命令：包含条件控制的命令，实现更合理的安全策略。多条件命令<strong>只能用AND</strong>连接条件。<br>可靠(安全)的：一个权限r不会被加入到原来不存在r的矩阵元素中。<br>在最普通、最抽象的情况下，计算机的安全是不可判定的。对于普通的HRU模型一系列操作，不存在算法判断权限是否泄漏。</p><blockquote><p>证明：<br>将图灵机停机问题归约为可靠性问题，而图灵机停机问题不可判定，故可靠性问题不可判定。</p><blockquote><p>证明：<br>设D(i,x)返回i号图灵机在输入为x时是否停机。构造图灵机y号如下:<br>if D(i,x)&#x3D;停 then 不停 else 停<br>则输入的编号为y时，产生悖论，故不存在这样的图灵机y，即判定图灵机是否停机问题的算法是无限的。</p></blockquote></blockquote><h4 id="图灵机停机问题"><a href="#图灵机停机问题" class="headerlink" title="图灵机停机问题"></a>图灵机停机问题</h4><p>图灵机：能模拟任何确定、可行、有限的算法。如果图灵机不能进入任何预设的接受拒绝状态，则图灵机不停机。<br>图灵机问题指的是，是否存在图灵机能回答,任意图灵机在任意输入下,是否停机的问题?</p><h4 id="用ACM矩阵表示图灵机"><a href="#用ACM矩阵表示图灵机" class="headerlink" title="用ACM矩阵表示图灵机"></a>用ACM矩阵表示图灵机</h4><p><img src="/study/acm.png" alt="ACM"><br>其中，纸袋的左移、右移、写，越过边界，可由一系列ACM命令模拟。<br>own确定了纸带单元的顺序。<br>k的存在保证同一时刻只有一条命令被触发。</p></div><div class="tab-item-content" id="1-3"><p>第一种可判定安全性的访问控制模型，时间是系统规模的线性函数。</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><blockquote><p>take：主体A可获取B的所有权限。<br>主体s若能获得y拥有的所有权限，则s可最终扩展为y。<br>grant：主体A可将自身拥有的任意权限赋给B。<br>主体s若能把其权限赋给r，则s可初始扩展为r。<br>create：主体创造对象。<br>remove：主体移除对象或权限。</p></blockquote><p>只有主体能主动执行一些动作，规则是修改ACM的权限。规则不是对系统的修改，而是对系统描述的修改。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>对称性<br><img src="/study/take.png" alt="对称性"></p><blockquote><p>即z对x有take权限，x也能通过一系列操作获得z的权限。<br>和x对z有take权限的区别：需要双方进行操作，而非一方进行操作。</p></blockquote><h4 id="保护状态图"><a href="#保护状态图" class="headerlink" title="保护状态图"></a>保护状态图</h4><p>岛：最大的，tg相连的，都是主体的子图。如果tg相连的都是主体，那么take和grant权限是对称的。<br>桥：连接众多主体、客体的路径(全是take权限；或take权限夹单个grand权限)，但桥的两端都是主体。(证明见回放)<br>谓词can·share(r,x,y,G)：返回节点x能否获得对y的r权限。</p><blockquote><p>如果x，y是一个岛上的主体，则返回真。</p></blockquote><blockquote><p>为真的充要条件1：如果x有一条边r连向y，则返回真。</p></blockquote><blockquote><p>为真的充要条件2：主体s有对y的r权限边，主体s和<strong>主体x</strong>在一些由桥连接的岛上。</p></blockquote><blockquote><p>为真的充要条件3：主体s有对y的r权限边，存在主体x‘&#x3D;x或x’初始扩展为x，存在主体s‘&#x3D;s或s’最终扩展为s，主体s‘和主体x’在一些由桥连接的岛上。</p></blockquote><p>任何两个点x，y的can·share(r,x,y,G)可用时间复杂度有限的算法判定。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="访问控制策略类型"><a href="#访问控制策略类型" class="headerlink" title="访问控制策略类型"></a>访问控制策略类型</h2></div><p>按照主体对ACM的权限进行的分类：</p><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">自主型访问控制DAC</button><button type="button" class="tab " data-href="2-2">强制访问控制MAC</button><button type="button" class="tab " data-href="2-3">创建者控制访问机制ORCON</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><p>基于身份的访问控制。<br>主体能自主地将访问权授予其他主体。<br>局限：主体不能控制信息的流动。<br>攻击：<br><img src="/study/muma.png" alt="木马"></p></div><div class="tab-item-content" id="2-2"><p>基于规则的访问控制。<br>系统机制控制对客体的访问，一般用户不能改变访问控制矩阵。<br>需要一个中心控制权威。</p></div><div class="tab-item-content" id="2-3"><p>DAC和MAC的结合。<br>没有创建者的许可，客体不会被泄露；<strong>客体的任何副本也遵循同样的限制</strong>。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="访问控制机制"><a href="#访问控制机制" class="headerlink" title="访问控制机制"></a>访问控制机制</h2></div><div class="tabs" id="3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="3-1">访问控制列表ACL</button><button type="button" class="tab " data-href="3-2">能力表</button><button type="button" class="tab " data-href="3-3">基于角色的访问控制RBAC</button><button type="button" class="tab " data-href="3-4">基于属性的访问控制ABAC</button></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><p>ACM的列，去除空表项，表和客体绑定。<br>应用：文件目录，网络防火墙。<br>易于集中管理，管理员可知道哪些主体拥有权限。</p></div><div class="tab-item-content" id="3-2"><p>ACM的行，去除空表项，表和主体绑定。<br>应用：分布式系统，微内核。<br>易于传递权限，无需管理员审批；不易于查找某一权限。<br>问题：<br>撤销权限时，要遍历所有主体。<span class="hide-inline"><button type="button" class="hide-button" style="">Click<br>  </button><span class="hide-content">构造一个全局客体表，主体引用全局客体表的表号代表客体(解决了撤销权限的问题，寻找权限的问题没解决)</span></span></p></div><div class="tab-item-content" id="3-3"><p>RBAC根据用户所拥有的角色进行访问控制和授权。<br>管理员角色管理权限的授予和撤销，用户的访问权限不可以主动转交。(非自主的访问控制)<br>应用：数据库、分布式系统。<br>一个用户可以发起几次会话，在不同会话中承担不同角色。<br>角色间的层次关系：角色A的权限包含角色B的所有权限。<br>约束：角色互斥、角色的实例限制等</p><blockquote><p>静态职责分离SSD：系统设计之初就定义好了的互斥角色<br>动态职责分离DSD：系统运行期间，动态地限制用户拥有的角色 </p></blockquote><p>优点：</p><blockquote><p>提高了管理员的管理能力(简化了授权模型，可方便实现权力分割、互斥)<br>模型与组织机构自然对应(使用起来很自然)</p></blockquote></div><div class="tab-item-content" id="3-4"><p>优点：<br>细粒度的访问控制；<br>灵活，适合动态访问控制；<br>减少用户和角色数量；<br>描述专业系统的防控策略。<br>属性分为主体属性，客体属性，环境属性。<br>ABAC在判断用户能否权限时，组合各类属性，代入规则以计算权限。<br>可实现DAC,RBAC,MAC等。</p><h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><p><img src="/study/abac.png" alt="策略"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="安全策略类型"><a href="#安全策略类型" class="headerlink" title="安全策略类型"></a>安全策略类型</h2></div><div class="tabs" id="3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="3-1">保密性策略</button><button type="button" class="tab " data-href="3-2">完整性策略</button><button type="button" class="tab " data-href="3-3">混合策略</button></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><p>用于军事安全策略。<br>基础：Bell-La Padula模型</p><h4 id="Bell-La-Padula模型"><a href="#Bell-La-Padula模型" class="headerlink" title="Bell-La Padula模型"></a>Bell-La Padula模型</h4><p>访问权限：执行、附加(追加写)、读、写。<br>Bell-La Padula模型约束信息的流动，信息不能由高安全级流向低安全级。<br>主体只能向下读(主体要有客体的DAC读权限)，向上附加(主体要有客体的DAC附加权限)，同级写(主体要有客体的DAC写权限)。<br>问题：有时候并不是所有的向下读等都是有必要的。<br>优化：给主体贴上“安全等级“的标签，安全等级由安全级别、类别构成。如{Too Secret，{Nuc，Eur，Asi}}</p><h4 id="关系优化"><a href="#关系优化" class="headerlink" title="关系优化"></a>关系优化</h4><p><img src="/study/zhipei.png" alt="支配"><br>支配关系dom，是部分序关系。基于需要知道原则，即便是同级的主体，也可能无法互相访问。<br>理解：{Too Secret，{Nuc，Eur，Asi}} dom {Too Secret，{Eur，Asi}}，意思为拥有前一个标签的主体，能访问拥有后一个标签的主体。</p><h4 id="对DAC木马问题的解决"><a href="#对DAC木马问题的解决" class="headerlink" title="对DAC木马问题的解决"></a>对DAC木马问题的解决</h4><p><img src="/study/mumaa.png" alt="木马"></p><h4 id="局限和结论"><a href="#局限和结论" class="headerlink" title="局限和结论"></a>局限和结论</h4><p>局限：没有涉及完整性，级别是静态的，包含隐形道(可能泄露高级对象的名字)。<br>重要结论：基本安全定理-状态迁移是安全的，初始状态是安全的，则其后的每一个状态都是安全的。</p></div><div class="tab-item-content" id="3-2"><p>用于商业安全策略。<br>著名模型：Biba完整性模型。</p><h4 id="Biba完整性模型"><a href="#Biba完整性模型" class="headerlink" title="Biba完整性模型"></a>Biba完整性模型</h4><p>完整性级别越高，数据越可信。<br>Biba完整性模型约束信息的改变，对信息的写会破坏完整性。<br><font color=red>Low-Water-Mark策略</font></p><blockquote><p>主体能向下写(主体的完整性等级高于客体的完整性等级)，向上读。<br>当一个主体读了一个低完整性客体，那么主体的完整性等级下降到该客体。<br>可以invoke(调用)低级别的客体。</p></blockquote><p><font color=red>环策略</font></p><blockquote><p>主体完整性等级都相同。<br>任意主体能read任意客体。<br>主体能向下写(主体的完整性等级高于客体的完整性等级)。<br>可以invoke(调用)低级别的客体。</p></blockquote><p>忽略了间接修改的问题，导致信息可以向上流。<br><font color=red>严格完整性策略</font></p><blockquote><p>主体能向下写(主体的完整性等级高于客体的完整性等级)，向上读。<br>可以invoke(调用)低级别的客体。</p></blockquote></div><div class="tab-item-content" id="3-3"><p>代表：中国墙模型，创建者控制访问机制ORCON，基于角色、属性的访问控制。</p><h4 id="中国墙模型"><a href="#中国墙模型" class="headerlink" title="中国墙模型"></a>中国墙模型</h4><p>解决商业中的利益冲突问题。<br>将信息对象分为“利益冲突”类。<br>CD：与一个公司有关的信息的集合。<br>COI：有利益冲突的公司的CD的集合，每个CD只属于一个COI。<br><img src="/study/coi.png" alt="COI"></p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p>s可以读o，当s读过o所属的CD的客体，或s没有读过其他冲突CD，或o是无毒客体。主体在一个COI中只能访问一个CD。<br>s可以写o，当s能够读的全部未消毒客体(即有毒个体，也即信息需要保密的个体。无毒：信息可以被任何主体读。)，与<strong>可读的</strong>o在一个CD中。</p><h4 id="联系和区别"><a href="#联系和区别" class="headerlink" title="联系和区别"></a>联系和区别</h4><p>与BLP本质区别：BLP用了安全标签，CW用了访问历史。<br>BLP能够模拟CW任意时刻的状态(不能跟踪变化)，而CW能模拟BLP整体。<br><img src="/study/youdu.png" alt="CW模拟"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>参考资料：<br>1.<a href="https://blog.csdn.net/sinat_41135487/article/details/105443141?fromshare=blogdetail&sharetype=blogdetail&sharerId=105443141&sharerefer=PC&sharesource=lemonsed&sharefrom=from_link" title="" target="">信息安全模型</a><br>2.<a href="https://blog.csdn.net/waqqy/article/details/127803086?fromshare=blogdetail&sharetype=blogdetail&sharerId=127803086&sharerefer=PC&sharesource=lemonsed&sharefrom=from_link" title="" target="">Bell-Lapudula模型</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：算法优化</title>
      <link href="/posts/5f4e56a6.html"/>
      <url>/posts/5f4e56a6.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note primary flat"><h2 id="公钥算法的优化"><a href="#公钥算法的优化" class="headerlink" title="公钥算法的优化"></a>公钥算法的优化</h2></div><p>加密算法的两个重要指标是加密强度和速度。在实现上，可以用各种技术来提高算法速度。<br>加密算法分为密钥生成和加解密，主要优化加解密部分。<br>Amdahl定律：优化一段代码的效果，取决于其执行时间占全部执行时间的比例。</p><h4 id="优化工作的方向"><a href="#优化工作的方向" class="headerlink" title="优化工作的方向"></a>优化工作的方向</h4><blockquote><p>充分利用CPU特性，如流水线和指令并行</p></blockquote><blockquote><p>针对加密算法本身做一些优化</p></blockquote><blockquote><p>编译器也会做一些优化：编译器的优化很保守(保证正确性)，且一些优化对于程序员来说简单，对编译器来说很难</p></blockquote><h4 id="软件优化一般方法"><a href="#软件优化一般方法" class="headerlink" title="软件优化一般方法"></a>软件优化一般方法</h4><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">代码移动</button><button type="button" class="tab " data-href="1-2">预计算</button><button type="button" class="tab " data-href="1-3">指令替换</button><button type="button" class="tab " data-href="1-4">共享子表达式</button><button type="button" class="tab " data-href="1-5">减少多余过程调用</button><button type="button" class="tab " data-href="1-6">限制变量</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>利用指令并行：调整代码顺序，使相近的两条指令的数据不相关<br>将条件分支指令按照概率和计算量排列次序</p></div><div class="tab-item-content" id="1-2"><p>如先计算一个定值，先计算一个字符串的长度</p></div><div class="tab-item-content" id="1-3"><p>避免使用耗时的指令：如左右移指令不能与任何其他指令配对形成流水，阻断了流水线<br>在循环中避免使用条件跳转指令：条件跳转指令会产生不可预见的指令流，容易分支预测失败</p></div><div class="tab-item-content" id="1-4"></div><div class="tab-item-content" id="1-5"><p>展开加密循环和函数：减少了条件指令和计算指令，将变量转化为常量，减少流水线的阻断和指令预取的作废</p></div><div class="tab-item-content" id="1-6"><p>限制变量的数量：寄存器有限<br>变量长度与CPU内部寄存器长度相同:否则，需要用别的指令来辅助存取，增加了指令周期数</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h4 id="优化举例"><a href="#优化举例" class="headerlink" title="优化举例"></a>优化举例</h4><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">IDEA算法优化</button><button type="button" class="tab " data-href="2-2">AES算法优化</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><p>问题<br>乘法时，若输入是0，该怎么办？ <span class="hide-inline"><button type="button" class="hide-button" style="">Click<br>  </button><span class="hide-content">乘法输入为0，则将其替换为2的16次方(<strong>17</strong>位数)，如果乘法输出是2的16次方，则将其替换为0。 正确性：0和2的16次方，在进行异或和加法时，结果一致；但是0没有乘法逆元，2的16次方为17位，故可以定义一个数，以2的16次方的性质(存在逆元)存在，但又能以16位的大小(数0)传递。</span></span><br>乘法的取模操作太耗时！<br>解决：高低算法：设p的高16是a，低16是b，则<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>p</mi><mo>&#x3D;</mo><mi>a</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">⟹</mo><mi>p</mi><mo>≡</mo><mi>b</mi><mo>−</mo><mi>a</mi><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>,</mo><mo>即计算</mo><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mo>&gt;&gt;</mo><mn>16</mn><mo stretchy="false">]</mo></math> </p><h4 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h4><p>查表法(指令周期大大减少)：预计算和存储一个生成元e的指数对数表，则a*b可表示为:<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mi>e</mi></mrow></msub><mi>a</mi><mo>+</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mi>e</mi></mrow></msub><mi>b</mi><mo>&#x3D;</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mi>e</mi></mrow></msub><mi>a</mi><mi>b</mi><mo>,</mo><mo>查表得</mo><mi>a</mi><mi>b</mi></math></p></div><div class="tab-item-content" id="2-2"><p>提供128比特寄存器，直接操作128比特块</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="字节顺序控制"><a href="#字节顺序控制" class="headerlink" title="字节顺序控制"></a>字节顺序控制</h2></div><p>类型：大端寻址，小段寻址</p><h4 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h4><p>问题：不规定哪种顺序，会导致错误<br>解决：网络字节顺序按大端地址，主机字节顺序任意<br>问题：字节反转时，如果一个比特一个比特重排，则需n(n为比特数目)次操作<br>解决：利用指令并行来加速；或用特定快速比特算法。</p><p>注意：对于大端寻址而言，高位放在低地址，但单个字节内部的顺序不变</p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人生-价值</title>
      <link href="/posts/2.html"/>
      <url>/posts/2.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><script>    (function(d, w, c) {        w.ChatraID = 'D5JbrYK4vHavdTNTf';        var s = d.createElement('script');        w[c] = w[c] || function() {            (w[c].q = w[c].q || []).push(arguments);        };        s.async = true;        s.src = 'https://call.chatra.io/chatra.js';        if (d.head) d.head.appendChild(s);    })(document, window, 'Chatra');</script><h1 id="One-第九边缘关于人生的一个判断"><a href="#One-第九边缘关于人生的一个判断" class="headerlink" title="One:第九边缘关于人生的一个判断"></a>One:第九边缘关于人生的一个判断</h1><p>Six Sections about a real life 世界和人生需要精准和理性的维持<br>本文主要介绍了人生道路的分类方式，以及我们在不同阶段的思维方式和思维特征。并不是所有人都有正常完整的认知能力。批判的意义在于指出现有的不足，引导我们未来的盟友，和帮助我们完善体系。文章提供了多种关于人生的判断，包括但不局限于思维体系，理性规则。</p><hr><h2 id="第一部分-总则"><a href="#第一部分-总则" class="headerlink" title="第一部分-总则"></a>第一部分-总则</h2><h3 id="Part1：三生-六道"><a href="#Part1：三生-六道" class="headerlink" title="Part1：三生-六道"></a>Part1：三生-六道</h3><p>Descriptions-<br>灵无次始，六道极穷。三生万物，显隐其中。<br>心系万物，以语相通。（赋）【感知始】<br>虚实相生，驭时凌空。（幻）【感知末】<br>克本守矩，定秩寻规。（互）【记录始】<br>众生事态，相期与途。（独）【记录末】<br>聚灵敛力，善已无终。（谊）【创造始】<br>思己无物，纵其归风。（觉）【创造末】<br>三始三终，各彰其道。道本无意，竞逐方舟。</p><p>Structures-</p><h4 id="1-三生"><a href="#1-三生" class="headerlink" title="1.三生"></a>1.三生</h4><p>变化的前提-感知（意识引发，混乱）<br>变化的轨迹-记录（思维传导，中立）<br>变化的结果-创造（产生物质，守序）<br>创造之物是意识能力的延伸，感知之形是物质能力的内化。</p><h4 id="2-六道"><a href="#2-六道" class="headerlink" title="2.六道"></a>2.六道</h4><p>赋（木&#x2F;风），幻（冰&#x2F;金）<br>互（水&#x2F;土），独（阴&#x2F;阳）<br>谊（火&#x2F;雷），觉（光&#x2F;草）</p><h4 id="3-九灵"><a href="#3-九灵" class="headerlink" title="3.九灵"></a>3.九灵</h4><p>元：感知-心灵，记录-时间，创造-空间<br>赋：境际（一语联系万物）-现实<br>幻：思译（想法改变世界）-能力<br>互：溯流（按照轨迹前行）-过去<br>独：映影（信息皆有价值）-空泛<br>谊：俱形（后物延续先物）-未来<br>觉：自然（超理想初状态）-无我</p><p>Tips-<br>前者揭示含义，后者揭示主要体现</p><p>Tips-<br>世间万物不曾结束，六道渗透各方极力维持着它。<br>三生是万物的源头，使隐藏世间的奥秘显现出来。<br>心中能考虑着万物，用共同的语言，给予他们相应回答。<br>不断转化虚无实际，认知改变时代，用行动去控制时空。<br>克服欲望守着规矩，稳定世间秩序，去寻找它们的规则。<br>众多生命事件状态，与我一起约定，沿着我的方向前行。<br>聚集着各方的能力，完善发生之事，使其不会走向终结。<br>构造着真实的自己，放弃世俗之物，任凭它们归向虚无。<br>三个开始，三个末端。它们各自彰显自己的作用。<br>方向不为打扰，遵循心中所向，便是自己的道路。</p><h3 id="Part2：八大职责"><a href="#Part2：八大职责" class="headerlink" title="Part2：八大职责"></a>Part2：八大职责</h3><p>Structures-<br>1.寻理<br>抽化现实，解决深层问题。<br>2.支撑<br>具现万物，保障结构稳定。<br>3.武装<br>驱除异常，维持既有秩序。<br>4.承接<br>统领联系，优化运转方式。<br>5.援助<br>提供能量，促使持续发展。<br>6.医护<br>缝补缺口，调整不良状态。<br>7.广义<br>广泛分析，整体应对变化。<br>8.精确<br>精准处理，高效处理事物。</p><hr><h2 id="第二部分-人生"><a href="#第二部分-人生" class="headerlink" title="第二部分-人生"></a>第二部分-人生</h2><h3 id="Part1：人生发展阶段"><a href="#Part1：人生发展阶段" class="headerlink" title="Part1：人生发展阶段"></a>Part1：人生发展阶段</h3><p>Structures-<br>1.赋形<br>发现世界，观察外界，探索世界。<br>2.五芒<br>学习外界知识，思维依靠具体事物。<br>3.九虹<br>形成稳定思维，初步处理抽象事物。<br>4.灵耀<br>语言构建意识，反思世界追溯本质。<br>5.幽而<br>承纳多种思维，精细权衡多样表达。<br>6.结理<br>平视世界，勘破外界，淡处世界。</p><h3 id="Part2：思维活动方式"><a href="#Part2：思维活动方式" class="headerlink" title="Part2：思维活动方式"></a>Part2：思维活动方式</h3><p>Structures-<br>1.自临：参与者<br>一定价值在一定条件下，经过一定时间后生成更大的价值。<br>2.移灵：策略家<br>以一部分自身价值，快速换取更小一部分外界价值。<br>3.游平：事业家<br>与能力建立平等的关系，并且各能力间相互影响。<br>4.磁流：开拓者<br>以部分能力作为媒介，以不稳定的关系获取价值。<br>5.聚灵：维系者<br>当自身被特定理念触动时，该种理念失去影响。<br>6.汇形：为势者<br>建立在“灵耀”基础上的高效获利关系。<br>7.集影：领导者<br>处于特定环境时，获得不可断裂的具有时效性的价值。<br>8.除灵：破律者<br>通过破坏价值，来创造价值。<br>9.自然：升环者<br>不依赖具体物质，追寻思想构建的理念世界。</p><hr><h2 id="第三部分-灵魂"><a href="#第三部分-灵魂" class="headerlink" title="第三部分-灵魂"></a>第三部分-灵魂</h2><h3 id="Part1：Seasonal三生系统"><a href="#Part1：Seasonal三生系统" class="headerlink" title="Part1：Seasonal三生系统"></a>Part1：Seasonal三生系统</h3><p>Structures-</p><h4 id="思维系统"><a href="#思维系统" class="headerlink" title="思维系统"></a>思维系统</h4><h5 id="一．刺激处理"><a href="#一．刺激处理" class="headerlink" title="一．刺激处理"></a>一．刺激处理</h5><p>机体与外界交互的过程，就是机体接收信息和机体向外界传递信息的过程。外界传递给机体的信息以刺激的形式呈现。<br>1.刺激接收<br>机体接收外界刺激。<br>2.刺激呈现<br>机体在受到刺激后，调整对应状态。<br>3.刺激分析<br>机体分析刺激所呈递的信息。</p><h5 id="二．对抗反应"><a href="#二．对抗反应" class="headerlink" title="二．对抗反应"></a>二．对抗反应</h5><p>对抗反应是简单的适应性回路。其需遵守一定的自然规律，受机体主观意识影响小。其中模式反应指形成后无需机体做出过多判断便能够进行的活动回路。默然反应包含对特定事物的恐惧回路等。<br>1.接收-本态反应<br>生而有之的活动网络，但能通过后天减弱或加强。<br>2.呈现-模式反应<br>后天形成的活动网络，机体选择性表达。<br>3.分析-默然反应<br>后天形成的信息网络，受潜在意识支配。</p><h5 id="三．记忆复现"><a href="#三．记忆复现" class="headerlink" title="三．记忆复现"></a>三．记忆复现</h5><p>记忆可分为显态记忆和隐态记忆。显态记忆指可直接调动的，以意识活动呈递出的记忆，如切实发生过的事件；隐态记忆指不可直接调动，以能力、行为间接反应出的记忆，如知识、恐惧记忆。<br>1.呈现-刺激重塑<br>重新模拟刺激信息，避免可能危险的发生。<br>2.分析-记忆构建<br>构建记忆，形成稳定处理一类刺激的回路。<br>*特征-思想偏正：用自身记忆去分析事物时，会产生适应自己的偏差。</p><h4 id="四-意识构造"><a href="#四-意识构造" class="headerlink" title="四.意识构造"></a>四.意识构造</h4><p>意识构造指复杂的适应性回路。这类回路由机体后天习得，比简单的适应性回路更容易被改变。<br>1.接收-自我构造<br>形成自我概念：自身受到的刺激仅反馈给自身。<br>*特征-求异态：对高度相似但本质不同的事物的本能性向往。<br>2.呈现-行为构造<br>后天形成的对相似刺激的高相似应答的结构性结合。<br>*特征-并行处理：能够同时处理多种刺激信息的能力。<br>3.分析-印象构造<br>由可主动调取的指定节点的信息构成。<br>*特征-工具衰退：机体可支配的逻辑远比构建该机体的逻辑低级。</p><h4 id="物质系统"><a href="#物质系统" class="headerlink" title="物质系统"></a>物质系统</h4><h5 id="肢体协和"><a href="#肢体协和" class="headerlink" title="肢体协和"></a>肢体协和</h5><p>肢体协和指机体与其肢体活动的连接，是机体意识与身体机能所协调而进行活动的前提。<br>1.本态协和<br>进行生而有之的活动的保证。<br>2.条件协和<br>进行后天形成的行动的保证。<br>*活动类型：<br>随机模拟-机体自主、随机地产生活动。<br>行为渲染-机体因某种外界信息而产生活动。<br>刺激诱导-机体受到某种交互刺激而产生活动。</p><h5 id="信息调节"><a href="#信息调节" class="headerlink" title="信息调节"></a>信息调节</h5><p>信息调节指机体活动、行动受到调节的来源于信息的方式。<br>1.本态-物质调节<br>依赖于物质活动的调节。<br>*示例：交互调节-创口修复，药物治疗等依赖外界交互的调节。<br>2.条件-认知调节<br>依赖于意识活动的调节。<br>*示例：公序调节-社会道德，秩序规则等影响一类机体的调节。</p><h5 id="生命构造"><a href="#生命构造" class="headerlink" title="生命构造"></a>生命构造</h5><p>生命构造指机体的生命组成，包含物质和意识两部分。<br>1.本态-物质构造<br>组成机体的物质结构。<br>2.条件-意识构造<br>机体所具备的意识结构。</p><h4 id="人格系统"><a href="#人格系统" class="headerlink" title="人格系统"></a>人格系统</h4><h5 id="一．意识三人格"><a href="#一．意识三人格" class="headerlink" title="一．意识三人格"></a>一．意识三人格</h5><p>1．本态人格<br>满足生存需求的协和物质活动的先天回路，本态人格控制物质和机体。<br>本态人格进行物质联系，负责维持生存，保持精力和健康。</p><p>2．替身人格<br>为适应外界而产生的依赖意识的后天回路，替身人格控制意识和行为，解读外界刺激带来的信息和做出反应。<br>替身人格进行意识活动，负责体会世界，连接万物和自我。<br>*替身人格总体类型：<br>外倾：探寻外界，积极互动<br>内敛：探寻自我，构想世界<br>连接：共享联系，开放交流<br>分散：封锁联系，自主改变<br>善行：友好宽容，仁爱坚韧<br>恶意：直率审视，高效直接</p><p>3．植入人格<br>受非自然刺激（如学习），或因双人格协和而产生的作用于高级认知的后天回路，植入人格控制学习和感知，拥有一定的协调“自我”的能力（如辩驳，信仰）和一部分基本生命活动的控制权。<br>植入人格进行高瞻远瞩，负责找到方向，分散未知和挑战。<br>*植入人格总体类型：<br>寻世型：归纳特征和现象<br>探世型：解释本质和规律<br>联合型：寻找共性和关系<br>分立型：寻找差异和价值<br>可觉型：用感受体会万物<br>可视型：用语言抽化万物</p><h5 id="二．四位构建"><a href="#二．四位构建" class="headerlink" title="二．四位构建"></a>二．四位构建</h5><p>1.本我与联想<br>感知世界，探索世界，进行思考的“我”。<br>2.辩驳对象<br>因自我辩驳，分析问题而产生的“我”。<br>3.随意和理性<br>因对待万物的态度分立而产生的对立统一的“我”。<br>4.他我<br>因他人而产生的，有意在他人面前表现出来的“我”。</p><h3 id="Part2：T-try拓源系统"><a href="#Part2：T-try拓源系统" class="headerlink" title="Part2：T-try拓源系统"></a>Part2：T-try拓源系统</h3><p>Structures-<br>1.未知<br>散：机巧灵动，不断探索，分步解决。<br>合：结果至上，利用规则，适时放弃。<br>2.恐慌<br>散：冷静思考，积极行动，寻求帮助。<br>合：抑制表象，避免视线，模仿他人。<br>3.敏感<br>散：倾听内心，释放情绪，展示想法。<br>合：平和思考，收敛行为，约束表达。<br>4.煽情<br>散：隔离情感，追寻真相，交流看法。<br>合：理性分析，保持旁观，谨慎表态。<br>5.压力<br>散：积极响应，克服障碍，紧随目标。<br>合：充分准备，分散重心，降低期待。<br>6.剧变<br>散：利用情绪，把握细节，主动出击。<br>合：保持冷静，维持理智，制定策略。<br>7.低迷<br>散：寻找支持，积极交流，制定计划。<br>合：避免接触，规律生活，转移目标。<br>8.逐求<br>散：保持平衡，调整状态，探求新知。<br>合：化大为小，规律应答，优化行动。<br>9.厌恶<br>散：保持真诚，尊重感受，有效协调。<br>合：伪装礼貌，考虑迎合，平和应对。<br>10.喜爱<br>散：保持客观，积极探索，乐于分享。<br>合：留存未知，保持距离，自私独立。<br>11.威胁<br>散：寻求帮助，卸其武装，提前防备。<br>合：假意妥协，避免接触，诱其迟钝。<br>12.排斥<br>散：稳定心态，客观分析，寻求症源。<br>合：自然而然，当行则行，当止则止。</p><h3 id="Part3：X-try析源系统"><a href="#Part3：X-try析源系统" class="headerlink" title="Part3：X-try析源系统"></a>Part3：X-try析源系统</h3><p>Structures-</p><h4 id="一、析源态度"><a href="#一、析源态度" class="headerlink" title="一、析源态度"></a>一、析源态度</h4><p>1.怜悯：由上而下的包容<br>怜悯意味着你应该具备有层次的包容。产生的原因来自你对低层次的维护，或受到高层次压力时，出于对低层次的维护而产生的必要的对压力的容忍。</p><p>2.平等：由心而发的正视<br>平等意味着你处理事物时应不具备层次，展现出更加公正也更加直观的态度。平等是一个局部概念，但它不意味着孤立和草率，而是意味着“平等”双方转换差异的过程需要代价。</p><p>3.契合：灵魂相似的陪伴<br>契合意味着你认可的对方应当在价值观相容的基础上，与自身价值存在互补。即在追寻灵魂高度的共性的时候，保护对方个性的出色之处。</p><p>4.契约：高于自身的恪守<br>契约意味着你应该拥有更强的意志和信念，高于自身存在的不可轻易瓦解之物。即便身处黑色和低谷，也不应该放弃追寻光明的渴求。</p><h4 id="二、析源标准"><a href="#二、析源标准" class="headerlink" title="二、析源标准"></a>二、析源标准</h4><p>1.简练：简化表达<br>简笔勾勒，便表达关键信息。避免思维惰性的同时，我们也不需要冗余之物来增加信息门槛，或支起学识的渊博。不过，核心需要平凡的结构去撑起，表达核心的同时也需要重视繁琐平淡的结构。</p><p>2.相和：避免情绪<br>接纳不同的观点，尽可能平和中立地对待它们。保持情绪稳定，才能更好地观察和利用外界。</p><p>3-1.理性：追求实质与中立<br>任何事物需成立，必先证实其价值。用价值不断考验事物，将得到更加有效的价值。理性的准则是：蔑视偏见、正视情绪、不断超越。理性意味着全面考虑和尊重现实，而不具备敷衍冲撞，片面孤立的低级非理性特征。维护对立面，约束小便宜，强调客观平等，重视逻辑事实并不是理性的缺陷，而是非理性存在的漏洞需要修复。</p><p>3-2.感性：保证时效与温情<br>感性可以快速、高效地调动更多的力量和做出反应，也能为我们的理性分析提供更多的材料。我们在感性分析时，需要接收尽可能多而全面的信息，以免立场受到繁杂的表象影响而不断改变。感性与理性从不对立，漠视规则，把不服从个人偏见的表象归结为错误是低级感性的特征，木讷死板，热烈批驳不合客观逻辑的事物是低级理性的特征。</p><p>4.合理：合乎事实<br>认知来自实际。我们需要让我们的认知更有实际含义，以及谨慎考虑违背实际的认知。合理不是一种妥协，而是说我们不应该过于冒犯。同时，任何事物都有其前提和基础，前提和基础一旦改变，事物允许改变。即便是许诺或者契约，在前提和基础改变后也未必要遵守。</p><h4 id="三、析源关系"><a href="#三、析源关系" class="headerlink" title="三、析源关系"></a>三、析源关系</h4><p>1.协和：共同作用，特征灵活<br>协和的事物在表观上能达到协，并可能带来单一事物不具备的新特性。</p><p>2.关联：恰时出现，连锁反应<br>关联是一种未必真实的关系，但这种具备不确定性的关系，可以快速被我们发觉和利用。</p><p>3.矛盾:属性同一，性质分立<br>有些事物不可单独出现，但出现时又需将该物区分。例如木板在特定位置被称作门，被称作门时是指代该木板而非其他物。</p><p>4.逻辑:万物相连，牵一而发<br>我们并不需要急于去寻找因果。因果关系只是基于时间的表观联系，事物间往往有更加复杂的逻辑关系。</p><h4 id="四、析源手段"><a href="#四、析源手段" class="headerlink" title="四、析源手段"></a>四、析源手段</h4><p>1.重新评估<br>每隔一段时间或经受重大事件后，重新判断目标对象的性质，明确知晓其对自身的价值。这需要我们找对问题的切片，将一个复杂问题分解为多个仅需要回答是或否的判别问题。</p><p>2.调解<br>在得到针对具体事物的具体回答前，允许自身思维中存在相互冲突的想法，在有绝对的具体把握之前，保证他们能和谐共存。</p><p>3-1.定界<br>对于已有信息，或自身处理的信息，应该保证其每一部分描述中指代的含义和实际的含义一一对应。然而事物的界限往往是模糊的，故定界标准需要依赖于具体事物的本质和量度。</p><p>3-2.捆绑<br>将抽象的概念和实际的行动捆绑在一起，以达到扩大利益的目的。例如捆绑信念和必要工作，在保障结果的同时降低成本。</p><p>4.符号<br>明确区分理想的符号和其在现实世界的暂时性寄托，不沉迷或过度追求现实中的某个事物。</p><h4 id="五、析源结构"><a href="#五、析源结构" class="headerlink" title="五、析源结构"></a>五、析源结构</h4><p>1.建构<br>实现目标时，应从表及里建构一系列“规则”。它们包含：途径分支，目标本身，对己影响，对物影响，退出方式。同时，我们做一件事时，要考虑:个人意愿与责任、效果与执行难度、共识与替代方案、原因、目的与要求、具体行动与处理态度。与人交流时，应该关注交流态度、交流目的、待解决问题、延伸问题、细节暗示。</p><p>2.虚构逻辑<br>我们并不需要理解一些事物的本质和真实正确的规律。构建一种基于应付或应用的逻辑，并且在满足已知案例后不断完善。组成为：已知输入，处理回路，正确输出。</p><p>3.学习：价值分析 2024-12-29<br>价值由环境赋予。事物价值(v)因对象差异在同一时间产生多份不可叠加的流动价值(w,v&gt;&#x3D;w)，流动价值除去运作消耗价值(s)与无法直接利用但能影响技艺状态的并行价值(m)后,剩余的必要价值(w-s-m)通过技艺传递及放大构成积蓄价值(t,t&gt;&#x3D; w-s-m)，积蓄价值中包含价值w2(w2&#x3D;w)即完成等价交换。<br><img src="/pictures/value.png" alt="价值分析"></p><p>4.区域分析<br>分析事物时，首先考虑整体的逻辑合理性。即呈现给你的信息是否是片面的、是否是有意误导的、是否是刻意虚构的。其次才是对这些信息进行逻辑分析。这需将事件划分为多个区域，分析各个区域及区域联系的合理性。一般的流程为：展现对方的观点，指出支持对方观点的证据，再分析这些证据，肯定有效的证据，将有瑕疵的证据转化为对自己观点有利的部分，最后表达自己的观点，提出一些转化对方观点或实现自身观点的方法。</p><p>5.神经网络模型<br>神经网络模型以人类的智慧统合世界的智慧，突破生物思维带来的局限。神经网络模型代替的是不具备思想内核简单活动，技术的发展会进一步筛除不具备超强创新力的创造物。<br>神经网络模型有以下功能：<br>1.统合已有的智慧：减少无意义的知识重叠，降低知识获取的门槛，让正确性筛选更加平等有效。<br>2.减少无必要劳动：减少不具备的学识带来的磨耗，减少格式化的表达带来的繁杂，充分利用已有的成果。<br>3.稳定安全的交互：稳定的回复风格和封闭式的交互，更能使我们持续高效地提出真实的想法，并能得到不具备社会偏见的回复。<br>4.协助创意和思考：知识水平和经验经历会限制我们思考的范围，不具备明显倾向性但专业的回复往往能为我们提供关键的想法。<br>不过，神经网络的使用注定会加剧认知降级。当情绪表达和理性分析分开时，矛盾而非冲突将成为人类认知的主流色彩。</p><p>6.提高意识能力<br>意识能力包含处理语言信息的能力、处理逻辑运算的能力、强化和描述记忆的能力、维持感官静态而稳定的能力、快速搜索信息的能力、学习知识，分析问题，接纳理论的能力。<br>7.认清骗局<br>1.全面发展骗局：教育方式<br>只提供使你成为工具的资源，却以全面发展为由强迫你为其创造更多的零成本价值。没有人需要热爱自己谋生的手段，更何况全面发展的目的在于让我们更好地应对抽象的问题和挑战。我们应当感恩人生塑造和保护帮助，但谨慎感恩互相利用的工具式培育。</p><p>2.一致对外骗局：激进爱国群体<br>维护不应通过排外来彰显，血脉躯体不应成为精神自由的枷锁。假借信念之名，对人格化的抽象对象施以出于生物破坏本能的抨击，不应该引起同类的赞颂。形式化的重情重义护己排外，不应该成为忠诚高尚的选择，也不应该成为统一战线的表达。</p><p>3.娱乐害人骗局：长辈群体<br>娱乐是文明，哲学，精神的载体，体现着科学技术和文化水平的发展程度。没有任何一种合理合法的娱乐会毁掉一个人的前途，唯一败坏的只有那本就残枝败叶般的认知体系：浅薄和贪婪的本性使一部分人沉迷于既得刺激，而忽略更重要的发展价值。</p><p>4.本意善良骗局：浅薄帮助<br>只管行善，莫问前程？若莫问前程，极易成为见人开药，而忽视疗效的庸医。本意的善良，也应该考虑外界的客观因素。善意无法保证善的结果，就如精神满足的仪式感不应该破坏我们对物质的正常需求：善意和虚假只有一线之隔。</p><p>5.宽容大度骗局：学生群体<br>许多庸人并不希望其他人争取到合理的权益:他们把迟钝当成一种遮挡软弱的美德，但又无法放弃指责他人的快感。这类人往往以一种自认幽默风趣的语调，强迫他人和自己一样虚伪粗劣，在成为受益方帮凶的同时，助长为非作歹的风气。</p><h3 id="Part4：S-try亚式思维系统"><a href="#Part4：S-try亚式思维系统" class="headerlink" title="Part4：S-try亚式思维系统"></a>Part4：S-try亚式思维系统</h3><p>Structures-</p><h4 id="一：意识"><a href="#一：意识" class="headerlink" title="一：意识"></a>一：意识</h4><p>获得，处理信息并做出反馈的能力。其包含：</p><h5 id="1-意识力"><a href="#1-意识力" class="headerlink" title="1.意识力"></a>1.意识力</h5><p>发展过程：自我封闭→类别固有→低频互动→理智平和<br>模仿世界运行规律而产生的预处理外界信息的能力。意识力远重于智力和操纵力。即“可以不做，不可不知。”理智指有道德约束的理性。其包含：<br>1.注意力<br>对特定信息保持敏锐的能力<br>2.维持力<br>维持意识相对稳定的能力<br>3.辨识力<br>定义或比较事物特征的能力<br>4.构建力<br>构建稳定或暂时性场景的能力<br>5.量度力<br>划分事物不同程度的能力<br>6.心性<br>对根本性刺激反应的强弱</p><h5 id="2-智力"><a href="#2-智力" class="headerlink" title="2.智力"></a>2.智力</h5><p>发展过程：低智稳定→封锁愚昧→自我突破→高智相和<br>专精地处理抽象事物的能力。自身的天赋部分地决定学习的起点和智力的上限，后天的学习极大地提高智力的水准。其包含：<br>1.抽化力<br>将事物转化为有效信息的能力<br>2.逻辑力<br>对抽象事物进行转换或运算的能力<br>3.认知力<br>迁移知识和认识的能力<br>4.洞察力(深层学习)<br>探究和寻找正确信息的能力<br>5.表达力<br>描述事物的能力<br>6.领悟力<br>跳跃地获取正确结果的能力<br>*学习模式可按不同标准分为灌输式学习、自主学习、激励学习；分立学习、统合学习；任务性学习、持续学习。</p><h5 id="3-操纵力"><a href="#3-操纵力" class="headerlink" title="3.操纵力"></a>3.操纵力</h5><p>发展过程：增强→波动→下降→稳定<br>广泛地处理具体事物的能力。其包含：<br>1.反应力<br>快速对信息进行应答的能力<br>2.记忆力(浅层学习)<br>复用具体事物的能力<br>记忆力和天赋一样，具备针对性。某种具体的记忆力是某种具体天赋的先导：当你对某一件事物有较强的天赋的时候，往往会忽略掉极佳地记忆它的过程，而认为自己并没有显式地记忆。针对记忆能力的记忆天赋，对外表现为广泛的记忆能力。<br>3.模仿力<br>依赖于预设规则的能力<br>4.交流力<br>使用语言交流的能力<br>5.创造力<br>实时构建事物的能力</p><h4 id="二：调节"><a href="#二：调节" class="headerlink" title="二：调节"></a>二：调节</h4><p>调节行为的能力。其包含：</p><h5 id="1-人格"><a href="#1-人格" class="headerlink" title="1.人格"></a>1.人格</h5><p>相似回路和诱发特征的结合体。其包含：<br>1.气运<br>气数和命运<br>2.记忆<br>可被调用的经加工处理的信息<br>3.性格<br>较稳定的态度和行为方式<br>4.追求<br>有意维持或致力的事物<br>5.精神<br>影响物质状态的心理状态</p><h5 id="2-道德"><a href="#2-道德" class="headerlink" title="2.道德"></a>2.道德</h5><p>公认的约束，强权的文化。其包含：<br>1.约束<br>减少仅对己有利的行为<br>2.教养<br>尊敬他人感受的具体表现<br>3.风尚<br>社会需要和维护的价值取向<br>4.体面<br>符合身份，被动伪装</p><h5 id="3-情感"><a href="#3-情感" class="headerlink" title="3.情感"></a>3.情感</h5><p>生理引发的评价和体验。其包含：<br>1.情绪<br>不稳定的心理活动<br>2.态度<br>依赖具象事物的看法<br>3.连接<br>认同的集体或归属<br>4.气氛<br>外界烘托的感触方向</p><h4 id="三．引导"><a href="#三．引导" class="headerlink" title="三．引导"></a>三．引导</h4><p>接受引导的能力。其包含：</p><h5 id="1-意志"><a href="#1-意志" class="headerlink" title="1.意志"></a>1.意志</h5><p>超越自身的稳定存在。其包含：<br>1.知识<br>用科学语言描述的世界<br>2.物质<br>不再发的思维，稳定传播的组合<br>3.自然<br>天地的引导<br>4.责任<br>被赋予的要求<br>5.信仰<br>高于生命的引导</p><h5 id="2-天性"><a href="#2-天性" class="headerlink" title="2.天性"></a>2.天性</h5><p>生命带来的能力。其包含：<br>1.思考<br>总结归纳，逻辑推理<br>2.生存<br>活着，繁衍，协助同类<br>3.活动<br>为更好地生存而引发的状态改变</p><h5 id="3-本性"><a href="#3-本性" class="headerlink" title="3.本性"></a>3.本性</h5><p>一切活动的源头。其包含：<br>1.懒惰<br>混淆或回避不悦之物<br>2.软弱<br>怜悯或维护弱小之物<br>3.欲望<br>占据或渴求美好之物<br>4.破坏<br>扭曲或消除冲突之物</p><hr><h2 id="第四部分-条约"><a href="#第四部分-条约" class="headerlink" title="第四部分-条约"></a>第四部分-条约</h2><h3 id="Part1：三生之法"><a href="#Part1：三生之法" class="headerlink" title="Part1：三生之法"></a>Part1：三生之法</h3><p>Structures-</p><h4 id="感知"><a href="#感知" class="headerlink" title="感知"></a>感知</h4><p>木：依托外物，由心生境<br>风：听其所向，自有所往<br>冰：意念凝形，状态显化<br>金：天理驱使，规则限制</p><h4 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h4><p>水：承纳世界，相和共生<br>土：既定之道，相与为一<br>阴：约束存在，潜伏于世<br>阳：区分差异，凸显自身</p><h4 id="创造"><a href="#创造" class="headerlink" title="创造"></a>创造</h4><p>草：明确目标，不断推进<br>雷：及时发展，持续更替<br>光：虚化外物，塑造能力<br>火：构建优解，化异为同</p><h3 id="Part2：阴阳衡术"><a href="#Part2：阴阳衡术" class="headerlink" title="Part2：阴阳衡术"></a>Part2：阴阳衡术</h3><p>人是冲突认知的集合，精神力量的脆弱会使其无法正常活动。常见的认知缺乏的病症体现为：糊弄、冒犯、妄想、轻浮、强辩。若需阴阳调和，则应顺从自然。<br>Structures-<br>1.留存未知，无需逾越。<br>2.敏锐觉察，适时改变。<br>3.守护阴暗，留存希望。</p><p>4.及时决策，减少拖延。<br>5.循序渐进，多向共行。<br>6.批判低劣，维持距离。</p><p>万象有阴阳。<br>据阴动阳，控阳聚阴，阴阳平衡，万象可控。<br>万物凝虚实。<br>晓虚破实，占实凝虚，虚实均衡，万物可知。</p><h3 id="Part3：三位一体（规律无常-不具目的-依赖外界）"><a href="#Part3：三位一体（规律无常-不具目的-依赖外界）" class="headerlink" title="Part3：三位一体（规律无常-不具目的-依赖外界）"></a>Part3：三位一体（规律无常-不具目的-依赖外界）</h3><p>Structures-</p><h4 id="恶意"><a href="#恶意" class="headerlink" title="恶意"></a>恶意</h4><p>贪婪&#x2F;上进:妒他厌异-无度索取-压榨剥削</p><p>纯善&#x2F;高洁:自我感动-极致纯粹-过度奉献</p><p>狡诈&#x2F;机敏:情感诱导-精神孤立-规则迫害</p><p>自恃&#x2F;自信:轻视未知-高捧自身-伪造真相</p><p>怠惰&#x2F;稳定:愚昧迷信-安分弱势-回避被动</p><p>偏执&#x2F;锐利:思维片面-交集杂化-态度顽劣</p><p>野蛮&#x2F;坦诚:浅薄冒犯-直率利己-冲击约束</p><p>*思维片面：仅仅处理部分的信息<br>*交集杂化：抗拒抽象无关的细节</p><h4 id="智慧"><a href="#智慧" class="headerlink" title="智慧"></a>智慧</h4><p>掌控:虚构回路-把控变化-穷观全局</p><p>模仿:普遍应答-复刻表态-保持同步</p><p>敏锐:极简高效-灵敏机灵-细致精准</p><p>乐观:热情好奇-认同自身-勇敢积极</p><p>约束:控制欲望-简化表达-敬畏外界</p><p>*虚构回路：抽象的建构；深度学习的表现<br>*复刻表态：具象的复制；低级学习的表现<br>*普遍应答：模仿大众化的行为<br>*保持同步：模仿周围人的行为</p><h4 id="守护"><a href="#守护" class="headerlink" title="守护"></a>守护</h4><p>抑性:平和宽容-自觉自律-谦虚谨慎</p><p>循规:理性思辨-客观公正-务实求真</p><p>护佑:亲和开放-奉献负责-坚韧无私</p><p>重形:优雅崇高-守正创新-自立真挚</p><h3 id="Part4：思维规划"><a href="#Part4：思维规划" class="headerlink" title="Part4：思维规划"></a>Part4：思维规划</h3><p>Structures-</p><h4 id="1-开端也是结局：世界，无比真实：对世界本质的整体把握"><a href="#1-开端也是结局：世界，无比真实：对世界本质的整体把握" class="headerlink" title="1.开端也是结局：世界，无比真实：对世界本质的整体把握"></a>1.开端也是结局：世界，无比真实：对世界本质的整体把握</h4><p>SCHNIE.世界无所谓真实与虚幻，我们希望能够活在属于自己的理念世界里。<br>万物客观存在，还是受限于观测者？<br>事物性质是可知的，还是不可明确？<br>事物根本上是统一的，还是各自划分区域？</p><h4 id="2-稳定但是多变：思维，融于物质：对事物逻辑的规范划分"><a href="#2-稳定但是多变：思维，融于物质：对事物逻辑的规范划分" class="headerlink" title="2.稳定但是多变：思维，融于物质：对事物逻辑的规范划分"></a>2.稳定但是多变：思维，融于物质：对事物逻辑的规范划分</h4><p>SCHNIE.世界由物质构成，可物质以思维为形式，投递到我们的意识之中。<br>事物有哪些存在方式，他们之间的联系是什么？<br>我们能获得哪些信息，他们之间的联系是什么？<br>事物间有哪些关系，这些关系的联系是什么？</p><h4 id="3-世界起源：能量与时间差：发展与起源"><a href="#3-世界起源：能量与时间差：发展与起源" class="headerlink" title="3.世界起源：能量与时间差：发展与起源"></a>3.世界起源：能量与时间差：发展与起源</h4><p>SCHNIE.能量不均导致时间流动，而时间流动激化思维，进一步演变成物质。<br>发展和更替是无限的，还是存在端点？<br>起源和覆灭是明确的，还是混沌一体？</p><h4 id="4-矛盾产生：这成必要决断：选择与取向"><a href="#4-矛盾产生：这成必要决断：选择与取向" class="headerlink" title="4.矛盾产生：这成必要决断：选择与取向"></a>4.矛盾产生：这成必要决断：选择与取向</h4><p>SCHNIE.矛盾的出现，使万物万事凝聚成该有的形状。<br>真理和价值是客观规定的，还是个性化选择？<br>理论和认知是逐步完善的，还是虚构的逻辑？</p><h4 id="5-故事开端：我们为何生活：生存与生活"><a href="#5-故事开端：我们为何生活：生存与生活" class="headerlink" title="5.故事开端：我们为何生活：生存与生活"></a>5.故事开端：我们为何生活：生存与生活</h4><p>SCHNIE.生活是社会赋予的职责，同时也能填补不平衡的内心。<br>在你的世界观里，维持生存有哪些必然因素？<br>在你的世界观里，追求生活有哪些不同方式？</p><h4 id="6-恪守本分：臣服乃是前提：社会与自我"><a href="#6-恪守本分：臣服乃是前提：社会与自我" class="headerlink" title="6.恪守本分：臣服乃是前提：社会与自我"></a>6.恪守本分：臣服乃是前提：社会与自我</h4><p>SCHNIE.在有能力质疑或改变一件事之前，必经臣服。<br>外界秩序和更优策略发生冲突时，如何处理？<br>社会道德和个人判断发生冲突时，如何评判？</p><h4 id="7-维系深井：认知存在局限：实力和认知"><a href="#7-维系深井：认知存在局限：实力和认知" class="headerlink" title="7.维系深井：认知存在局限：实力和认知"></a>7.维系深井：认知存在局限：实力和认知</h4><p>SCHNIE.智慧徒增伤感，没有实力之前，请甘于维护愚昧。<br>实力不足以支撑认知时，认知是什么地位？<br>所处环境不认可实力时，实力是什么地位？</p><h4 id="8-遗忘但是存在：意识，还是事实：对自我存在的空泛认知"><a href="#8-遗忘但是存在：意识，还是事实：对自我存在的空泛认知" class="headerlink" title="8.遗忘但是存在：意识，还是事实：对自我存在的空泛认知"></a>8.遗忘但是存在：意识，还是事实：对自我存在的空泛认知</h4><p>SCHNIE.承载已发生之事的记忆，决定着“我”是谁。<br>自我和他我的界限是什么？<br>不同阶段自我界限是什么？<br>“自我”的概念依赖什么而产生？</p><h4 id="9-终端也是启程：世界，本成一线：对一切概率的均衡判决"><a href="#9-终端也是启程：世界，本成一线：对一切概率的均衡判决" class="headerlink" title="9.终端也是启程：世界，本成一线：对一切概率的均衡判决"></a>9.终端也是启程：世界，本成一线：对一切概率的均衡判决</h4><p>SCHNIE.所有可能都在实际发生，我们做出的选择，是自己与自己的争斗。<br>万事皆可存在，还是依赖逻辑？<br>事物早已决定，还是无限可能？<br>追求注定随生命而消逝的未来，究竟是为了什么？</p><hr><h2 id="第五部分-语言"><a href="#第五部分-语言" class="headerlink" title="第五部分-语言"></a>第五部分-语言</h2><h3 id="Part1：聚神生灵"><a href="#Part1：聚神生灵" class="headerlink" title="Part1：聚神生灵"></a>Part1：聚神生灵</h3><p>Descriptions-<br>1.自然无灵，赋灵者以平等身份赋万物灵魂，才会受其客观到主观的影响。<br>2.赋灵对象拥有和赋灵者相同的思维体系。<br>3.对自身产生的思维赋灵是提升思维能力重要途径。自身赋灵数越多，灵魂稳定程度越低。自身赋灵能使不同思维间产生交流能力。<br>4.被赋灵者对一定范围内的赋灵者精神状态有一定影响。<br>5.赋灵的形式包括精神触动、物质交互。<br>6.赋灵会对主体造成持续的能量损耗，主体能量不足以维持众多联系时，主体会丧失部分与客体的联系。<br>7.赋灵的对象包括高等生物，自身思维，抽象概念，及带有明显概率性的非生物。<br>8.赋灵不可传递，且不具备对称性。<br>9.赋灵是对文明历史的传承，是不同思维体交涉的途径，更是维持时空相对稳定的根本原因。</p><h3 id="Part2：第九理性"><a href="#Part2：第九理性" class="headerlink" title="Part2：第九理性"></a>Part2：第九理性</h3><p>观察行为本身，也会让我们陷入困境。谨慎而又深刻地对待世间万物，方为第九理性。<br>Descriptions-</p><h4 id="1-吸纳共性"><a href="#1-吸纳共性" class="headerlink" title="1.吸纳共性"></a>1.吸纳共性</h4><p>同万物而非同类竞争。<br>世界共享，共同维护。<br>利用规则，尊重规律。<br>把握实质，寻求症源。<br>保证状态，注重气氛。<br>知情达理，尊重家庭。<br>在进行中寻找更优途径。<br>思路决定出路，环境塑造人生。<br>流动产生质量，稳固滋生腐烂。</p><h4 id="2-弱化差异"><a href="#2-弱化差异" class="headerlink" title="2.弱化差异"></a>2.弱化差异</h4><p>不轻视、轻易否定任何形式的信息。<br>我只活一次，我允许任何事发生。<br>各自发展时各自平等，指定需求时自有层次。<br>不反感理论，不鄙视现实。<br>存护善意，即便虚假。<br>适当隐瞒，保留底牌。<br>主动学习，敬重知识。</p><h4 id="3-平等交流"><a href="#3-平等交流" class="headerlink" title="3.平等交流"></a>3.平等交流</h4><p>尊重他人的意愿、隐私和自由。<br>给予之前，确保对方愿意接纳。<br>不动声色地帮助他人走出窘迫之地。<br>在自证清白之前，先反击他人诋毁你的手段。<br>不谋关系，不受怜悯。<br>无需过多回应他人的期待。<br>不存共利，互不干扰。<br>无论承诺的对象是否浪费无用，都不可轻易动摇承诺。<br>不存理所应当。<br>熟悉不是掌握，帮助并非施舍。<br>直接并明确地沟通，凸现个人的需求和边界。<br>被迫同意不等同于同意。<br>认真整理思绪，而非急于找到一个偏见来回击。</p><h4 id="4-相和处事"><a href="#4-相和处事" class="headerlink" title="4.相和处事"></a>4.相和处事</h4><p>不被传统约束，但守己见同时保守处事。<br>用低素质干扰低素质，是一种手段而非方法。<br>有分寸地付出，保持自己的边界。<br>保留学术的严谨，认同生活的广泛。<br>为达目的，慎选手段。<br>关系身边的人，追寻自己喜欢的事。<br>爱得具体，爱得真挚。<br>谨慎表态，慎重拒绝。<br>自嘲不用于他嘲。<br>以效率考量万物，以公平管控利刃。</p><h4 id="5-批判权威"><a href="#5-批判权威" class="headerlink" title="5.批判权威"></a>5.批判权威</h4><p>谨防信念闭锁认知。<br>重量过度的弱势“真相”传的远，还得靠傻子。<br>犯人惩罚不合流程的帮助，却忽视无人知晓的冷漠。<br>比起单纯的愚昧，我们更抵触满是阴险的纯粹光辉。<br>对恶意的善是为肮脏的恶，对善意的恶是为虚伪的善。<br>谨慎对待捆绑正向词汇的对象，利用负面影响。<br>不用自身表达观点的自由否定别人表达观点的自由。<br>如果无法面对恶，那便没有资格拥抱善。<br>相对错误而言是错误的行径，可为合理行径。<br>正义若浮于表面，那脏劣早已渗透入骨。<br>不合理需要纠正，而不是用另一个不合理来覆盖。<br>稳定的上一步是破坏平衡。<br>财富无法共享，罪恶无需分摊。<br>迟到的正义叫做无赖。<br>和资源不匹配的节俭，是一种自私的愚蠢。<br>善于享受，君子不器。<br>给科学留有足够纯粹和自由。<br>弱势的手段不值得肯定，恶意的控制未必要否定。<br>远离低等的苦难。<br>权威的力量不应来自否定和强迫。</p><h4 id="6-抵抗愚昧"><a href="#6-抵抗愚昧" class="headerlink" title="6.抵抗愚昧"></a>6.抵抗愚昧</h4><p>保护自己的隐私。<br>不要让苦难成为唯一拿得出手的东西。<br>别让惰性破坏价值。<br>既有实力，那便无忧开放包容。<br>贪婪是一种失格，而不是一种智慧。<br>包容更温和，尖锐更有力。<br>优先判断事物的合理性。<br>正义需要承担责任，拒绝免费的正义。<br>情绪价值不该被冠以正义之名。<br>比起威胁，威慑更是一种高效体面的手段。<br>未知全貌，不予置评。<br>愚者可畏，在于人多。<br>把握感性的量度。<br>事情严重并不代表可信。<br>合理的事物以不合理的形式表现出来，会失去合理的特性。<br>选择性谅解他人的失误。<br>能者多劳，无能少劳，有需尽劳，无需慎劳。<br>不毁坏触手可得的回报。<br>估价自己的时间。与其对外贱卖，不如自行浪费。<br>知识是我们认识世界的钥匙，但不是感受世界的屏障。</p><h4 id="7-承认现实"><a href="#7-承认现实" class="headerlink" title="7.承认现实"></a>7.承认现实</h4><p>在主动尝试新事物之前，必有能力承担后果。<br>不过于理想化，接受现实的伪诈。<br>软弱的阳光，照不进不可能的现实。<br>可恨之人必有可悲之苦。<br>成就不意味成长。<br>任何事物都无法在庇护下成长，因为他给的不够多。<br>敢于反击才能保护自己。<br>能力存在限度。<br>专业人做专业事，不轻易求助熟悉但不深刻了解的人。<br>忘记应当被舍弃的事物。<br>珍惜祝福和奇迹。<br>相信事在人为，并积极迎接未知的挑战。<br>客观事实，无需投票。<br>热爱是使人失去度量，陷入狂热的陷阱。<br>在一些无伤大雅的小事上，没必要为了正确而正确。<br>学会表里不一，有时人际比智慧更有益。<br>克制不了发展，那就避免接触。<br>考虑成本，在意磨损。<br>时间不足以弥补效率上的欠缺。<br>坚持的过程会失败。<br>凭努力胜过敷衍，因效率败给天赋。<br>接纳精神消费，重视物质回报。<br>成败决定细节。<br>不回避生活里的无力和污秽。</p><h4 id="8-认同自身"><a href="#8-认同自身" class="headerlink" title="8.认同自身"></a>8.认同自身</h4><p>先热爱，再规范。<br>勤学善娱，内敛自谦。<br>独立自信，不断创造。<br>场合引导能力。<br>一件事情的发生并不能带来直接的情绪后果。<br>不轻贱自己的承诺。<br>清醒停留，胜过盲目前行。<br>在寻找人生方向上的弯路，并不徒劳。<br>无论过去如何，应不以此过分顾虑将来。<br>内心的强大，永胜过外表的浮华。<br>选择清高，那便无需在意世俗评价。<br>若追寻更高的高度，便无需自施枷锁。<br>远离边缘和庸俗，匹配更优秀的世间万物。<br>有些事情，并非明知前路混沌，便可以不去做。</p><h3 id="Part3：主控因素-UPDATE-2024-11-27"><a href="#Part3：主控因素-UPDATE-2024-11-27" class="headerlink" title="Part3：主控因素 UPDATE:2024-11-27"></a>Part3：主控因素 UPDATE:2024-11-27</h3><p>Structures-<br>第一类为随机因素，第二类为重要性递减的关键因素，第三类为不分主次的其他因素。</p><h4 id="1-情感"><a href="#1-情感" class="headerlink" title="1.情感"></a>1.情感</h4><p>果不可代因，往不可还来，正是因为有情感存在。情感将我们与世界联系起来，是永不可灭的纽带。即便那是错误的，但我们总能在考验中获得磨砺和启示，建立正确的价值观。</p><h4 id="2-1-1安逸"><a href="#2-1-1安逸" class="headerlink" title="2.1-1安逸"></a>2.1-1安逸</h4><p>生而安逸。生活使我们忙碌起来，然后再回到安逸。安逸是一切行动的根本，也是一切行动的究极目的。</p><p>2.1-2价值<br>价值是主观选取的蕴含于客观事物的积极影响。人生总是不断完善的，对价值的倾向决定我们前行的收获。</p><p>2.2-1信念<br>信念是人主观塑造的高于自身的精神力量，支撑我们在每一个昏暗时刻前行。信念脆弱的人，败于自毁。</p><p>2.2-2利益<br>利益是事物的内核。在利益问题上，我们不要指望他人的通融或是善意，而是学会必要的掩盖和变通。</p><p>2.3-1规章<br>我们若过早反抗规章，则容易失去潜在的效益，或见证秩序的崩坏。不过因自身埋汰而被规章针对，并非规章的错误。</p><p>2.3-2秩序<br>在明面上，我们的所作所为应先考虑他人和社会,这也是一种对自己的间接保护。追寻后天的平等，方使公正的秩序凝结。</p><p>2.3-2&#x2F;权威<br>权威能使我们在陷入偏执状态时，得以短暂清醒。不过，我们不可以迷信那些虚浮有余，详实不足的高傲。</p><p>2.4-1目标<br>有一定的目标，便能主动地学到一些新东西。不过我们在树立新的目标之前，必须有能力承担失误的后果。</p><p>2.4-2能力<br>能力是我们与生俱来的特权，体现在对相同信息的不同处理方式上。但无论它是否高价，援助他人绝非理所当然的责任。</p><p>2.4-2&#x2F;资格<br>所谓资格，便是关系网搭建的竞争优势，扼杀着无关者的人生和希望，充斥落后而不自知的傲慢。</p><h4 id="3-1-1效率"><a href="#3-1-1效率" class="headerlink" title="3.1-1效率"></a>3.1-1效率</h4><p>效率是理性的第一要素，（不幸地）同时也是工具式人生的首要的追求。</p><p>3.1-2试探<br>高质量的革新，往往从不见效率的试探开始。尊重每一种创造，即便对目前来说，并无作用。</p><p>3.2-1良知<br>任何正面词汇都有其适用的范围，这种范围除和特定的场合相关外，还交融着个体的认知素养、身份能力。</p><p>3.2-2审视<br>对更严重的危害，或自身因此获得的好处视而不见，而倾向于指责人们普遍存在的举动。</p><p>3.2-3验证<br>当你左右为难时，可能是事物的前提出了问题。当你做出价值判断时，优先去质疑事例的前提。<br>3.3-1从众<br>逻辑严密无法战胜逻辑不自洽。我们更容易表达某种过分简单行为，来寻得一种不落后大众的方式。</p><p>3.3-2规划<br>保留一些信息和底牌。选取那些你需要展示或提高的部分，往往比全心投入更加有效。</p><p>3.3-3裹挟<br>重复他人的成功，沿着他人的道路前行，自我剥削，甘于庸碌，抵制捷径，批驳开源，只为陷入精英主义的骗局。</p><p>3.4-1耐性<br>自愿接受摧残，因改变现状获取的收益，小于现在能够获得或预计可以获得的收益。</p><p>3.4-2正义<br>正义讲究的是直白且当场的反击。我们若相信一些事物能在未来得到弥补，那便可以选择稳固的秩序。</p><p>3.5-1感受<br>我们需要照顾周围人的正常感受，但绝不应该纵容愚人的愚行。给他人以台阶，是默契，也能是施舍。</p><p>3.5-2偏执<br>我们掠夺性地希望得到外界的补偿。但集中地表现一些世俗定义的恶意，容易招人质疑。</p><p>3.5-3自证<br>物质会阻隔无端捆绑自己的恶，面对网络上的流言蜚语，比起分析现象及逻辑的合理性，不如使用强硬手段。</p><hr><h2 id="第六部分-神识"><a href="#第六部分-神识" class="headerlink" title="第六部分-神识"></a>第六部分-神识</h2><h3 id="Part1：意识互联"><a href="#Part1：意识互联" class="headerlink" title="Part1：意识互联"></a>Part1：意识互联</h3><p>意识互联介绍如何将机体的意识连接在一起，以进行更高效的信息交流。<br>Structures-<br>1.信息共享<br>机体对信息进行翻译、编辑后，传递到其他机体的意识中</p><p>2.感官延迟<br>机体分离出时刻的部分感受，在特定时机再引发特定反应</p><p>3.时空叠加<br>机体同时进行多个交互或拥有多个交互对象，且相对独立</p><h3 id="Part2：空泛之语"><a href="#Part2：空泛之语" class="headerlink" title="Part2：空泛之语"></a>Part2：空泛之语</h3><p>Descriptions-<br>为何生存？<br>1.履行职责，2.追求价值，3.享受生活。</p><p>何为缺陷？<br>1.感性压迫，2.监视互动，3.放纵情绪。</p><p>何为爱意？<br>不同角度的陪伴与认同，而非满足私欲的物化与抽离。</p><p>何为自我？<br>1.认知（感知），2.记忆（记录），3.交互（行为与规则，创造）。</p><p>理想社会？<br>1.利益对等，2.关系有限，3.后天平等。</p><p>错误发源？<br>1.苦难，2.结构，3.侵略。</p><p>愚昧时代？<br>1.自我封闭，2.自我剥削，3.自施苦难。</p><p>万物关系？<br>1.先导与现状，2.推理与实际，3.区域与连接。</p><p>为何苦累？<br>1.形式功利，2.现实落差，3.文化压迫。</p><p>虚拟交互？<br>1.平等交流，2.信息透明，3.稳定可靠。</p><p>何为世界？何为生死？何为消逝？<br>1.概率之一，2.记忆始末，3.不觉遗忘。</p><p>何为教育？<br>1.常识，2.知识，3.选拔，4.工作，5.研究。</p><p>何为雅？<br>1.思想深刻，2.底蕴丰富，3.细节充实。</p><p>何为俗？<br>1.思想浅薄，2.内涵畸化，3.粗糙泛滥。</p><p>何为道德？<br>1.不占有过多的资源（创造），2.不干扰他人的活动（记录），3.不苛责外界的错误（感知）</p><p>何不考虑？<br>1.自身不合理利益受损，2.他人合理利益扩大，3.对多余资源的强制占用</p><p>形式主义？<br>1.追求数量，忽视质量，2.监视思想，空洞庸碌，3.步骤繁琐，低效无用。</p><p>理性形式？<br>1.明确定义，2.判断关系，3.严格推理。</p><p>感性形式？<br>1.直观定性，2.融合关系，3.混沌联想。</p><p>老旧陋习？<br>1.服从教育，2.人情关系，3.野权迷信。</p><p>聚餐陋习？<br>1.尊卑分酒，2.低俗冒犯，3.吹嘘说教。</p><p>思维控制？<br>1.形象分明，2.抬己压异，3.理想虔诚，4.伪善妒恶，5.知行统一。</p><p>解决问题？<br>1.灵感&#x2F;能力(感知)，2.知识&#x2F;人脉(记录)，3.构造&#x2F;资源(创造)。</p><p>优秀理论？<br>1.概念明确，2.反映现实，3.协调一致，4.可扩充可兼容。</p><p>何为蠢人？<br>1.保守至对性避讳不提，2.激进至无脑感性爱国，3.伟大至提倡低级苦难，4.渺小至吹捧封建迷信。5.以性质忽略量度，以表象否决本质，以区别漠视联系。<br>何为智能？<br>1.广泛的智慧意味着知识丰富，2.均衡的理性意味着客观清晰，3.极大的包容意味着博爱平和。</p><p>何为钝化？<br>1.忽略情绪，2.漠视人格，3.簇拥权威，4.跪拜规则。</p><p>何为俗生？<br>1.房车暴欲，2.烟酒赌博，3.认知保守。</p><p>三大障碍？<br>1.官僚主义（记录），2.形式主义（创造），3.稚化认知（感知）。</p><p>文明恶习？<br>1.虚伪，2.强制，3.傲慢。</p><p>繁衍理由？<br>接纳生物本能、投资未来生活、固化家庭结构（封锁伴侣）、稳定行为方式（自造软肋）、传递财富或爱意、维持社会运转（排己目的）、无由地试探、弥补遗憾。</p><p>角色扮演？<br>1.理想，2.纯粹，3.祝福。</p><p>人情世故？<br>1.自己的面子，2.济私的利益，3.无由的试探。</p><p>知识要素？<br>1.传承（记录）、2.共鸣（感知）、3.实用（创造）。</p></div>]]></content>
      
      
      <categories>
          
          <category> 世界之核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SCHNIE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：安全协议</title>
      <link href="/posts/24329b97.html"/>
      <url>/posts/24329b97.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note primary flat"><h2 id="身份证明协议"><a href="#身份证明协议" class="headerlink" title="身份证明协议"></a>身份证明协议</h2></div><blockquote><p>两个参与者：证明者，验证者。</p></blockquote><blockquote><p>采用方式：挑战-响应协议-证明者向验证者通过展示与身份相关的秘密知识，证明自己的身份。</p></blockquote><blockquote><p>关键：不泄露秘密，且能够抵抗攻击。</p></blockquote><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">双向认证(基于共享密钥)</button><button type="button" class="tab " data-href="1-2">基于整数模p的阶为q的乘法循环群</button><button type="button" class="tab " data-href="1-3">基于公钥的认证</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><blockquote><p>挑战：一方传送给对方一个随机数</p></blockquote><blockquote><p>响应：对方对这个数进行特定处理再返回</p></blockquote><p><font color=red>双向认证协议(1)</font><br><img src="/study/xieyi0.png" alt="协议1"></p><blockquote><p>假设A也是可接受多个会话的通用计算机</p></blockquote><blockquote><p>考虑当攻击者伪装B的身份</p></blockquote><p>受到反射攻击：<br><img src="/study/gonji0.png" alt="反射攻击"></p><blockquote><p>关键：1.攻击者伪装B，建立一个同A的会话；2.攻击者拦截一个A向B的会话；3.攻击者利用A的自动加密，分别套出两个随机数的加密值。</p></blockquote><p><font color=red>双向认证协议(2)</font><br><img src="/study/xieyi1.png" alt="协议2"></p><p>受到反射攻击：<br><img src="/study/fanshe.png" alt="反射攻击"></p><blockquote><p>改进方式：在每个加密消息里加入发送者、接收者在协议中的角色(这样攻击者就无法利用消息2)。</p></blockquote><p><font color=red>双向认证协议(3)</font><br>基于HMAC，对HMAC的 攻击难于对<strong>对称密钥算法</strong>的攻击。<br><img src="/study/hmac.png" alt="协议3"></p><p><font color=red>双向认证协议(4)</font><br>Andrew安全RPC协议。<br><img src="/study/RPC.png" alt="协议4"></p><p>攻击：</p><blockquote><p>重放攻击：重放4给A；4中没有注明这个会话密钥和此次通信的关联。</p></blockquote><blockquote><p>类型缺陷攻击：攻击者在第四步重放2给A：虽然攻击者不一定知道RA+1，但猜测nonce比猜测密钥简单。</p></blockquote><p>解决类型缺陷攻击：</p><blockquote><p>Nonce只被要求每次不同即可，不包含随机性。</p></blockquote></div><div class="tab-item-content" id="1-2"><p><font color=red>Schnorr协议</font></p><blockquote><p>挑战：一方传送给对方一个随机数e</p></blockquote><blockquote><p>响应：对方对这个数进行特定处理再返回</p></blockquote><p>全局变量：p(大素数)、q(素数，p-1的因数)、g(生成元，0&lt;g&lt;p)、v(公钥，v&#x3D;g^(-a) mod p)<br>私钥：a(0&lt;a&lt;q)</p><p>过程：</p><blockquote><p>A 生成随机 r(0&lt;r&lt;q)，将 g^{r} mod p 发给B(防止暴露a)</p></blockquote><blockquote><p>B 向 A 发送随机数 e(防止A伪造a,e&lt;2^{t}&lt;q)[挑战]</p></blockquote><blockquote><p>A 计算 y &#x3D; r + ae mod <strong>q</strong>，将 y发给B，(B无法求离散对数得到r，进而得到e)(为什么mod q：q是阶)[响应]</p></blockquote><blockquote><p>B 计算 g^{y} (g^{-a})^{e} mod p 是否等于g^{r} mod p, 判定A的身份(如果A没有a，很难伪造私钥以通过验证)</p></blockquote><p>问题:<br>将Schnorr协议的过程1，2反序。协议是否安全？<span class="hide-inline"><button type="button" class="hide-button" style="">Click<br>  </button><span class="hide-content">不安全，A可第三步构造t，第一步发送g^{t}g^{-a}^e来欺骗B</span></span><br>若A使用相同的r进行两次验证，监听者能否获得a？ <span class="hide-inline"><button type="button" class="hide-button" style="">Click<br>  </button><span class="hide-content">能，B将e设为r，即可获得a</span></span></p></div><div class="tab-item-content" id="1-3"><p>对于公钥算法来说，身份认证非常简洁。</p><blockquote><p>基于加密的认证：用X的公钥加密消息M</p></blockquote><blockquote><p>基于签名的认证：用X的私钥加密消息M</p></blockquote><p>注意：不要将密钥用于多个目的，比如使用不同的密钥对进行签名和加密</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note warning flat"><h2 id="认证协议设计一般原则"><a href="#认证协议设计一般原则" class="headerlink" title="认证协议设计一般原则"></a>认证协议设计一般原则</h2></div><blockquote><p>安全协议设计是困难的,需要不断设计，分析，改进。</p></blockquote><blockquote><p>协议中报文不能被重复使用。</p></blockquote><blockquote><p>通信的发起者先提供自己的身份的证明，然后才是响应者。</p></blockquote><blockquote><p>发起者和响应者使用不同的共享密钥。</p></blockquote><blockquote><p>发起者和响应者的挑战数来源于不同的集合。如发起者用偶数，响应者用奇数。</p></blockquote><blockquote><p>并行会话无法被利用。</p></blockquote><div class="note primary flat"><h2 id="密钥建立协议"><a href="#密钥建立协议" class="headerlink" title="密钥建立协议"></a>密钥建立协议</h2></div><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">密钥传输</button><button type="button" class="tab " data-href="1-2">密钥协商</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>一方建立，安全地传给另一方。</p><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">无预先共享密钥的密钥传输</button><button type="button" class="tab " data-href="2-2">使用密钥分发中心的密钥传输</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><p>目的：密钥 K 保密地（但无身份验证）从 A 传输到 B。<br>系统参数: 素数 p；A和B分别选择秘密随机数 a、b(1 ≤ a、b ≤ p − 2),均与p − 1互素(保证a逆 mod p-1存在)。</p><p>过程：</p><blockquote><p>A → B ： K^{a} mod p</p></blockquote><blockquote><p>A ← B ： (K^{a})^{b} mod p</p></blockquote><blockquote><p>A → B ： (K^{ab})^{a^(-1)} mod p</p></blockquote></div><div class="tab-item-content" id="2-2"><p>每个用户与KDC共享一个秘密密钥，KDC存储并管理所有密钥。</p><div class="tabs" id="3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="3-1">宽蛙嘴协议</button><button type="button" class="tab " data-href="3-2">简单票协议</button><button type="button" class="tab " data-href="3-3">Needham-Schroeder 协议</button><button type="button" class="tab " data-href="3-4">Kerberos协议</button></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><blockquote><p><img src="/study/kuanwa.png" alt="宽蛙嘴"></p></blockquote><p>攻击：</p><blockquote><p>重放2。</p></blockquote><p>解决：</p><blockquote><p>加入时间戳或nonce</p></blockquote></div><div class="tab-item-content" id="3-2"><blockquote><p><img src="/study/jiandan.png" alt="简单票"></p></blockquote><p>攻击：</p><blockquote><p>重放攻击：如果一个旧密钥 Ks及其KB(KS)泄露，则攻击者可假冒任何人的身份与Bob对话</p></blockquote><blockquote><p>中间人攻击1：Alice可在最后一步假冒任何人的身份与Bob对话</p></blockquote><blockquote><p>中间人攻击2：攻击方C申请和A、B对话，拿到KC(KS)，KA(KS),KC(KS‘),KB(KS’)，进而监听和篡改A、B之间的通信</p></blockquote><p>解决：<br>解决重放攻击：<br><img src="/study/chongf.png" alt="重放"></p><blockquote><p>Alice能保证得到的Ks是新鲜的</p></blockquote><p>解决中间人攻击：<br><img src="/study/jiejue.png" alt="简单票2"></p><blockquote><p>Alice无法假冒别的身份与Bob对话</p></blockquote><blockquote><p>Eva可以得到 KA(Ks，B)和 KB(Ks，A)， 但无法解密Ks，也无法伪造身份(因为身份信息受到KDC的加密)</p></blockquote></div><div class="tab-item-content" id="3-3"><p><img src="/study/Need.png" alt="协议"><br>4,5是B向A证明身份，确认收到密钥，同时确认A的身份。注意：消息2对KB(A,KS)的加密是没有必要的。</p><p>攻击：</p><blockquote><p>Trudy得到了一个旧的 ks，则可以重放消息3。而B必须记住所有旧ks才能抵抗这种攻击。</p></blockquote><p>解决：</p><blockquote><p>在2、3中加入时间戳，或者在3之前加入认证。</p></blockquote><p><font color=red>改进：Otway-Rees 协议</font><br><img src="/study/Ot.png" alt="协议"></p><blockquote><p>不需要复杂的同步机制</p></blockquote><blockquote><p>通信双方都与KDC进行了一次挑战-应答</p></blockquote><blockquote><p>RA加入到4，保证了KS的新鲜性</p></blockquote><blockquote><p>接收方B不在线时，不能使用</p></blockquote></div><div class="tab-item-content" id="3-4"><p>对Needham-Schroeder 协议的改进。</p><p><img src="/study/K5.png" alt="协议"></p><blockquote><p>TGS票重用，一次登录可访问多个服务</p></blockquote><blockquote><p>可视为两部分：第一部分，AS充当KDC，TGS充当另一用户；第二部分TGS充当KDC，Bob为另一用户</p></blockquote><p>过程：</p><blockquote><p>1.用户向AS提供用户名和密码，获取ticket(一个登录期间一次)</p></blockquote><blockquote><p>2.用户将此ticket发往TGS，获取另一个ticket(一种类型的服务一次)</p></blockquote><blockquote><p>3.用户将此ticket发往服务器，获取服务</p></blockquote><p>优点：</p><blockquote><p>身份验证只需一次，降低了风险</p></blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tab-item-content" id="1-2"><p>共同参与计算一个共享密钥，任何一方不能预先确定结果。</p><div class="tabs" id="4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="4-1">DH密钥协商</button><button type="button" class="tab " data-href="4-2">完美前向保密PFS</button></ul><div class="tab-contents"><div class="tab-item-content active" id="4-1"><blockquote><p>A 选择随机数 a，发送给B：g^{a} mod p</p></blockquote><blockquote><p>B 选择随机数  b，发送给A：g^{b} mod p</p></blockquote><blockquote><p>会话密钥 Ks &#x3D; g^{ab} mod p</p></blockquote></div><div class="tab-item-content" id="4-2"><blockquote><p>长期共享密钥K,当K被截获，不会造成Ks被破译:</p></blockquote><blockquote><p>A公开：EK(g^{a} mod p)</p></blockquote><blockquote><p>B公开：EK(g^{b} mod p)</p></blockquote><blockquote><p>会话密钥:Ks &#x3D; g^{ab} mod p</p></blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note warning flat"><h2 id="解决重放攻击的一般方式"><a href="#解决重放攻击的一般方式" class="headerlink" title="解决重放攻击的一般方式"></a>解决重放攻击的一般方式</h2></div><p>消息重放的实质是消息的新鲜性（Freshness）不能得到保证。</p><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">时间戳</button><button type="button" class="tab " data-href="1-2">挑战－应答机制</button><button type="button" class="tab " data-href="1-3">序列号</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>对消息盖上本地时戳，只有当消息上的时戳与当前本地时间的差值在意定范围之内，才接受该消息。<br>要求有一个全局同步时钟，但是如果双方时钟偏差过大或者允许的范围过大，则可以被攻击者利用。</p></div><div class="tab-item-content" id="1-2"><p>通过发送挑战值（Nonce）来确保消息的新鲜性。</p></div><div class="tab-item-content" id="1-3"><p>通信双方通过消息中的序列号来判断消息的新鲜性。要求通信双方必须事先协商一个初始序列号，并协商递增方法。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="传输层的安全协议SSL-TLS"><a href="#传输层的安全协议SSL-TLS" class="headerlink" title="传输层的安全协议SSL&#x2F;TLS"></a>传输层的安全协议SSL&#x2F;TLS</h2></div><p><img src="/study/woshou.png" alt="协议"><br>分为记录层(编码协议、报文顺序等)、握手层。</p><p>重要概念：</p><blockquote><p>会话：会话是指客户机和服务器之间的关联。一个会话包含多个连接。SSL 会话使用了公钥算法，开销大。</p></blockquote><blockquote><p>连接：连接是客户和服务器之间的逻辑链路，用于提供合适的传输服务和操作环境。SSL连接使用SSL会话生成的<strong>pre-master secret</strong>生成密钥，不再使用公钥算法。</p></blockquote><blockquote><p>SSL&#x2F;TLS握手协议负责协调客户机和服务器之间的<strong>会话</strong>的状态：当前操作状态和未决状态（在握手协议期间）。</p></blockquote><p>服务：</p><blockquote><p>身份认证。认证用户和服务器，确保数据发送到正确的客户机和服务器；</p></blockquote><blockquote><p>保密性。加密数据以防止数据中途被窃取；</p></blockquote><blockquote><p>完整性。维护数据的完整性，确保数据在传输过程中不被改变。</p></blockquote><div class="tabs" id="6"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="6-1">简化的SSL会话建立</button><button type="button" class="tab " data-href="6-2">有共享秘密pre-master secret后的SSL连接建立</button></ul><div class="tab-contents"><div class="tab-item-content active" id="6-1"><p><img src="/study/ssl.png" alt="协议"><br>使用了<strong>公钥算法</strong>，大大降低了效率。</p><blockquote><p>S ：<strong>pre-master secret</strong>，A生成的随机值。</p></blockquote><blockquote><p>K &#x3D; h(S||RA||RB)</p></blockquote><blockquote><p>“msgs”是前边全部消息，用来证明前边消息已经正确接收。</p></blockquote><blockquote><p>CLNT，SRVR 是固定字符串。</p></blockquote><blockquote><p>Ek(h(msgs||CLNT||K))用于向Bob证明Alice的身份，可以不需要。</p></blockquote><blockquote><p>第四步，Bob向Alice证明自己的身份。</p></blockquote><p>问题<br>并没有认证A的身份。<span class="hide-inline"><button type="button" class="hide-button" style="">Click<br>  </button><span class="hide-content">服务员在此后用其他手段认证A的身份。</span></span></p></div><div class="tab-item-content" id="6-2"><p>不需要公钥算法。<br><img src="/study/lianjie.png" alt="协议"></p><blockquote><p>SSL会话已建立，用session-ID表示</p></blockquote><blockquote><p>K &#x3D; h(S||RA||RB)</p></blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>参考资料：<br>1.<a href="http://t.csdnimg.cn/QDNGJ" title="" target="">Schnorr身份识别方案</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：快速比特操纵算法</title>
      <link href="/posts/7511bdb5.html"/>
      <url>/posts/7511bdb5.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note info flat"><h2 id="快速比特操纵算法含义"><a href="#快速比特操纵算法含义" class="headerlink" title="快速比特操纵算法含义"></a>快速比特操纵算法含义</h2></div><p>使用机器字操作(算术、逻辑运算)实现机器字中的比特的计算和变换，是一种时间复杂度与机器字长无关的算法。</p><div class="note primary flat"><h2 id="计算1的个数"><a href="#计算1的个数" class="headerlink" title="计算1的个数"></a>计算1的个数</h2></div><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">朴素方法</button><button type="button" class="tab " data-href="1-2">移位加法方法</button><button type="button" class="tab " data-href="1-3">乘法方法</button><button type="button" class="tab " data-href="1-4">乘法和加法的综合使用</button><button type="button" class="tab " data-href="1-5">更快的方法</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v; <span class="comment">//c的值即1的个数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> c; </span><br><span class="line"><span class="keyword">for</span> (c = <span class="number">0</span>; v; c++)</span><br><span class="line">    v &amp;= v - <span class="number">1</span>; </span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="1-2"><h4 id="分块和"><a href="#分块和" class="headerlink" title="分块和"></a>分块和</h4><blockquote><p>对于一个二进制数x（总位数为w），将其划分为多段相同长度u的区间，将每个区间内的<strong>1的个数</strong>转化为二进制，首尾相接得到y：y称为x的u分块和。</p></blockquote><blockquote><p>例如：101010的1分块和是1,0,1,0,1,0,101010的2分块和是01,01,01，101010的6分块和是000011。</p></blockquote><blockquote><p>因为u位能表示的最大个数，大于等于u的长度，故该方式能正确表达出分块和而不发生溢出。</p></blockquote><h4 id="递推表达式"><a href="#递推表达式" class="headerlink" title="递推表达式"></a>递推表达式</h4><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>x</mi><mrow><mo stretchy="false">[</mo><mn>2</mn><mi>u</mi><mo stretchy="false">]</mo></mrow></msup><mo>&#x3D;</mo><mi>y</mi><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi></mrow></msup><msup><mn>1</mn><mrow><mi>u</mi></mrow></msup><msup><mo stretchy="false">)</mo><mrow><mi>w</mi><mrow><mo>&#x2F;</mo></mrow><mn>2</mn><mi>u</mi></mrow></msup><mo>+</mo><mo stretchy="false">(</mo><msup><mi>x</mi><mrow><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo></mrow></msup><mo>&gt;&gt;</mo><mi>u</mi><mo stretchy="false">)</mo><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi></mrow></msup><msup><mn>1</mn><mrow><mi>u</mi></mrow></msup><msup><mo stretchy="false">)</mo><mrow><mi>w</mi><mrow><mo>&#x2F;</mo></mrow><mn>2</mn><mi>u</mi></mrow></msup></math><br>说明</p><blockquote><p>简单来说，便是将奇数个u区间和偶数个u区间相加。</p></blockquote><blockquote><p>例如上面01010101的例子：<br>先将01010101和00110011按位与，只保留奇数位u区间得到00010001；<br>再将01010101右移u位，得到00010101，与00110011按位与，只保留偶数个u区间得到00010001。</p></blockquote><blockquote><p>再将两数相加，完成合并。</p></blockquote><p>这种方法参照了递归方式，计算1的个数的时间复杂度是O(log w)，小于上一方法的O(w)。</p></div><div class="tab-item-content" id="1-3"><h4 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h4><blockquote><p>若一个数，每个区间除了最后一位为0&#x2F;1，其他位都为0：换而言之，最低位的数表示这个u区间有多少个1：</p></blockquote><blockquote><p>形如001001001001、000000001001，将其与001001001001相乘，结果的从右往左数的第m-1&#x3D;w&#x2F;u-1（从0开始计数）个u区间的值为此二进制数的1的个数。</p></blockquote><blockquote><p>对于这个例子，001001001001与001001001001相乘，结果为1010011<strong>100</strong>011010001，得到001001001001中1的个数是4。</p></blockquote><h4 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h4><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>所有</mo><mi>u</mi><mo>区间的第</mo><mi>i</mi><mo>个比特中</mo><mn>1</mn><mo>的数量</mo><msub><mi>C</mi><mrow><mi>i</mi></mrow></msub><mo>&#x3D;</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&gt;&gt;</mo><mi>i</mi><mo stretchy="false">)</mo><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>m</mi></mrow></msup><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>m</mi></mrow></msup></math><br>即：通过移位和按位与，强制将每一部分的数变成“每个区间除了最后一位为0&#x2F;1，其他位都为0”的形式。</p><blockquote><p>如110110，分块为110，110，求第0,1,2位的1的个数的操作分别为000000*001001，001001*001001，001001*001001。</p></blockquote><blockquote><p>将上面的结果相加，取从右往左数的第w&#x2F;u-1（从0开始计数）个u区间的值，便是110110中1的个数，得到4。注意：分块长度至少为<strong>lgw</strong>，否则相加时会产生进位(即需满足w&lt;2^{u})。</p></blockquote><p>总结：如果设区间长度为lgw，则需要做[0,lgw）次乘法，并将乘法得到的结果<strong>相加</strong>，最后取第m-1(从0开始计数)个u区间的值。</p></div><div class="tab-item-content" id="1-4"><blockquote><p>加法方法进行到区间长度 u &#x3D; lgw 时；</p></blockquote><blockquote><p>用一次乘法，<strong>结果的第 m - 1 个 u 区间的值等于 x 中 1 的个数</strong>。</p></blockquote><blockquote><p>时间复杂 O(loglog w)</p></blockquote><p>此时虽然<strong>y</strong>的每个分块不满足“每个区间除了最后一位为0&#x2F;1，其他位都为0”,但满足“表示的数的大小为x的对应分块的1的个数”。即结果的第 m - 1 个 u 区间的值并非为y中1的个数，<strong>而是x的1的个数</strong>。</p><p>额外的：</p><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>x</mi><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>g</mi><mi>w</mi><mo stretchy="false">]</mo></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mrow><mi>l</mi><mi>g</mi><mi>w</mi></mrow></msup><mo>–</mo><mn>1</mn><mo stretchy="false">)</mo><mo>等于所有</mo><mi>u</mi><mo>区间的和</mo></math></p></blockquote><p>例子：</p><blockquote><p>0001001010001111，分块为4，则x[lgw]为0001,0001,0001,0100(十进制为4372)。</p></blockquote><blockquote><p>其乘以0001000100010001的结果的第3个数为0111，值为7。同时，4372模15的值也为7。</p></blockquote></div><div class="tab-item-content" id="1-5"><h4 id="前导知识"><a href="#前导知识" class="headerlink" title="前导知识"></a>前导知识</h4><blockquote><p>log*(n)的定义：满足log( log( ··· log(n) ··· ) ) ＜1 的最小log个数。</p></blockquote><blockquote><p>lg*(32) &#x3D; lg*(64) &#x3D; lg*(128) &#x3D; ··· &#x3D; lg*(2^16) &#x3D; 4</p></blockquote><blockquote><p>u个比特能表示2的u次方-1大小，也即(2的u次方-1)&#x2F;u个u区间的1的个数之和。</p></blockquote><blockquote><p>思想：让每次乘法尽最大可能扩张区间长度。</p></blockquote><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>设</mo><msup><mi>u</mi><mo>′</mo></msup><mo>是用一次乘法能得到的最大区间长度，则</mo><msup><mi>u</mi><mrow><mo>′</mo></mrow></msup><mo>&#x3D;</mo><mi>u</mi><mo stretchy="false">⌊</mo><mfrac><mrow><msup><mn>2</mn><mi>u</mi></msup><mo>−</mo><mn>1</mn></mrow><mi>u</mi></mfrac><mo stretchy="false">⌋</mo></math></p></blockquote><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>定义</mo><mi>L</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&#x3D;</mo><mi>l</mi><mi>g</mi><mi>w</mi><mo>,</mo><mi>L</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>&#x3D;</mo><mi>l</mi><mi>g</mi><mi>l</mi><mi>g</mi><mi>w</mi><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>&#x3D;</mo><mi>l</mi><mi>g</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mi>w</mi><mo>.</mo><mo>则:</mo><msup><mi>x</mi><mrow><mo stretchy="false">[</mo><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow></msup><mo>&#x3D;</mo><mo stretchy="false">(</mo><msup><mi>x</mi><mrow><mo stretchy="false">[</mo><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow></msup><mo>∗</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mfrac><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow></msup><mo stretchy="false">)</mo><mo>&gt;&gt;</mo><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></math></p></blockquote><blockquote><p>说明：从L(i)区间开始，每次将区间放大为原来的2次幂倍，直到区间长度为lgw。此时运用一次分块乘法，便能得到结果。</p></blockquote><blockquote><p>原理：存在y，x[u] * y &#x3D; z，对于 z 的每个u’区间，其最高 u 比特的值是x[ u’]对应区间的值。通过移位等处理，可得到x [u’]</p></blockquote><p><strong>具体公式课堂略过</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="LSB计算"><a href="#LSB计算" class="headerlink" title="LSB计算"></a>LSB计算</h2></div><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">Leiserson方法</button><button type="button" class="tab " data-href="2-2">Fich方法 O(1)</button><button type="button" class="tab " data-href="2-3">求最高位的置1比特（MSB）(O(1))</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><h4 id="前导知识"><a href="#前导知识" class="headerlink" title="前导知识"></a>前导知识</h4><blockquote><p>二元de Bruijn序列是一种特殊的周期为2的n次方的序列，满足任意一个二元n长向量都在de Brujn序列的一个周期中恰出现一次。</p></blockquote><blockquote><p>如n取3时，序列为00010111<strong>00</strong>，也即00010111的循环：其中000,001,010,011,100,101,110,111只出现了一次。</p></blockquote><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><blockquote><p>构造哈希函数h(x)：其中x是2的幂次方，最大值<strong>小于</strong>2的w次方，h(x)为0到w-1的任意一个数。<br>h(x) &#x3D;B * x &gt;&gt; (w – lg w)，lgw整除w(why?)。</p></blockquote><p>这个操作相当于对B进行移位后取高lgw(即上文中的n)位，因为B的特殊性，所以h(x)和x是一一对应的。</p><blockquote><p>构造表D：对于长度为lgw的数(或者说0&lt;&#x3D;x&lt;w)x，找到lgw维de Bruijn的第x位，取lgw个，得到的数记为y，D[y]&#x3D;x。(y互不相同；O(w)时间，O(wlgw)空间)</p></blockquote><p>这一步实际上就是由x确定h(x),<strong>不同的是，这里的x是LSB的值，而上文的的x是2的幂次方。h(x)的作用是，作为枢纽，连接这两个值</strong>。</p><blockquote><p>将word的除了最低置位bit之外的bit置 0(一个方式：(~word+1) AND word,~即按位取反)</p></blockquote><blockquote><p>结果与De Bruijn序列相乘，取乘积的前lgw bit得到数x’(这一步实际上就是进行h(x))</p></blockquote><blockquote><p>用结果查表D，得到D[x’]，即为LSB的位置</p></blockquote><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><blockquote><p>LSB的值根据de Bruijn序列，映射成了唯一的长度为lgw的值，而这长度为lgw的值又通过de Bruijn序列映射成了唯一的2的幂次方。当de Bruijn序列确定时，这两个映射关系是唯一确定的。</p></blockquote></div><div class="tab-item-content" id="2-2"><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><blockquote><p>将 x分为 u bit区间。</p></blockquote><blockquote><p>将LSB隔离出来，其他bit都是0。(一个方式：(~word+1) AND word,~即按位取反)</p></blockquote><p>注意：其中 u 应该大于根号w,否则做乘法时，00..1串无法覆盖所有的u区间。<br>计算LSB所在的区间号i</p><blockquote><p>生成一个机器字<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>F</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>将第</mo><mi>i</mi><mo>位之后的</mo><mi>u</mi><mo>区间的最低位比特置</mo><mn>1</mn><mo>：</mo><mi>y</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&lt;&lt;</mo><mn>1</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>A</mi><mi>N</mi><mi>D</mi><mi>F</mi></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>通过如下操作将所有</mo><mi>i</mi><mo>之后</mo><mi>u</mi><mo>区间的最后的比特相加到一个区间里:</mo><mi>y</mi><mo>&#x3D;</mo><mi>y</mi><mo>∗</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>在机器字</mo><mi>Y</mi><mo>的最高</mo><mi>u</mi><mo>比特中存放的数值就是</mo><mi>L</mi><mi>S</mi><mi>B</mi><mo>所在的</mo><mi>u</mi><mo>区间的编号:(截断为w位)</mo><mi>i</mi><mo>&#x3D;</mo><mi>y</mi><mo>&gt;&gt;</mo><mo stretchy="false">(</mo><mi>w</mi><mo>−</mo><mi>u</mi><mo stretchy="false">)</mo></math></p></blockquote><p>原理</p><blockquote><p>LSB后面的所有u区间的最低位为1，故在LSB及其后面有多少个u区间，便有多少个1被加。<strong>注意：这里的01串的重复次数是u，而非w&#x2F;u</strong></p></blockquote><p>计算LSB在区间中的位置j</p><blockquote><p>将x的i区间复制成u份：<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>y</mi><mo>&#x3D;</mo><mi>x</mi><mo>&gt;&gt;</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>i</mi><mo>–</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>u</mi><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup></math><br>只将第j个u区间保留下来：<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>y</mi><mo>&#x3D;</mo><mi>y</mi><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup></math><br>采用计算区间号i的方法，得到j</p></blockquote><p>则y &#x3D; u*(i-1)+j。</p><p>例子：</p><blockquote><p>100(u为3):</p></blockquote><blockquote><p>计算i：(0111&amp;(001001001))*(001001001)&#x3D;001001001,取高u位，即i&#x3D;1。</p></blockquote><blockquote><p>计算j：100复制三次：100100100，再与上000100010001得100000000,利用计算i的方法，得到j&#x3D;3。</p></blockquote><blockquote><p>最终：(1-1)*3+3&#x3D;3。</p></blockquote><p>反例：</p><blockquote><p>100 000 000 000…(u为3)：</p></blockquote><blockquote><p>此时不管后面有多少个000，最后都会得到LSB在第三个区间，而这是错误的。那为什么不动态改变机器字F来使得其正确:耗时。</p></blockquote></div><div class="tab-item-content" id="2-3"><h4 id="前导知识"><a href="#前导知识" class="headerlink" title="前导知识"></a>前导知识</h4><p>SetR(x,u)</p><blockquote><p>此操作根据机器字x中u区间是否为0对u区间进行设置，如果为0，则u区间不变，否则最低位置为1。</p></blockquote><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>1</mn><mo>）将每个</mo><mi>u</mi><mo>区间最高位置为</mo><mn>1</mn><mo>。</mo><mi>x</mi><mo>&#x3D;</mo><mi>x</mi><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>10</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup><mo>。</mo></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>2</mn><mo>）</mo><mi>y</mi><mo>&#x3D;</mo><mi>x</mi><mo>−</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>3</mn><mo>）将等于</mo><msup><mn>10</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>的</mo><mi>u</mi><mo>区间的最高为置为</mo><mn>1</mn><mo>。</mo><mi>x</mi><mo>&#x3D;</mo><mi>y</mi><mrow><mo stretchy="false">|</mo></mrow><mo stretchy="false">(</mo><mi>x</mi><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>10</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup><mo stretchy="false">)</mo><mo>.</mo></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>4</mn><mo>）</mo><mi>x</mi><mo>&#x3D;</mo><mi>x</mi><mo>&gt;&gt;</mo><mi>u</mi></math></p></blockquote><p>反向聚合操作compr(x,u)</p><blockquote><p>此操作将每个区间的最后一个比特聚合在一个u区间中，但顺序相反。</p></blockquote><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>1</mn><mo>）</mo><mi>y</mi><mo>&#x3D;</mo><mi>S</mi><mi>e</mi><mi>t</mi><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>u</mi><mo stretchy="false">)</mo></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>2</mn><mo>）将每个</mo><mi>u</mi><mo>区间的最低位比特反向聚集在</mo><mi>y</mi><mo>的最高</mo><mi>u</mi><mo>区间。</mo><mi>y</mi><mo>&#x3D;</mo><mi>y</mi><mo>∗</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>3</mn><mo>）</mo><mi>x</mi><mo>&#x3D;</mo><mi>y</mi><mo>&gt;&gt;</mo><mo stretchy="false">(</mo><mi>w</mi><mo>−</mo><mi>u</mi><mo stretchy="false">)</mo></math></p></blockquote><p>扩散操作diffu(x,u)</p><blockquote><p>此操作将一个u区间的每个比特放置到每个u区间的最低比特上，顺序不变。</p></blockquote><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>1</mn><mo>）将</mo><mn>0</mn><mo>区间复制</mo><mi>u</mi><mo>份</mo><mi>y</mi><mo>&#x3D;</mo><mi>x</mi><mo>∗</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><mo stretchy="false">)</mo><mi>u</mi></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>2</mn><mo>）保留第</mo><mi>i</mi><mo>区间的第</mo><mi>i</mi><mo>个比特</mo><mi>y</mi><mo>&#x3D;</mo><mi>y</mi><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi></mrow></msup><mn>1</mn><mo stretchy="false">)</mo><mi>u</mi></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>3</mn><mo>）</mo><mi>S</mi><mi>e</mi><mi>t</mi><mi>R</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mi>u</mi><mo stretchy="false">)</mo></math></p></blockquote><h4 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h4><p>首先计算MSB所在的u区间的号</p><blockquote><p>（1）y &#x3D; SetR(x)</p></blockquote><blockquote><p>（2）y &#x3D; Compr(y,u)</p></blockquote><blockquote><p>（3）y &#x3D; diffu(y,u)</p></blockquote><blockquote><p>（4）计算y中的MSB的位置 i，因此MSB在x中所在区间为 i’&#x3D; u-i</p></blockquote><p>计算i’区间中MSB位置</p><blockquote><p>（5）y &#x3D; x&gt;&gt;(i’u)</p></blockquote><blockquote><p>（6）y &#x3D; diffu(y,u)</p></blockquote><blockquote><p>（7）计算y中的MSB的位置 j，因此MSB所在区间为 j’&#x3D; u-j</p></blockquote><p>最终可得到MSB的位置为 i’u+j’<br><strong>此部分在课堂略过</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="比特置换"><a href="#比特置换" class="headerlink" title="比特置换"></a>比特置换</h2></div><h4 id="递归方法实现完全比特反转O-lgw"><a href="#递归方法实现完全比特反转O-lgw" class="headerlink" title="递归方法实现完全比特反转O(lgw)"></a>递归方法实现完全比特反转O(lgw)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = (((x &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((x &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    x = (((x &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((x &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>));</span><br><span class="line">    x = (((x &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((x &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>));</span><br><span class="line">    x = (((x &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((x &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>((x &gt;&gt; <span class="number">16</span>) | (x &lt;&lt; <span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Benes置换网络"><a href="#Benes置换网络" class="headerlink" title="Benes置换网络"></a>Benes置换网络</h4><blockquote><p>可实现任意置换，只需在方块中填写交叉或直连(X或&#x3D;)。</p></blockquote><p> <img src="/study/zhihuan.png" alt="置换网络"></p><blockquote><p>输入个数是2的幂次方，该置换网络使用多个 2*2 <strong>基本交换单元</strong>实现置换，输出也为2的幂次方个元素的序列。</p></blockquote><blockquote><p>BN网络运用了<strong>递归</strong>的思想，即相邻(奇偶性不同)的输入，分别前往两组，而在某一组中，又再进行分组；而在输出时，每两个输出合并到一个输出，直到两个输出合并成最终输出，完成置换过程。</p></blockquote><blockquote><p>所需层数：2lgw-1。时间复杂度：O(lgw)，空间复杂度：O(lgw)(记录直连还是交换)</p></blockquote><h4 id="断点图"><a href="#断点图" class="headerlink" title="断点图"></a>断点图</h4><blockquote><p>输入中的相邻用实线连接，输出中的相邻用虚线连接。（作图为俩列）</p></blockquote><blockquote><p>调整断点图：交换相邻点的位置，使得虚线相连的两个数不在同一列。</p></blockquote><blockquote><p>获得输入符号：如果一组相邻点换序，则为“×”，否则为“&#x3D;”。</p></blockquote><blockquote><p>获得输出符号：在输出中如果一组相邻点为上下关系，在断点图中不为左右关系，则为“×”，否则为“&#x3D;”。</p></blockquote><blockquote><p>重复以上过程，直到所有空填上。</p></blockquote><p>例子：<br>输入从上到下是01234567，输出从上到下是64203571，(初始输入分组是01&#x2F;23&#x2F;45&#x2F;67，初始输出分组是64&#x2F;20&#x2F;35&#x2F;71。)则作图如下：<br><img src="/study/duandian.png" alt="断点"></p><blockquote><p>输入符号从上到下为“x&#x3D;x&#x3D;”，输出符号从上到下为“&#x3D;&#x3D;xx”。进一步地，获得新的分组。</p></blockquote><p>对输出符号的解释：64是一组且在输出分组中6在上4在下，在输入的调整后的断点图中6在左4在右，故不交换；71是一组且在输出分组中7在上1在下，在输入的调整后的断点图中7在右而1在左，故交换。</p><h4 id="断点图实例"><a href="#断点图实例" class="headerlink" title="断点图实例"></a>断点图实例</h4><blockquote><p><img src="/study/zhih.png" alt="置换网络"><br>注意：线条在方块“背面”经过，意为不进入这一置换单元。</p></blockquote><p>试着将以上例子对应的符号填入方块中。得到：</p><blockquote><p><img src="/study/zhih1.png" alt="断点"></p></blockquote><h4 id="一般情况m置换单元"><a href="#一般情况m置换单元" class="headerlink" title="一般情况m置换单元"></a>一般情况m置换单元</h4><blockquote><p>输入、输出按顺序分为m个块，每块k个元素。</p></blockquote><blockquote><p>将每块中的元素分到k个不同组中，使得每组中元素属于输入的不同块。</p></blockquote><blockquote><p>归结为K正规图着色问题。(why?)<br><strong>此部分课堂略过</strong></p></blockquote><p>参考资料：</p><a href="https://blog.csdn.net/u012028275/article/details/108895271?fromshare=blogdetail&sharetype=blogdetail&sharerId=108895271&sharerefer=PC&sharesource=lemonsed&sharefrom=from_link" title="" target="">【位操作笔记】详解一种高效位反转算法</a></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：安全计算</title>
      <link href="/posts/bc7c7b.html"/>
      <url>/posts/bc7c7b.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note warning flat"><h2 id="协议双方互不信任，都有可能欺骗"><a href="#协议双方互不信任，都有可能欺骗" class="headerlink" title="协议双方互不信任，都有可能欺骗"></a>协议双方互不信任，都有可能欺骗</h2></div><p>Semi-honest 半诚实，遵守协议流程，在过程中获得尽可能的信息</p><div class="note primary flat"><h2 id="承诺方案"><a href="#承诺方案" class="headerlink" title="承诺方案"></a>承诺方案</h2></div><p>即在一次信息交换中，A和B需要“同时”获得对方的一个信息。假设A先给出信息a，B后给出信息b。则B需要先给出b的证明c，A再给出信息a，B再给出信息b。这样，A能够核验信息证明c，来确保B没有在接收信息a后更改信息b【绑定】；同时，A也无法从信息证明c中获取b，来改变信息a【隐藏】。</p><h4 id="基于Hash函数的实现"><a href="#基于Hash函数的实现" class="headerlink" title="基于Hash函数的实现"></a>基于Hash函数的实现</h4><blockquote><p>A 计算承诺 c &#x3D; H (随机数,a)，将 c 发送给 B</p></blockquote><blockquote><p>隐藏性：存在 H ( R’, a’ ) &#x3D;  H ( R, a )，B找不到真实的R，a</p></blockquote><blockquote><p>绑定性： A 找不到 R’, a’，满足：H ( R’, a’ ) &#x3D; H ( R, a )</p></blockquote><p>不存在对有无限计算能力的敌手同时具有隐藏性和绑定性的承诺方案。</p><div class="note primary flat"><h2 id="百万富翁问题"><a href="#百万富翁问题" class="headerlink" title="百万富翁问题"></a>百万富翁问题</h2></div><p>A有一个0-9的数a，B有一个0-9的数b，A和B不想让对方知道自己的数字，但想知道a和b的大小。</p><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">基于DH实现</button><button type="button" class="tab " data-href="2-2">茫然传输方案</button><button type="button" class="tab " data-href="2-3">混淆电路方案</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><blockquote><p>A和B生成 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>α</mi><mo>,</mo><msup><mi>g</mi><mrow><mi>α</mi></mrow></msup><mo>,</mo><mi>β</mi><mo>,</mo><msup><mi>g</mi><mrow><mi>β</mi></mrow></msup></math></p></blockquote><blockquote><p>A进行操作后发给B：<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>若</mo><mi>α</mi><mo>&#x3D;</mo><mi>i</mi><mo>，则</mo><mi>H</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&#x3D;</mo><msup><mi>g</mi><mrow><mi>α</mi></mrow></msup><mo>∗</mo><mn>3.</mn><mo>.</mo><mo>.</mo><mo>,</mo><mo>若</mo><mi>α</mi><mo>&lt;</mo><mi>i</mi><mo>，则</mo><mi>H</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&#x3D;</mo><msup><mi>g</mi><mrow><mi>α</mi></mrow></msup><mo>∗</mo><mn>2.</mn><mo>.</mo><mo>.</mo><mo>,</mo><mo>若</mo><mi>α</mi><mo>&gt;</mo><mi>i</mi><mo>，则</mo><mi>H</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&#x3D;</mo><msup><mi>g</mi><mrow><mi>α</mi></mrow></msup><mo>∗</mo><mn>1.</mn><mo>.</mo><mo>.</mo><mo>,</mo><mo>,</mo><msup><mi>g</mi><mrow><mi>α</mi></mrow></msup><mo>.</mo></math>(“…”互不相同是为了防止B通过判断相同元素个数，50%概率猜出a)</p></blockquote><blockquote><p>B对H[b]进行加密，并抹除下标，将其发送给A。</p></blockquote><blockquote><p>A对H[?]进行解密，并将其发送给B。(防止A知道下标b，而猜出具体数字)</p></blockquote><blockquote><p>B解密，获得结果。</p></blockquote><blockquote><p>B发送密钥给A，A解密，获得结果。</p></blockquote></div><div class="tab-item-content" id="2-2"><blockquote><p>B 生成大数字 x，用 A 的公钥加密 x 得到 [x]A，将 [x]A – b 发送给A</p></blockquote><blockquote><p>A收到后：</p><blockquote><p>计算九个数字：[x]A – b + 1,  [x]A – b + 2 ,  …  ,  [x]A – b + 9.<br>并用自己的私有密钥解密这个些数字： { [x]A – b + 1 }A ,  { [x]A - b + 2 }A ,  …  ,  { [x]A - b + 9 }A<br>并将第 1 到第 a 结果 +1，其余不变</p></blockquote></blockquote><blockquote><p>A将 9 个结果按序发送给 Ｂ</p></blockquote><blockquote><p>Ｂ检测第 b 个数字，如果是 x，则 a &lt; b，否则 a &gt;&#x3D; b.(原理：若成功解密，说明第b项没有+1，即a＜b)</p></blockquote></div><div class="tab-item-content" id="2-3"><p>即将函数f(a,b)(比较a和b大小的函数)电路化，再对每个门电路进行加密。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="茫然传输协议"><a href="#茫然传输协议" class="headerlink" title="茫然传输协议"></a>茫然传输协议</h2></div><p>A 拥有 m1、m2，B需要知道指定的一个，而不知道另一个；A不知道B指定了哪个。</p><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">EGL协议</button><button type="button" class="tab " data-href="2-2">Naor-Pinkis协议</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><p>采用了姚期智解决百万富翁问题的方案。</p><blockquote><p>A，B 共享 y0，y1</p></blockquote><blockquote><p>B 选择 x，用 A 的公钥加密，得到 [x]A, 将 [x]A - yb 发送给 A</p></blockquote><blockquote><p>A计算 [x]A – yb + y0, [x]A – yb + y1，并用A的私钥解密这两个结果，得到 { [x]A – yb + y0 }A，{ [x]A – yb + y1 }A。因为b是确定的，故其中一个等于x，但A并不知道哪个是x。</p></blockquote><blockquote><p>A将 { [x]A - yb + y0 }A + m0，{ [x]A – yb + y1 }A + m1 发送给 B</p></blockquote><blockquote><p>B 计算 { [x]A - yb+ yb }A + mb - x 得到 mb。因为另一个数不等于x，B无从知道另一个m是什么，除非B知道A的私钥。</p></blockquote></div><div class="tab-item-content" id="2-2"><p>基于Elgamal加密算法实现。<br><img src="/study/mangran.png" alt="茫然传输"><br>若B知道C的离散对数，设其为t，则有<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo stretchy="false">(</mo><mi>C</mi><mrow><mo>&#x2F;</mo></mrow><msup><mi>g</mi><mrow><mrow><mo>β</mo></mrow></mrow></msup><msup><mo stretchy="false">)</mo><mrow><mi>a</mi></mrow></msup><mo>&#x3D;</mo><mfrac><msup><mi>g</mi><mrow><mi>a</mi><mi>t</mi></mrow></msup><msup><mi>g</mi><mrow><mi>a</mi><mrow><mo>β</mo></mrow></mrow></msup></mfrac><mo>&#x3D;</mo><mfrac><msup><mi>g</mi><mrow><mo stretchy="false">(</mo><mi>a</mi><mrow><mo>β</mo></mrow><msup><mo stretchy="false">)</mo><mrow><mfrac><mi>t</mi><mrow><mo>β</mo></mrow></mfrac></mrow></msup></mrow></msup><msup><mi>g</mi><mrow><mi>a</mi><mrow><mo>β</mo></mrow></mrow></msup></mfrac><mo>&#x3D;</mo><msubsup><mi>P</mi><mrow><mn>1</mn><mo>−</mo><mi>b</mi></mrow><mrow><mi>a</mi></mrow></msubsup><mo>。</mo></math></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="多方安全计算协议"><a href="#多方安全计算协议" class="headerlink" title="多方安全计算协议"></a>多方安全计算协议</h2></div><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">两方安全计算</button><button type="button" class="tab " data-href="2-2">混淆电路</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><blockquote><p>问题：A，B各自拥有秘密 a，b。A，B 希望计算函数 f ( a, b )，同时不泄漏 a，b。值域定义域均为 [n]。</p></blockquote><blockquote><p>解决1：A 生成函数表 f ( a, * )，B 和 A 运行 1 &#x2F; n 茫然传输，B 输入 b(表在A方，B查询输入b时候的输出值，且不让A知道查询的值，得到f(a,b))，B 得到 f ( a, b )。</p></blockquote><blockquote><p>解决2：混淆电路，更便于实现多方安全计算，开销更小。</p></blockquote></div><div class="tab-item-content" id="2-2"><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>多个</strong>参与方提供输入，计算一个函数值，同时不泄露各自的输入。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><blockquote><p>设现有电路模块M，两个0&#x2F;1输入，一个0&#x2F;1输出。A将0&#x2F;1输入映射为B0，B1，将0&#x2F;1输出映射为T0，T1，并在对应的真值表中，用输入的映射值对输出的映射值进行加密。A选取a的映射值作为输入。</p></blockquote><blockquote><p>B选取一个输入b(0&#x2F;1),并通过<strong>茫然传输</strong>从A那里获得输入的映射值。</p></blockquote><blockquote><p>A将a的映射发给B，因为B<strong>不知道对应关系</strong>，故不知道A的输入原本是什么；B用两个映射值对四个被加密的输出值进行解密，得到正确的输出映射值。(解密函数 D 具有可分辨性质，即能通过解密结果判定解密是否正确。)因为A给B的四个盒子被<strong>混淆</strong>，故B不能通过顺序关系找到A的输入是0还是1。</p></blockquote><blockquote><p>B将输出的映射值发给A，A查表后得到输出的原本值，再发给B。</p></blockquote><blockquote><p>现有多个M，通过逻辑线路相连（但B不应该知道是与门还是或门)，B应当通过对多个M的解密获得多个输出，再把这些输出当做其他M的输入，进而得到最终输出。(最终输出无需加密和映射)</p></blockquote><p>一个电路的所有门的混淆表集合称为电路的混淆电路。<br>混淆电路实现了安全计算的目标。<br><strong>这部分运用比理论简单，建议看回放</strong></p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><blockquote><p>A 拥有AES密钥 k</p></blockquote><blockquote><p>B 希望得到用 k 加密的 m, 即 AES ( k, m )</p></blockquote><blockquote><p>此过程结束后 B 得到 AES ( k, m )，但不知道 k。A 不知道 m。(实现方式：将AES加密逻辑转化为电路，并将输入值转换为0&#x2F;1比特)</p></blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note warning flat"><h2 id="安全计算目标"><a href="#安全计算目标" class="headerlink" title="安全计算目标"></a>安全计算目标</h2></div><h4 id="隐私保护"><a href="#隐私保护" class="headerlink" title="隐私保护"></a>隐私保护</h4><blockquote><p>计算无法通过协议得知对方的参数</p></blockquote><h4 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h4><blockquote><p>能正确地传递信息</p></blockquote><h4 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h4><blockquote><p>双方都可以得到结果</p></blockquote><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><blockquote><p>混淆电路协议对诚实但好奇(观察分析)的攻击者是安全的</p></blockquote><p>参考：<br>1.<a href="http://t.csdnimg.cn/mfXre" title="" target="">CSDN：【隐私计算篇】混淆电路深入浅出</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：俄国农民指数算法</title>
      <link href="/posts/db01f830.html"/>
      <url>/posts/db01f830.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note primary flat"><h2 id="俄国农民指数算法"><a href="#俄国农民指数算法" class="headerlink" title="俄国农民指数算法"></a>俄国农民指数算法</h2></div><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">正向快速幂(R-L算法)</button><button type="button" class="tab " data-href="1-2">逆向快速幂(L-R算法)</button><button type="button" class="tab " data-href="1-3">比较</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">FastPow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> g,<span class="type">long</span> <span class="type">long</span> e,<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> m)</span> <span class="comment">//求g的e次方模m的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(e)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span>(e&amp;<span class="number">1</span>)</span><br><span class="line">        ans=(ans*g)%m;</span><br><span class="line">        g=(g*g)%m;</span><br><span class="line">        e&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="1-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">FastPow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> g,<span class="type">long</span> <span class="type">long</span> e,<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> m)</span> <span class="comment">//求g的e次方模m的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(e)  <span class="comment">//e采用反向存储</span></span><br><span class="line">        &#123;</span><br><span class="line">        ans=(ans*ans)%m;</span><br><span class="line">        <span class="keyword">if</span>(e&amp;<span class="number">1</span>)</span><br><span class="line">        ans=(ans*g)%m;</span><br><span class="line">        e&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>a</mi><mi>n</mi><mi>s</mi><mo>∗</mo><mi>a</mi><mi>n</mi><mi>s</mi><mo>&#x3D;</mo><msup><mi>g</mi><mrow><msub><mi>e</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>e</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><msub><mi>e</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>e</mi><mrow><mn>2</mn></mrow></msub><msub><mi>e</mi><mrow><mn>1</mn></mrow></msub><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mn>0</mn><mo data-mjx-texclass="CLOSE">]</mo></mrow></mrow></msup><mo>,</mo><mo>如果</mo><msub><mi>e</mi><mrow><mn>0</mn></mrow></msub><mo>&#x3D;</mo><mn>1</mn><mo>,</mo><mo>则再乘以</mo><mi>g</mi><mo>，否则不变。</mo></math></p></div><div class="tab-item-content" id="1-3"><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><blockquote><p>两种算法都需要平均1.5∗(n −1) 次乘法。</p></blockquote><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><blockquote><p>第二种是用固定的g值作乘法，第一种的g值是变化的，因此在硬件实现时，需要增加一个寄存器。</p></blockquote><blockquote><p>第一种算法中，平方和模乘是独立的，可以并行运算。但在第二种算法中不能。</p></blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="俄国农民乘法算法"><a href="#俄国农民乘法算法" class="headerlink" title="俄国农民乘法算法"></a>俄国农民乘法算法</h2><p>图片见下：<br><img src="/study/nongm.png" alt="俄国农民"></p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;  <span class="comment">//当a是2的倍数时，加上b的2次幂；否则不加</span></span><br><span class="line">    <span class="type">int</span> ans=b&amp;(a%<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span>(a!=<span class="number">0</span>)&#123;</span><br><span class="line">        b=b*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        ans+=b;</span><br><span class="line">    &#125;</span><br><span class="line">    a=a/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><h2 id="笔纸算法"><a href="#笔纸算法" class="headerlink" title="笔纸算法"></a>笔纸算法</h2></div><p>简单来说，就是用程序模拟手算乘法时的<strong>竖式</strong>计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[], <span class="type">int</span> c[])</span> </span>&#123; <span class="comment">//OI WIKI</span></span><br><span class="line">  <span class="built_in">clear</span>(c);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 这里直接计算结果中的从低到高第 i 位，且一并处理了进位</span></span><br><span class="line">    <span class="comment">// 第 i 次循环为 c[i] 加上了所有满足 p + q = i 的 a[p] 与 b[q] 的乘积之和</span></span><br><span class="line">    <span class="comment">// 这样做的效果和直接进行上图的运算最后求和是一样的，只是更加简短的一种实现方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) c[i] += a[j] * b[i - j];</span><br><span class="line">    <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">      c[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><h2 id="比笔纸算法更快的算法"><a href="#比笔纸算法更快的算法" class="headerlink" title="比笔纸算法更快的算法"></a>比笔纸算法更快的算法</h2></div><p>用递归的方式优化乘法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multiply</span>(u, v) <span class="comment">//快速计算uv；</span></span><br><span class="line">Input: 正整数 u、 v, in binary</span><br><span class="line">Output: uv</span><br><span class="line">n = <span class="built_in">max</span>(size of u, size of v)</span><br><span class="line"><span class="keyword">if</span> n = <span class="number">1</span>  <span class="keyword">return</span> xy</span><br><span class="line">U1=u的高n/<span class="number">2</span>位， U0 =  u的低 n/<span class="number">2</span> 位</span><br><span class="line">V1 =v的高n/<span class="number">2</span>位, V0= v的低 n/<span class="number">2</span> 位</span><br><span class="line">P1 = <span class="built_in">multiply</span>(U1, V1)</span><br><span class="line">P2 = <span class="built_in">multiply</span>(U0 , V0)</span><br><span class="line">P3 = <span class="built_in">multiply</span>(U1-U0, V0-V1)</span><br><span class="line"><span class="keyword">return</span> =(<span class="number">2</span>^n<span class="number">+2</span>^n/<span class="number">2</span>)P1<span class="number">+2</span>^n/<span class="number">2</span>*P2+(<span class="number">2</span>^n/<span class="number">2</span><span class="number">+1</span>)P3</span><br></pre></td></tr></table></figure><p>递归表达式：<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>T</mi><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo><mo>≤</mo><mn>3</mn><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>c</mi><mi>n</mi></math><br>最终，算法复杂度约为n的1.5次方。</p><div class="note primary flat"><h2 id="复数乘法"><a href="#复数乘法" class="headerlink" title="复数乘法"></a>复数乘法</h2></div><p>两个复数相乘时，减少乘法的次数为3次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">复数乘法(a+bi)*(c+di): <span class="comment">//四次乘法改三次乘法</span></span><br><span class="line">A=a*d</span><br><span class="line">B=b*c</span><br><span class="line">C=(a+b)*(c-d)</span><br><span class="line">(a+bi)*(c+di)=(C-A+B)+(A+B)i</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：蒙哥马利约减</title>
      <link href="/posts/11252e67.html"/>
      <url>/posts/11252e67.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note primary flat"><h2 id="蒙哥马利约减"><a href="#蒙哥马利约减" class="headerlink" title="蒙哥马利约减"></a>蒙哥马利约减</h2></div><p>目前使用最广泛的模指数运算方法</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote><p>求y mod N，N为质数。y称为x模N关于R的Montgomery约减,即y&#x3D;xR’ mod N</p></blockquote><blockquote><p>附加条件：不使用除法（除法速度慢）</p><blockquote><p>尽量避免使用取模运算<br>用移位、减法运算替代取模运算</p></blockquote></blockquote><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><blockquote><p>1.取R为2的n次方(如果 N表示为n个b进制数，则 R取b的幂次方)，这样&#x2F; R即右移，*R即左移，mod R即与（R-1）按位与，大大提高了速度。</p></blockquote><blockquote><p>2.N&lt;R,R和N互质，即存在R’和N’，使得RR’ + NN’＝1(保证对任意的x＜R，有k＜R，使得kN&#x3D;x＜R。这保证<strong>表达式</strong>(见下文)的后半部分有解，且大小不超过R&#x2F;R&#x3D;1)。同时，加上y&#x2F;R＜N，故<strong>表达式</strong>的前半部分大小不超过N。综上可得，表达式整体大小不超过2N(故取模可以用减法做)。</p></blockquote><h4 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h4><p>设T&#x3D;Qm+r，欲求T mod m<br>将T分为n的两部分，高n位为T’，低n位为T’’<br>则：<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mfrac><mi>T</mi><mi>R</mi></mfrac><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi><mo>&#x3D;</mo><msup><mi>T</mi><mo>′</mo></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi><mo>+</mo><mn>0.</mn><msup><mi>T</mi><mo>″</mo></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math><br>前半部分只需要移位和最多一次减法。<br>对于后半部分，需要找到0.km，使其与表达式后半部分相加，能将小数部分变成0。即T’’+km&#x3D;cR(R的低位全为0)。加之m和R互素，故这样的k一定存在。实际上，k&#x3D;-1&#x2F;m*T’’ mod R<br>综合可得，T+km是R的倍数。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∗</mo><mi>N</mi><mrow><mo>′</mo></mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>R</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>N</mi><mo stretchy="false">)</mo><mrow><mo>&#x2F;</mo></mrow><mi>R</mi><mo>≡</mo><mi>x</mi><mo>∗</mo><msup><mi>R</mi><mo>′</mo></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>N</mi></math></p></blockquote><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∗</mo><mi>N</mi><mrow><mo>′</mo></mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>R</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>N</mi><mo stretchy="false">)</mo><mrow><mo>&#x2F;</mo></mrow><mi>R</mi><mo>&lt;</mo><mn>2</mn><mi>R</mi></math></p></blockquote><p>x模 N 关于 R 的Montgomery 约减用2次乘法、1次加法(把-k换成k)、2次移位、1次减法(最后取模时使用)。<br><strong>注意：xmod R和x’’ modR结果一致，因为x’mod R结果为0。同时，结论的x*N‘ modR等于推导式中的-k</strong></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><blockquote><p>取N &#x3D; 3457，R &#x3D; 2^16，得到N’＝12929，R’＝682。求y mod N：</p></blockquote><blockquote><blockquote><p>计算得<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>3310</mn><mo>≡</mo><mi>R</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>N</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>由结论得，<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>y</mi><mo>≡</mo><mo stretchy="false">(</mo><mi>y</mi><mo>∗</mo><mi>R</mi><mo>−</mo><mo stretchy="false">(</mo><mi>y</mi><mo>∗</mo><mi>R</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>N</mi><mrow><mo>′</mo></mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>R</mi><mo>∗</mo><mi>N</mi><mo stretchy="false">)</mo><mrow><mo>&#x2F;</mo></mrow><mi>R</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>代入计算得，<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>y</mi><mo>≡</mo><mo stretchy="false">(</mo><mi>y</mi><mo>∗</mo><mn>3310</mn><mo>−</mo><mi>y</mi><mo>∗</mo><mn>3310</mn><mo>∗</mo><mn>12929</mn><mi>m</mi><mi>o</mi><mi>d</mi><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup><mo>∗</mo><mn>3457</mn><mo stretchy="false">)</mo><mrow><mo>&#x2F;</mo></mrow><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup></math></p></blockquote></blockquote><blockquote><blockquote><p>这种方法的另一个优势在于，<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>R</mi><mo>∗</mo><mi>N</mi><mrow><mo>′</mo></mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>R</mi><mo>∗</mo><mi>N</mi></math>也即<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>12929</mn><mi>m</mi><mi>o</mi><mi>d</mi><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup><mo>∗</mo><mn>3457</mn></math> 可提前计算。</p></blockquote></blockquote><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> u;</span><br><span class="line">    u = a * QINV;  <span class="comment">//QINV固定</span></span><br><span class="line">    t = u * CTRU_Q;<span class="comment">//CTRU_Q固定</span></span><br><span class="line">    t = a - t;</span><br><span class="line">    t &gt;&gt;= <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用：模指数"><a href="#应用：模指数" class="headerlink" title="应用：模指数"></a>应用：模指数</h4><blockquote><p>计算 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>x</mi><mrow><mn>5</mn></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote><blockquote><blockquote><p>计算x*R²的M约减  <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>x</mi><mrow><mo stretchy="false">̃</mo></mrow><mo>&#x3D;</mo><mi>x</mi><mi>R</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>计算x̃²的M约减A： <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>x</mi><msup><mrow><mo stretchy="false">̃</mo></mrow><mrow><mn>2</mn></mrow></msup><mrow><mo>&#x2F;</mo></mrow><mi>R</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>计算A平方的M约减 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>A</mi><mrow><mn>2</mn></mrow></msup><mrow><mo>&#x2F;</mo></mrow><mi>R</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi><mo>&#x3D;</mo><mi>x</mi><msup><mrow><mo stretchy="false">̃</mo></mrow><mrow><mn>4</mn></mrow></msup><mrow><mo>&#x2F;</mo></mrow><msup><mi>R</mi><mrow><mn>3</mn></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>A平方的M约减 乘 x̃的M约减，再进行约减，即得。</p></blockquote></blockquote><p>乘方写成函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x̃ = <span class="built_in">MR</span>(x * (R方 mod m)), ã = <span class="built_in">MR</span>(<span class="number">1</span>*(R方 mod m) ) <span class="comment">//逆向快速幂，输出：x^&#123;e&#125; mod m.</span></span><br><span class="line">For i = t downto <span class="number">0</span></span><br><span class="line">ã = <span class="built_in">MR</span>(ã* ã)</span><br><span class="line">If ei = <span class="number">1</span> then ã = <span class="built_in">MR</span>(ã* x̃)</span><br><span class="line">a = <span class="built_in">MR</span>(ã)</span><br><span class="line"><span class="built_in">Return</span>(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="应用：取模乘法"><a href="#应用：取模乘法" class="headerlink" title="应用：取模乘法"></a>应用：取模乘法</h4><blockquote><p>计算 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>c</mi><mo>&#x3D;</mo><mi>x</mi><mo>∗</mo><mi>y</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote><blockquote><blockquote><p>计算x的M变换 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>x</mi><mo>′</mo></msup><mo>&#x3D;</mo><mi>x</mi><mo>∗</mo><msup><mn>2</mn><mrow><mi>n</mi></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>计算y的M变换 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>y</mi><mo>′</mo></msup><mo>&#x3D;</mo><mi>y</mi><mo>∗</mo><msup><mn>2</mn><mrow><mi>n</mi></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>计算x’和y’的积，再进行M约减 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>c</mi><mo>′</mo></msup><mo>&#x3D;</mo><msup><mi>x</mi><mo>′</mo></msup><mo>∗</mo><msup><mi>y</mi><mo>′</mo></msup><mrow><mo>&#x2F;</mo></mrow><msup><mn>2</mn><mrow><mi>n</mi></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>进行约减，即得。</p></blockquote></blockquote><h4 id="优化：用M约减实现M变换"><a href="#优化：用M约减实现M变换" class="headerlink" title="优化：用M约减实现M变换"></a>优化：用M约减实现M变换</h4><blockquote><p>即计算<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>x</mi><mo>′</mo></msup><mo>&#x3D;</mo><mi>x</mi><mo>∗</mo><msup><mn>2</mn><mrow><mn>2</mn><mi>n</mi></mrow></msup><mrow><mo>&#x2F;</mo></mrow><msup><mn>2</mn><mrow><mi>n</mi></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote><h4 id="优化：多精度M约减"><a href="#优化：多精度M约减" class="headerlink" title="优化：多精度M约减"></a>优化：多精度M约减</h4><p>当T比较大时。<br>T为2n位，N为n位，R为b的n次方。<br>理论：<br><img src="/study/gaojj.png" alt="多精度"><br>实例：<br><img src="/study/gaoj.png" alt="多精度"></p><h4 id="优化：多精度M乘法"><a href="#优化：多精度M乘法" class="headerlink" title="优化：多精度M乘法"></a>优化：多精度M乘法</h4><p>x为n位，y为n位，N为n位，R为b的n次方。<br>理论：<br><img src="/study/gaoj2j.png" alt="多精度"><br>实例：<br><img src="/study/gaoj2.png" alt="多精度"><br><strong>证明方式见回放</strong></p><div class="note primary flat"><h2 id="barrett约减"><a href="#barrett约减" class="headerlink" title="barrett约减"></a>barrett约减</h2></div><p><img src="/study/barrett.png" alt="barrett"><br>其中r1-r2可能为负数，只需要加一次模。(因为−b^{k+1} &lt; r1 − r2 &lt; b^{k+1})<br>其中第四步最多执行2次。(因为Q-q3≤2)<br>设x&#x3D;Qm+r，则x 的高 k+1位与 1&#x2F;m 的高 2k 比特中的低 k+1 位相乘，取整数部分(高k+1位)得到Q的近似值q3(Q-2≤q3≤Q)。Qm+r-q3m对m取模得到r。<br>问题<br>为什么是模b的k+1次方，为什么要求b&gt;3？ <span class="hide-inline"><button type="button" class="hide-button" style="">Click  </button><span class="hide-content">因为r1-r2＜3m，而m占据k位，如果需要r1-r2少于k+1位(极致地压低模的大小有利于计算速度)，则b>3。若b≤3，则r1-r2为负数时，不只需要加一次模。b的k+1次方，是能保证正确性下的，最方便计算的模数。</span></span><br>为什么r1和r2对非m取模，不影响正确性？ <span class="hide-inline"><button type="button" class="hide-button" style="">Click  </button><span class="hide-content">若m＝1，则结果为1；若m=2，则判断奇偶性；m≥3时，因为Q-q3≤2，且b的k+1次方大于2，故r1、r2对b的k+1次方取模后相减，不会影响正确的Q和q3的差值。加之r＜m＜b的k+1次方，故不会影响正确的r的大小。 实际上，我们并不需要关心Q和q3相差了多少和变没变。这个结果无非是m的系数，多减几次m便可以去除。但是，将Q-q3的结果控制在固定大小内，可以优化减m的速度。</span></span><br>为什么要求b&gt;k？ <span class="hide-inline"><button type="button" class="hide-button" style="">Click  </button><span class="hide-content">使q2的 k − 1位的进位最多是1，若 b 远大于 k，则只需包括 k 和 k+1位的计算。 q2 的低 k-1 位不用参与计算。**详细证明见回放**</span></span></p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>b</mi><mo>&#x3D;</mo><mn>4</mn><mo>,</mo><mi>k</mi><mo>&#x3D;</mo><mn>3</mn><mo>,</mo><mi>x</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>313221</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo>,</mo><mi>m</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>233</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo>&#x3D;</mo><msub><mn>3561</mn><mrow><mn>10</mn></mrow></msub><mo>，</mo><mi>m</mi><mo>&#x3D;</mo><msub><mn>47</mn><mrow><mn>10</mn></mrow></msub><mo stretchy="false">)</mo><mo>.</mo></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mfrac><mn>1</mn><mi>m</mi></mfrac><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>0.00111302</mn><mo>·</mo><mo>·</mo><mo>·</mo><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">⟹</mo><mrow><mo>µ</mo></mrow><mo>&#x3D;</mo><mo stretchy="false">⌊</mo><mfrac><msup><mn>4</mn><mrow><mn>6</mn></mrow></msup><mi>m</mi></mfrac><mo stretchy="false">⌋</mo><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>1113</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo>,</mo></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>x</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>313221</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">⟹</mo><mi>q</mi><mn>1</mn><mo>&#x3D;</mo><mo stretchy="false">⌊</mo><mfrac><mi>x</mi><msup><mn>4</mn><mrow><mn>2</mn></mrow></msup></mfrac><mo stretchy="false">⌋</mo><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>3132</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo>,</mo></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>q</mi><mn>2</mn><mo>&#x3D;</mo><mrow><mo>µ</mo></mrow><mo>·</mo><mi>q</mi><mn>1</mn><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>10231302</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">⟹</mo><mi>q</mi><mn>3</mn><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>1023</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>x</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>313221</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">⟹</mo><mi>r</mi><mn>1</mn><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>3221</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>q</mi><mn>3</mn><mo>·</mo><mi>m</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>313011</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">⟹</mo><mi>r</mi><mn>2</mn><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>3011</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo>,</mo></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>r</mi><mo>&#x3D;</mo><mi>r</mi><mn>1</mn><mo>−</mo><mi>r</mi><mn>2</mn><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>210</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub></math></p><p>故 x mod m &#x3D; 36。</p><p>参考：<br>1.<a href="http://t.csdnimg.cn/prAaS" title="" target="">CSDN：蒙哥马利约减</a><br>2.<a href="https://blog.csdn.net/mutourend/article/details/95613967?fromshare=blogdetail&sharetype=blogdetail&sharerId=95613967&sharerefer=PC&sharesource=lemonsed&sharefrom=from_link" title="" target="">CSDN：Montgomery reduction——多精度模乘法运算算法</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到第九边缘</title>
      <link href="/posts/6b6b7c33.html"/>
      <url>/posts/6b6b7c33.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><script>    (function(d, w, c) {        w.ChatraID = 'D5JbrYK4vHavdTNTf';        var s = d.createElement('script');        w[c] = w[c] || function() {            (w[c].q = w[c].q || []).push(arguments);        };        s.async = true;        s.src = 'https://call.chatra.io/chatra.js';        if (d.head) d.head.appendChild(s);    })(document, window, 'Chatra');</script><h2 id="一、什么是第九边缘文化体系"><a href="#一、什么是第九边缘文化体系" class="headerlink" title="一、什么是第九边缘文化体系"></a>一、什么是第九边缘文化体系</h2><p>“第九边缘是什么？相信并不是所有人都能够意识到。包括我们的代理者，也不能轻易做出一个明确的定义。或许，第九边缘并不符合他们的文化倾向。但在我们的世界里，第九边缘意味着“理性的文化”。它作为一个哲学符号，又或者是文明的动态象征，第九边缘的创造物意味着我们整个世界的智慧与现实。创造意味着新生，意味着第九边缘带来与现实截然不同的选择，记录意味着同步，意味着第九边缘的描述符合我们世界的基本认知，感知意味着神觉，意味着第九边缘存在超出我们世界的看法。在我们的世界里，虚构的文化太多，越来越多的人不重视实际存在的文明。随处可见的新文化，正在抹除文明本身的重量，使人们轻薄于学习既有的事物，去了解既有的历史。我们急需一种代表，能够保存我们的实际文明的同时，吸引绝大多数人们接纳我们的现实世界。这就是第九边缘，一个虚拟的科研组织，一个文明的汇聚之核。”（来自第九边缘：创世档案）<br>这是来自《创世档案》中的描述。可见，我们一直在回避这个问题。究其原因，是我们未曾拥有真实的历史。具体而言，第九边缘诞生于初中的一次灵感，又或者发源自一个初中生对虚构式未来的幻想。<br>我们在幻想世界的途中，融入了太多太多的元素。从自然、世界、人生，到风格、测试、涵养，我们融合了我们所认可的人类文化，也在尽我们所能塑造人类文化的一角。<br>但万事万物，如果一旦将其落在纸笔之上，就会拥有一个独属于它的定义。否则，我们无法认识到自己在做什么。<br>简单来说，<strong>第九边缘文化体系是一种理性的、规范的世界哲学体系，是立足于内在自我的，看待世界的一种立场、观点、方法。</strong><br>我们正式地在其后加上“体系”两字，是因为我们已经准备好向大众展示我们的世界。“体系”不仅意味着第九边缘从虚构世界的“科研团体”走出，而且意味着我们打算以一种成体系的方式展示我们的构造之物。<br>下面，我们将介绍第九边缘文化体系的构成。（在不引起争议时，我们将第九边缘文化体系简称为第九边缘）</p><h3 id="（一）-第九边缘理论研究及文章创造（SCHNIE）"><a href="#（一）-第九边缘理论研究及文章创造（SCHNIE）" class="headerlink" title="（一）.第九边缘理论研究及文章创造（SCHNIE）"></a>（一）.第九边缘理论研究及文章创造（SCHNIE）</h3><p>第九边缘的理论包含世界宇宙观，人生价值观，五维能力测试等部分，文章包含灵耀体系，九虹重启，三大规划等部分。<br>SCHNIE既从生活中提炼一些理性规则，也从一些典籍中寻找构建神话体系的力量。我们有批判，有引导，但同时也有激进，有妥协。我们需要不断面对自己的不足，也希望读者能够成为我们不断前行的后备力量。</p><h3 id="（二）-第九边缘内容椽笔及平台建设（SCHNIEBOW）"><a href="#（二）-第九边缘内容椽笔及平台建设（SCHNIEBOW）" class="headerlink" title="（二）.第九边缘内容椽笔及平台建设（SCHNIEBOW）"></a>（二）.第九边缘内容椽笔及平台建设（SCHNIEBOW）</h3><p>理论需要从实践中得到证实。<br>世界也需从运作中不断获取新的活力。第九边缘的平台包含QQ群，QQ频道，QQ发布号，官方网站，官方bilibili账号，微信公众号等。即便我们没有专业的力量协助，也能够构建出一个模糊但缺失专业性的框架。<br>我们迫切地需要外界的帮助，因为我们不擅长宣传自己。即便为了个数而扩展影响与我们的理性理念背道相驰，但我们的体系经过长期的理论积压，很难能够找出其中不断放大的缺陷。<br>世界总是完整的，而我们的体系注定如彩虹一般，只有部分流露在外。这是一种自我保护，也是一种保守底牌的策略。但我们由衷地希望，我们呈现出的那些光彩，能够照亮每一个需要的角落。<br>而这些角落，依赖大家的视线，依赖大家共同撑起的网络。</p><h3 id="（三）-第九边缘体系内核（schrodingerXI）"><a href="#（三）-第九边缘体系内核（schrodingerXI）" class="headerlink" title="（三）.第九边缘体系内核（schrodingerXI）"></a>（三）.第九边缘体系内核（schrodingerXI）</h3><p>极简，精确，相和，理性。<br>不添加多余之物，以最直接的方式逼近事物的内核；不被表象和偏见迷惑，以最关键的力量冲击事物的本质；与世界共生，与同伴共进，保持理性，不断前行。<br>感知，记录，创造。<br>感知是万物存在的标志，记录是万物运行的轨迹，创造是万物变化的结果。三生万物，竞逐方舟。<br>第九边缘，是人与世界共同的体系。</p><h3 id="（四）-第九边缘模组使用协议（DLXII）"><a href="#（四）-第九边缘模组使用协议（DLXII）" class="headerlink" title="（四）.第九边缘模组使用协议（DLXII）"></a>（四）.第九边缘模组使用协议（DLXII）</h3><p>与一般的“小说”不同的是，第九边缘的世界构造并不是由我们独立编辑，而是由探索者共同编辑的。我们共享我们的世界，也需要大家的共同维护。<br>读者们可以在原作的基础上进行修改，并著以第九边缘的标识进行传播。但不得添加其他的限制条件，不得以此谋利，不得申请版权及发布在小说网站，也不得转嫁责任给其他维护者。<br>我们尊重你从中获取灵感的权益，也尊重你作为一个独立创作者的权益。<br>在这种方式下，有一个显著的好处：第九边缘的世界构造，更能够接近我们所追求的“理性”—从最大程度上避免因偏见，知识面不全而造成世界构造的疏漏。这也符合我们追求效率这一原则。<br>我们诚恳地邀请您协助我们构建那个世界。在这里，我们将共享所有的与世界构造有关的内容，您可以查阅后以自己的理解来补充或创造新的内容。</p><h2 id="二、第九边缘的起源和发展"><a href="#二、第九边缘的起源和发展" class="headerlink" title="二、第九边缘的起源和发展"></a>二、第九边缘的起源和发展</h2><p>正如上文所言，第九边缘来自于一个灵感。虽然我们不能够从我们的发展历史中获得自信—我们的实践来自于对内在世界的不断探索，而非体现在对外部世界的探究和改造。我们也缺乏专业的素养，甚至，第九边缘的整个世界，都来自于一份稚嫩的猜想。<br>不过，我们希望保持这种落后性。第九边缘不是某些哲学思想的复制品，也不是一类哲学思想的整合。我们希望这些显有稚嫩的个人偏见，能够成为读者世界观，人生观，价值观参照或批判的一部分。<br>第九边缘在2021年推出了《设定合集》，其主体内容是我们认为的值得分享的美好事物；并在2022年推出了《以神之名》：它的出现意味着我们的哲学内核，即世界观，人生观，自然观趋于成熟。<br>在2023年，大学生活打开了我们走向世界的大门，我们推出了《梦境疗法》，我们第一次以一种伪互动的文体向读者展示我们的构造世界。<br>而2024年所著的《第九边缘文化体系：概论》则采用了思政类“教科书”的特点：分条分点，逐步递进，全文关联。<br>在创作这本书的念头诞生前，我们也曾建立过QQ群，以诸多文件为载体，分享我们的世界。但结果不尽乐观：读者们似乎对这种“莫名其妙”的分类不具有兴趣，而且难以理解高度凝练到过于抽象的思想逻辑。<br>即便第九边缘一直试图在具体的事情中探索抽象，而非在抽象的逻辑中强求具体，但我们选取的被当做“具体”的对象，对于第一次接触我们的人而言，还是过于晦涩抽象。<br>故我们需要一个引导者，一个忠实的、不厌其详的引导者，将我们的创造物分散到各个篇章，以一种更加科学合理的方式，引导读者认识并认知我们的世界。</p><h2 id="三、九大课题"><a href="#三、九大课题" class="headerlink" title="三、九大课题"></a>三、九大课题</h2><p>提出诸多概念，指出多种模型，归根结底是为了回答一些问题。第九边缘认为我们需要回答九个课题。<br>1.开端也是结局：世界，无比真实，回答对世界本质的整体把握的课题。第九边缘认为世界无所谓真实与虚幻，我们希望能够活在属于自己的理念世界里。读者们可以思考：万物客观存在，还是受限于观测者？事物性质是可知的，还是不可明确？事物根本上是统一的，还是各自划分区域？<br>2.稳定但是多变：思维，融于物质，回答对事物逻辑的规范划分的课题。第九边缘认为世界由物质构成，可物质以思维为形式，投递到我们的意识之中。读者们可以思考：事物有哪些存在方式，他们之间的联系是什么？我们能获得哪些信息，他们之间的联系是什么？事物间有哪些关系，这些关系的联系是什么？<br>3.世界起源：能量与时间差，回答发展与起源的课题。第九边缘认为能量不均导致时间流动，而时间流动激化思维，进一步演变成物质。读者们可以思考：发展和更替是无限的，还是存在端点？起源和覆灭是明确的，还是混沌一体？<br>4.矛盾产生：这成必要决断，回答选择与取向的课题。第九边缘认为矛盾的出现，使万物万事凝聚成该有的形状。读者们可以思考：真理和价值是客观规定的，还是个性化选择？理论和认知是逐步完善的，还是虚构的逻辑？<br>5.故事开端：我们为何生活，回答生存与生活的课题。第九边缘认为生活是社会赋予的职责，同时也能填补不平衡的内心。读者们可以思考：在你的世界观里，维持生存有哪些必然因素？在你的世界观里，追求生活有哪些不同方式？<br>6.恪守本分：臣服乃是前提，回答社会与自我的课题。第九边缘认为在有能力质疑或改变一件事之前，必经臣服。读者们可以思考：外界秩序和更优策略发生冲突时，如何处理？社会道德和个人判断发生冲突时，如何评判？<br>7.维系深井：认知存在局限，回答实力和认知的课题。第九边缘认为智慧徒增伤感，没有实力之前，请甘于维护愚昧。读者们可以思考：实力不足以支撑认知时，认知是什么地位？所处环境不认可实力时，实力是什么地位？<br>8.遗忘但是存在：意识，还是事实，回答对自我存在的空泛认知的课题。第九边缘认为承载已发生之事的记忆，决定着“我”是谁。读者们可以思考：自我和他我的界限是什么？不同阶段自我界限是什么？“自我”的概念依赖什么而产生？<br>9.终端也是启程：世界，本成一线，回答对一切概率的均衡判决的课题。第九边缘认为所有可能都在实际发生，我们做出的选择，是一场场自己与自己的争斗。读者们可以思考：万事皆可存在，还是依赖逻辑？事物早已决定，还是无限可能？追求注定随生命而消逝的未来，究竟是为了什么？</p><h2 id="四、如何看待第九边缘世界"><a href="#四、如何看待第九边缘世界" class="headerlink" title="四、如何看待第九边缘世界"></a>四、如何看待第九边缘世界</h2><p>现实存在着混沌、泥泞、内卷、腐败。不如向内看，广泛而自由地肯定自己的精神价值，从认可自我开始，从改变认知方式开始，重新观察世界，探索世界，改变世界。<br>第九边缘文化体系绝不是是什么严肃的文化依托，也不是什么专业的产物。它更像是一种建议，建议我们的读者以某种被建议的方式认识世界，改造世界，从而在探索世界中获得乐趣，在研究世界中获得感触。<br>没有人的偏见是理所当然的，但当我们质疑一种不合理时，自身的理性直觉从未是一种理由。我们希望读者们能够有原因地指出我们的缺点，我们乐于在不断改正中前行。<br>向后看是为了把握外壳，向前看是为了赋予生命。那么，就让我们从这里开始：<br>追溯，启航！</p><h2 id="参考书下载"><a href="#参考书下载" class="headerlink" title="参考书下载"></a>参考书下载</h2><a href="https://picbed.sch-nie.com/SCHNIE/%E7%AC%AC%E4%B9%9D%E8%BE%B9%E7%BC%98%E6%96%87%E5%8C%96%E4%BD%93%E7%B3%BB%EF%BC%9A%E6%A6%82%E8%AE%BA.pdf" title="" target="">第九边缘文化体系概论</a></div>]]></content>
      
      
      <categories>
          
          <category> 世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SCHNIE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宇宙-世界</title>
      <link href="/posts/1.html"/>
      <url>/posts/1.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><script>    (function(d, w, c) {        w.ChatraID = 'D5JbrYK4vHavdTNTf';        var s = d.createElement('script');        w[c] = w[c] || function() {            (w[c].q = w[c].q || []).push(arguments);        };        s.async = true;        s.src = 'https://call.chatra.io/chatra.js';        if (d.head) d.head.appendChild(s);    })(document, window, 'Chatra');</script><h1 id="Zero-第九边缘关于世界边缘的一个猜想"><a href="#Zero-第九边缘关于世界边缘的一个猜想" class="headerlink" title="Zero:第九边缘关于世界边缘的一个猜想"></a>Zero:第九边缘关于世界边缘的一个猜想</h1><p><code>Nine Sections about a real world 所有的内核与本质皆存在于理论计算中</code></p><p>本文主要介绍了与量元、事件、特征、衍影等概念相关的物质世界的基本要素和特征，以及它们与时间、空间、思维等方面的关系。</p><p>PART1：Ten basic concepts.    第九边缘宇宙观下十个基本概念。</p><p>PART2：Four basic characteristics.第九边缘宇宙观下世界的四大特征。</p><p>PART3：Some construction models.第九边缘宇宙观下的一些分析模型。</p><p>PART4：Some specific structures.第九边缘宇宙观下一些具体的结构。</p><hr><h2 id="Part1：Ten-basic-concepts"><a href="#Part1：Ten-basic-concepts" class="headerlink" title="Part1：Ten basic concepts"></a>Part1：Ten basic concepts</h2><h3 id="1-量元"><a href="#1-量元" class="headerlink" title="1.量元"></a>1.量元</h3><p>随机组成任何对象的基础单元。</p><p>Relations-</p><p>不同的事件间通过量元的活动延续。</p><p>Structures-</p><p>量能</p><p>量元构建的对象所具有的能量。</p><p>发生率</p><p>量元构建的对象表达“存在性”的概率。</p><h3 id="2-事件"><a href="#2-事件" class="headerlink" title="2.事件"></a>2.事件</h3><p>对象结合时空及其逻辑共同表现出的一定的动态形式。</p><p>Relations-</p><p>维度为时空维度，事件沿着联系，在时间和空间上进行扩张。</p><p>Functions-</p><p>世界由事件构成。</p><p>Features-</p><p>事件在稳定的时空中按照一定的规律发展。</p><p>事件内部的信息是同步共享的，不存在思维介导。</p><p>事件若可发展，则必然发展。</p><h3 id="3-物质-时空法则"><a href="#3-物质-时空法则" class="headerlink" title="3.物质&#x2F;时空法则"></a>3.物质&#x2F;时空法则</h3><p>能在多空间稳定发生“超控映射”的特定量元组成。</p><p>Functions-</p><p>限制与其有关联的低维度对象。</p><p>Features-</p><p>事物是可知的。事物本身的特性依赖于时空稳定性而相对稳定，观测者能通过不断细化的方式认识到事物间的联系特点，表现为事物特性的显化。事物本身的特性存在终点，而事物之间的联系会因不断认识到的新特性而被认识或因虚拟逻辑的产生而暂时增加或减少。总体认知的发展会给事物带来新的联系和变数，进而呈现为思维，并映射成物质投递到我们的意识之中。</p><p>物质存在的前提是可与其他物质发生冲突。</p><p>物质是一些列信息的稳定结合体，被观测方式不同，传递的信息不同。</p><p>物质所结合的信息符合相似的规律，这些信息间相互联系。</p><p>物质在向低维时空传导时，其在客体时空内仅具有客体所在的时空的思维范围内的特征。</p><p>事物的存在有三种相对的形态，分别是:物质(稳定的信息结构)，意识(被局限的思维活动)，思维(变化着的信息)。</p><p>Examples-</p><p>“物体”，“自然规律”，“社会规律”</p><p>Relations-</p><p>物质的根本属性是超控。</p><p>决定事件发展的规律和方式。</p><p>决定意识。意识为被限制的思维活动特征，而这种限制依赖于稳定可循的物质。</p><p>时空法则使量元有一定特征，当某种量元不存在时，对象无法对该量元组成的任何形式交涉。</p><h3 id="4-思维"><a href="#4-思维" class="headerlink" title="4.思维"></a>4.思维</h3><p>所有状态正在改变的对象所正在呈现的信息。</p><p>Examples-</p><p>“语言”，“知识”，“外表”，“行为”，“记忆”</p><p>Relations-</p><p>干预事件发展的进程。</p><p>Additions-</p><p>概念</p><p>物质性质是固有的，但概念是无法穷尽的。概念是思维体对客观现象的主动划分。</p><p>思考</p><p>思考即将现象中的相似部分连接到同一抽象概念，并构建出处理这一连接的回路的过程。<br>回路建立后，需要一定量的资源去纠正并完善，并用新情况去验证。</p><p>记忆</p><p>能理解的概念越基层，回路越复杂，同一概念链接的具体事物种类越多，记忆能力越强大。</p><h3 id="5-意识"><a href="#5-意识" class="headerlink" title="5.意识"></a>5.意识</h3><p>具有明显倾向性的依赖于物质结构的局限思维。</p><p>Features-</p><p>对信息的处理关联事态的其他特征。</p><p>综合的可能性引导行为的正常进行。</p><p>二维信息可以与一维信息双向演绎。</p><p>无法改变已有信息，只可记录，加工，储存，传递已有信息。</p><p>个体意识是整体意识的表现之一。</p><p>Examples-</p><p>“个性”，“爱好”，“情绪”</p><p>Relations-</p><p>对事件发展有重要影响。</p><h3 id="6-衍影"><a href="#6-衍影" class="headerlink" title="6.衍影"></a>6.衍影</h3><p>高维物质在低维思维中的投影。</p><p>Functions-</p><p>世界由事件构成。</p><p>Features-</p><p>具有相同衍影的思维体有以下特征：</p><p>1.这些思维体遵守同一观测规律。</p><p>2.这些思维体所能观测到的事件相同。</p><p>3.这些思维体彼此可见，且处于同一维度。</p><p>4.衍影的形成是被观测和发生交涉的基础，衍影的破裂意味着思维体不再发生有效映射。</p><p>5.同一时空内思维体衍影时刻改变，但与其他可相互观测思维体衍影方式和解码方式相同。</p><p>Examples-</p><p>改变的主要方式有：增加衍影，修改衍影，破裂衍影。</p><p>增加衍影可通过获取知识，培养兴趣等途径实现，结果为大幅度改变自身思维构建，明显影响思维体的行为特征；</p><p>修改衍影可通过自我辩驳，增加阅历等途径实现，结果为缓和地改变自身思维构建，逐渐改变思维体的行为特征；</p><p>破裂衍影可通过损毁意识，强制遗忘等途径实现，结果为突然地改变自身思维构建，大幅改变思维体的行为特征。</p><p>衍影破裂的同时，思维体并不会立刻消失（受低维反馈影响），而是继续以高维形式存在。</p><p>Relations-</p><p>能被思维体直接观测到的宏观物质的形态信息。</p><p>只有衍影方式和解码方式完全相同的对象才可相互观测。</p><p>Additions-</p><p>交涉</p><p>能够扩大衍影发生超控的程度，增加其发生映射的发生率与稳定性。</p><p>交涉的前提在于直接观测，间接观测包含文字，影像等形式。</p><p>联系</p><p>多维组成，负责传递信息(即思维)，连接物质(即时间)，取代意识。</p><h3 id="7-思维体"><a href="#7-思维体" class="headerlink" title="7.思维体"></a>7.思维体</h3><p>行为特征具有明显发生率性的物质组成。</p><p>Features-</p><p>思维体的行为在不同时间，空间下有较大差异。</p><p>思维体时空的限度在于能被感知的限度。</p><p>非思维体的物质在多空间超控，本身不产生时空。</p><p>Examples-</p><p>“人”，“蚁群”，“语言模型”</p><p>Relations-</p><p>思维体是衍影关于时间的积累。</p><p>Additions-</p><p>行为</p><p>指与自然发展方向相冲突的物质活动。</p><h3 id="8-时间"><a href="#8-时间" class="headerlink" title="8.时间"></a>8.时间</h3><p>量能的定向流动。</p><p>Functions-</p><p>时间使物体在不同空间中能连续性地转接，进而保持物体不与物体自身发生冲突。</p><p>Tips-</p><p>转接并不是简单转移，而是将不同空间内具有近乎相同衍影的物体相连。即不同空间为不同的“切片”，时间负责把有合理联系的切片串联起来。</p><p>当事件具有某一确定属性时，这种由可能性到确定属性的转变，就是时间流动的定向过程。这也意味着在属性确定前，存在多条指向不同属性的时间线，而非一簇将要同时包含不同属性的时间环。</p><p>Features-</p><p>存在稳定时间的前提是一定区域内拥有稳定的维度差异，即能发生稳定的量能流动。</p><p>Additions-</p><p>类同取代</p><p>多个对象在形态上相同，逻辑上承接，空间上互斥，时间上继起，是一种与时间取代高度相似，但本质不同的取代方式。</p><h3 id="9-观测-超控"><a href="#9-观测-超控" class="headerlink" title="9.观测&#x2F;超控"></a>9.观测&#x2F;超控</h3><p>观测特指某一时空内的对象可以被单思维体观测。</p><p>超控即该对象的衍影可稳定映射在多个非主时空中。</p><p>Features-</p><p>观测是超控的前提。</p><p>思维体与思维体的交涉本质在于超控衍影在不同思维体空间内表达。</p><p>Examples-</p><p>没有发生超控的对象仅在思维体空间内可见。</p><p>如1 2 2 3的梦境服务器中的对象，在其他空间内不可见。</p><h3 id="10-1基础维度"><a href="#10-1基础维度" class="headerlink" title="10.1基础维度"></a>10.1基础维度</h3><p>对量能的等级划分；按照不同的本质特征把思维及其关系划分成多个层次。</p><p>Features-</p><p>设想我们作为三维体存在于四维空间。</p><p>Examples-</p><h4 id="1-空间维度"><a href="#1-空间维度" class="headerlink" title="1.空间维度"></a>1.空间维度</h4><p>零维：引力，以及不发生映射的维度。</p><p>一维：声音信息等低等不具备直观外界形态信息，量元直接组成的维度。</p><p>二维：图像信息等可能可见的高等信息，组成衍影的最低维度。</p><p>三维：思维体的最低维度。</p><p>四维：能够产生超控映射的最低维度，即能产生物质的最低维度。</p><p>五维*：时空逻辑能够发生突变的最低维度。</p><p>六维*：全能首维，包含所有的时空交涉。</p><p>七维及以上和六维相同，但符合高维观测低维的规律。</p><h4 id="2-生物维度"><a href="#2-生物维度" class="headerlink" title="2.生物维度"></a>2.生物维度</h4><p>二维：二维及以下不存在任何生物。</p><p>三维：外观形态能够因其行为而改变，是能产生思维的最低维度。</p><p>四维：能单向观测自身已发生时间点事态的最低维。</p><p>Tips：即意识能回顾过去发生的所有细节。</p><p>五维*：能够单向观测平行时空的最低维。</p><p>Tips：即意识能精准模拟不同选择带来的结果。</p><p>六维*：能够与平行时空产生物质交换的最低维。</p><p>Tips：即意识能在不同选择间互换。</p><p>七维*：七维及以上与六维相同，但符合高维观测低维的规律。</p><h4 id="3-三维思维体在特定时空维度的交涉特征："><a href="#3-三维思维体在特定时空维度的交涉特征：" class="headerlink" title="3.三维思维体在特定时空维度的交涉特征："></a>3.三维思维体在特定时空维度的交涉特征：</h4><p>三维：思维体所能“创造”的最高时空维度。</p><p>四维：承载思维体的最低时空维度。</p><p>Tips：该维度具有时间效应：即同时间点下一定空间内不存在多个高度相似的思维体。</p><h4 id="4-三维思维体向不同时空维度观测时的特征："><a href="#4-三维思维体向不同时空维度观测时的特征：" class="headerlink" title="4.三维思维体向不同时空维度观测时的特征："></a>4.三维思维体向不同时空维度观测时的特征：</h4><p>零维：无法直接观测。</p><p>一维：能间接获得其包含的信息的维度。</p><p>二维：能直接观测的最低维度。</p><h4 id="5-不同维度对应的思维体可能存在的交涉特征："><a href="#5-不同维度对应的思维体可能存在的交涉特征：" class="headerlink" title="5.不同维度对应的思维体可能存在的交涉特征："></a>5.不同维度对应的思维体可能存在的交涉特征：</h4><p>五维*：思维体能够以物质形态跳跃至未来时间点，并不与自身相冲突的最低时空维度。同时是思维体意识能取代过去意识的最低维度。</p><p>六维*：能够以物质形态存在于当前时空任何时间点的最低维度。</p><p>七维*：能够对平行时空的自身进行意识交换的最低维度。</p><p>八维*：能够对平行时空的自身进行物质交换的最低维度。</p><p>九维*：能够对平行时空的自身进行意识交涉的最低维度。</p><p>十维*：能够对平行时空的自身进行物质交涉的最低维度。</p><p>十一维*：不稳定的时空维度。难以交涉。</p><h3 id="10-2编码维度-影像维度-映射维度-时间维度"><a href="#10-2编码维度-影像维度-映射维度-时间维度" class="headerlink" title="10.2编码维度&#x2F;影像维度&#x2F;映射维度&#x2F;时间维度"></a>10.2编码维度&#x2F;影像维度&#x2F;映射维度&#x2F;时间维度</h3><p>编码维度是构成各类信息的基础维度，通常为一维。</p><p>影像维度是能被思维体直接观测的维度。</p><p>映射维度是物体本身的维度。</p><p>时间维度为时空的最高维度。</p><p>Features-</p><p>映射维度到影像维度称为衍影。</p><p>影像维度到映射维度称为解码。</p><p>编码维度＜影像维度，影像维度≤映射维度，映射维度≤时间维度。</p><p>Examples-</p><p>三维对象A观测到三维对象B：</p><p>三维对象B产生的二维衍影被A观测到后，A将该衍影解码为三维状态。</p><p>投射到自身思维所参与构建的时空中。</p><p>Additions-</p><p>稳定指数</p><p>能够扩大衍影发生超控的程度，增加其发生映射的发生率与稳定性。</p><p>Features-</p><p>稳定指数&#x3D;编码维度+影像维度+映射维度-时间维度。</p><p>Examples-</p><p>①若影像维度小于映射维度，则最高维度＞＝映射维度；若影像维度＝映射维度，则最高维度＞影像维度。</p><p>Tips：物体映射维度＝时空最高维度时， 物体空间与时空空间为平行空间关系，即相互观测。物质的影像维度比映射维度更易改变。</p><p>②具二维衍影的三维生物在四维时空的数值分别为1 2 3 4。四维空间的三维生物的灵体数值为 1 3 3 4。灵体，即不能相互观测却能够相互交涉的独特思维体。</p><p>③1＜指数≤2的对象可稳定存在，称为几何态，指数≤1或＞2的对象不能稳定存在，称为电磁态。</p><p>Tips：如具二维衍影的三维生物在四维时空的总指数：6-4＝2，故其以几何生命形式存在。具二维衍影的三维生物在五维空间指数为1，即不能在五维时空有几何形态。同时，由于超控下时间维度＞映射维度，所以具二维衍影的三维生物不能在三维空间内被直接观测到。三维体的梦境对象指数为1 2 2 3。</p><hr><h2 id="Part2：Four-basic-characteristics"><a href="#Part2：Four-basic-characteristics" class="headerlink" title="Part2：Four basic characteristics"></a>Part2：Four basic characteristics</h2><h3 id="1-映射高维引发影像低维，影像高维形成映射低维。【规律性】"><a href="#1-映射高维引发影像低维，影像高维形成映射低维。【规律性】" class="headerlink" title="1.映射高维引发影像低维，影像高维形成映射低维。【规律性】"></a>1.映射高维引发影像低维，影像高维形成映射低维。【规律性】</h3><p>Descriptions-</p><p>高维物质能在低维时空引发意识，高维思维能在低维时空形成物质，思维和意识不能产生同维度的物质。物质能引发不直接与外界交互的意识活动，意识活动可通过物质活动即思维与外界交互。意识不能独立存在，意识依赖于物质但来源于高于物质本身的特定思维组成，即构建时空的规则逻辑。物质在引发意识时充当筛选作用，使对象仅表达出符合构建逻辑的活动。低维信息能以某种形式传达给更高的维度。维度越低的反馈越易受到思维体意识的影响， 从而发生映射偏差。</p><h3 id="2-观测决定物质状态：所有发生率全部且同时发生，单一观测仅表达一种结果。【发展性】"><a href="#2-观测决定物质状态：所有发生率全部且同时发生，单一观测仅表达一种结果。【发展性】" class="headerlink" title="2.观测决定物质状态：所有发生率全部且同时发生，单一观测仅表达一种结果。【发展性】"></a>2.观测决定物质状态：所有发生率全部且同时发生，单一观测仅表达一种结果。【发展性】</h3><p>Descriptions-</p><p>任何物质在被观测前，其属性是未确定的。观测者对物质进行的观测能够使得物质的状态唯一。这种唯一不是物质的自身属性，因为本时空观点认为所有的发生率全部且同时发生，即物质本身是均衡的，但是观测者对某一属性的特定接收决定了物质表现出的唯一状态。观测者所有可观测的对象对该物质的观测结果相同。若有两个独立的时空，一仅有两种可能性的对象分别对两个时空映射，若在一个时空观测到一种可能性，另一时空必定为另一种可能性。若上述两个时空相互映射，其可能性无法观测。 扩展至若干时空且对象的可能性无穷增加，则具有相同可能性的时空才可相互叠加与映射。</p><h3 id="3-物质是否存在，与可交涉对象能否与物质交涉相关。【存在性】"><a href="#3-物质是否存在，与可交涉对象能否与物质交涉相关。【存在性】" class="headerlink" title="3.物质是否存在，与可交涉对象能否与物质交涉相关。【存在性】"></a>3.物质是否存在，与可交涉对象能否与物质交涉相关。【存在性】</h3><p>Descriptions-</p><p>物质是否存在不依赖于观测者自身是否与其进行过交涉。只要观测者可交涉的对象能够与物质发生交涉，物质便确实存在，否则不可确定其存在性。即只要有对象传递过未违背原物质性质的相关信息且被观测者接收，该物质便确实存在。被观测对象是否为思维体，依赖于观测者时空内该对象映射能力的强弱和其本身是否为思维体。</p><p>Examples-</p><p>梦境时空来自于思维体的思维构建，而思维体的思维来源于包含其的时空。即时空中的物质映射到思维体时空后，通过意识的过滤进一步映射到梦境，因而梦境中的物质只具有现实中的部分特质。但发生偏差映射的原因是思维体的意识对物质的表达形式造成干扰，而非来自物质本身的稳定性遭到破坏。因此梦境中与现实有相似之处的方面视为物质。</p><h3 id="4-不同思维体的思维所组成的同维度空间相互叠加构成稳定空间体，使外界规律更难随个人思维活动的变化而变化。【稳定性】"><a href="#4-不同思维体的思维所组成的同维度空间相互叠加构成稳定空间体，使外界规律更难随个人思维活动的变化而变化。【稳定性】" class="headerlink" title="4.不同思维体的思维所组成的同维度空间相互叠加构成稳定空间体，使外界规律更难随个人思维活动的变化而变化。【稳定性】"></a>4.不同思维体的思维所组成的同维度空间相互叠加构成稳定空间体，使外界规律更难随个人思维活动的变化而变化。【稳定性】</h3><p>Descriptions-</p><p>不同思维体所在的总时空相对稳定的原因在于不同思维体的根本思维基本一致。同时，不同思维体的思维是可“互补”的，并且总体来看是“均衡”的。大范围的思维改变能够对外界环境有一定影响。思维体观测到的规律与思维体遵循的规律一致。</p><hr><h2 id="Part3：Some-construction-models"><a href="#Part3：Some-construction-models" class="headerlink" title="Part3：Some construction models"></a>Part3：Some construction models</h2><h3 id="1-量能假说【量能与表观联系】"><a href="#1-量能假说【量能与表观联系】" class="headerlink" title="1.量能假说【量能与表观联系】"></a>1.量能假说【量能与表观联系】</h3><p>Main idea-</p><p>时间势能&#x3D;第一空间能+表观思维能。</p><p>Structures-</p><p>时间势能：思维体不同状态间发生取代而需消耗的量能。</p><p>第一空间能（位移取代）：宏观物体因物质冲突或在一段时间内因空间位置不同而具备的量能。</p><p>表观思维能（稳定性取代）：不同量元因冲突而具有的量能，与不同思维冲突所具有的量能（包含对象的［稳定存在性］与时空相冲突而具有的量能）和。</p><p>Descriptions-</p><p>时间势能优先流向第一空间能。</p><p>时间势能随时间流动逐渐增大，并优先流向更低量能的思维体。</p><p>时间势能越大，相同外界时间内转移的量能越大，感知时间流速越快。</p><p>当位移极小时，时间势能完全用于填补表观思维能，感知时间流速加快。</p><p>稳定存在性，即个体能保持自身形态在短时间内不发生剧烈变化的能力。</p><p>取代的本质为量能流动，对象的量能越近，越易发生取代。</p><p>思维体量能低于构成其的思维的量能，但高于其产生意识量能。</p><p>取代增能，冲突产能。冲突产能多于意识耗能。</p><h3 id="2-能维假说【量能与维度联系】"><a href="#2-能维假说【量能与维度联系】" class="headerlink" title="2.能维假说【量能与维度联系】"></a>2.能维假说【量能与维度联系】</h3><p>Main idea-</p><p>量能和维度能相互转化。</p><p>Descriptions-</p><p>物质的量能升高到某一限度时转化为维度，以防止量能过高而失去宏观稳定性。</p><p>量能低于某一限度时降低维度，保持物质相对稳定。</p><p>低维度高能体能在低维度存在，而高维度低能体不能在低维度存在。</p><h3 id="3-稳定时空广义准则【时空稳定性】"><a href="#3-稳定时空广义准则【时空稳定性】" class="headerlink" title="3.稳定时空广义准则【时空稳定性】"></a>3.稳定时空广义准则【时空稳定性】</h3><p>Main idea-</p><p>稳定的时空所具备的特性。</p><p>Descriptions-</p><p>所有可观测对象传递的信息随观测方式的改变而改变。</p><p>所有可观测对象的自身性质不受观测顺序和次数影响。</p><p>所有观测者观测自身的结果与他者观测自身的结果一致。</p><p>任何已存在事物都可以是可知的且存在对立面。</p><p>对象的不同性质可单独出现也能同时出现。</p><p>外界逻辑与观测者自身状态无关。</p><p>对同一观测者而言唯一时间点对应唯一观测者。</p><p>不同观测者之间的存在性互不影响。</p><p>应当存在永恒不变的对象。</p><p>任何可观测对象均可被观测。</p><p>万物同源，变化连续，无中生有，有不归无。</p><p>Tips-</p><p>非稳定时空特征</p><p>存在可观测对象传递的信息不随观测方式的改变而改变。</p><p>存在可观测对象的自身性质受观测顺序和次数影响。</p><p>观测者观测自身的结果与他者观测自身的结果未必一致。</p><p>存在已知的是“未知”的事物或单独出现。</p><p>存在对象的不同性质仅能同时出现。</p><p>外界逻辑与观测者自身状态有关。</p><p>不同观测者之间的存在性可互相影响。</p><p>不存在永恒不变的对象。</p><p>万物同源，变化跳跃，无中生有，有中归无。</p><h3 id="4-服务器理论【时空创生性】"><a href="#4-服务器理论【时空创生性】" class="headerlink" title="4.服务器理论【时空创生性】"></a>4.服务器理论【时空创生性】</h3><p>Main idea-</p><p>服务器时空具备不同种类时空的部分特征。</p><p>Descriptions-</p><p>对特定时空进行信息处理，能避免时空发生映射的同时，使一类特定时空具备高度相似的特征和紧密联系。特定时空的维度不高于服务器所存在的时空维度。</p><p>Examples-</p><p>假设思维体的物质组成是三维。</p><p>若思维体作为“服务器”，那么其梦境时空可是三维：</p><p>这种梦境时空中二维的“物质”能被观测（产生二维衍影），表现为仿现实。</p><p>若思维体不作为“服务器”，那么其梦境时空是二维：</p><p>这种梦境时空中一维的对象无法被直接观测（未产生衍影），表现为无法被思维体直观感受到的纯意识。</p><p>前者梦境时空无法与其它时空相互映射，因而不具备稳定性。</p><p>后者梦境时空能与其它时空发生映射，因而具备稳定性：其可被持续稳定地包含在前者时空中，能在前者时空破裂时，将前者时空映射下来的一维信息较稳定地映射到思维体主时空，并且这种信息能被“解码”为二维衍影。</p><h3 id="5-时空演替【时空发展性】"><a href="#5-时空演替【时空发展性】" class="headerlink" title="5.时空演替【时空发展性】"></a>5.时空演替【时空发展性】</h3><p>Main idea-</p><p>演替分为本原演替和初生演替。</p><p>Structures-</p><p>本原演替指思维体的意识对事态发展进行具有一定逻辑性的推演。</p><p>初生演替指在外界诱导下，思维体进行的思维活动。</p><p>Descriptions-</p><p>本原演替会与被演替的对象相冲突，并受到时空法则的制约。</p><p>初生演替是受到时空规律的限制，符合客观变化规律的演替。</p><p>本原演替为时空的演替创造一定的基础，即影响思维体的可能行为。</p><p>初生演替对其进行选择，即使其按照合理的方向发展。</p><h3 id="6-时间假说【时间相关】"><a href="#6-时间假说【时间相关】" class="headerlink" title="6.时间假说【时间相关】"></a>6.时间假说【时间相关】</h3><p>Main idea-</p><p>时间是量能的流动。</p><p>Descriptions-</p><p>时间保证一定时间内同一空间中思维体唯一的同时，使得连续空间内同一思维体间可以转接而不发生交涉。</p><p>不同思维间发生强烈的冲突时，主时空会相应地引发量能导致个体时空时间流速增快。时间流速越快，时空越不稳定，即时空逻辑性减弱。</p><p>而时间流速达到一定程度时，时空会被破坏，从而不与其他时空发生映射。同维度的物质能发生碰撞，正是为了避免强烈的冲突。</p><p>对象拥有意识能力，正是由于其时空与所在主时空流速不一致。</p><p>思维体思维能力越强，冲突获得的量能越高，总时空流向其他个体量能增多，因而个体空间的时间间隔增加，表现为自身空间取代加快。</p><p>个体运动速度越快，时间作用效果越弱，个体延续加快，自身空间取代减慢。</p><h3 id="7-起源假说【起源相关】"><a href="#7-起源假说【起源相关】" class="headerlink" title="7.起源假说【起源相关】"></a>7.起源假说【起源相关】</h3><p>Main idea-</p><p>万物起源于发生率。</p><p>Descriptions-</p><p>发生率的差异引起一定区域内空间叠加次数不同，进而引发量能的不均。</p><p>这种不均引起量能流动（时间），进而产生不发生超控的低级思维，加剧这种量能不均。</p><p>不同思维相互冲突，直到筛选出较强大的超控思维。这种思维与其他思维相冲突但能保持自身稳定，即稳定时空产生。</p><p>稳定时空的产生会形成一定的规则。</p><p>Tips-</p><p>时空各部分发生叠加的发生率相同（均衡性），但各部分的叠加结果会因观测方式的独立性，而使得子时空内叠加发生率不同。</p><p>量能的流动总体处于动态平衡当中，但观测方式的不同使得量能流动情况分立。</p><p>思维的本质是量能流动，世界的形成来自思维的冲突与积累。</p><h3 id="8-记忆驱动【意识相关】"><a href="#8-记忆驱动【意识相关】" class="headerlink" title="8.记忆驱动【意识相关】"></a>8.记忆驱动【意识相关】</h3><p>Main idea-</p><p>外界因素融入记忆后对思维体行为具有影响。</p><p>Structures-</p><p>主要对象有信息，社会，自然，自身，集体，影像，梦境。</p><p>Descriptions-</p><p>1.记忆能使思维体在相似环境中的运动呈现相似状况。</p><p>2.记忆能一定程度上预演出相似环境的运动结果。</p><p>3.记忆能在相似环境下使思维体产生特定神经冲动。</p><p>4.记忆能使不同集体的相似行为趋于一致。</p><p>5.记忆能使思维体活动呈现一定的周期性。</p><p>6.其它思维体的记忆能通过时空思维影响有相似认知的个体。</p><h3 id="9-事件拓补原则【事件相关】"><a href="#9-事件拓补原则【事件相关】" class="headerlink" title="9.事件拓补原则【事件相关】"></a>9.事件拓补原则【事件相关】</h3><p>Main idea-</p><p>事态发展遵循一定的原则。</p><p>Descriptions-</p><p>1.参与对象的思维分歧与外界规律约束使事件进行具有逻辑性的发展。</p><p>2.外界规律起主导作用，参与对象的思维只能对其进行选择。</p><p>3.主时空进行的本原演替作为时空法则约束其他演替，并诱导进行初生演替。</p><h3 id="10-定点融合方式【联系相关】"><a href="#10-定点融合方式【联系相关】" class="headerlink" title="10.定点融合方式【联系相关】"></a>10.定点融合方式【联系相关】</h3><p>Main idea-</p><p>事件发展有一定的方式。</p><p>Structures-</p><p>1.升变：通过一定的量能使某种量元组合方式转变为另一种组合方式。</p><p>改变一般性质的方式，体现为发展，回溯，融合，分离。</p><p>2.交替：通过与自身交涉而引起可能性分歧但性质不变的方式。</p><p>自然存在，是产生平行时空或等价变换的方式。</p><p>3.转化：通过弱化某些不可直接利用特性而获取另一种不稳定的可利用特性。</p><p>实现过程复杂且性质明显改变的方式。</p><p>4.重组：通过剧烈量能使得部分量元重新组合。</p><p>大幅度改变各种性质的方式。</p><p>5.演替：</p><p>本原演替：由思维推算出的变化过程。</p><p>初生演替：由外界所导向的变化过程。</p><p>6.输送：通过一定的外界控制，转移量能。</p><p>7.协态:基于特定属性，按照一定的联系表达另一种属性。</p><h3 id="12-时空间的关系【时空相关】"><a href="#12-时空间的关系【时空相关】" class="headerlink" title="12.时空间的关系【时空相关】"></a>12.时空间的关系【时空相关】</h3><p>Main idea-</p><p>时空间具有四种基本关系。</p><p>Structures-</p><p>1.平行</p><p>不同的可能性产生相对应的不同主时空，这些主时空共同构成平行时空。</p><p>单一时间轴上不同的时空之间也为平行关系。</p><p>2.纠缠</p><p>不同时空的部分组成高度相似时，该部分进行即将重合与不断排斥之间的交替。</p><p>处于强纠缠时空下的物体同时具有多个不同的衍影，能同时被不同的时空的对象观测到。</p><p>而处于弱纠缠时空下的物体，会受到其他时空部分信息的影响，其中思维体的意识会受到影响。</p><p>当某一衍影发生解码时，另一衍影也同时发生解码。纠缠时空因不断激化矛盾导致时空量能增加快，最后导致平行关系转化为重合关系。</p><p>时空纠缠存在断裂点，断裂点能够阻隔特定事件的发生。</p><p>3.重合</p><p>不同思维体产生的时空，若可相互映射，则这些时空重合构成更为稳定的时空。</p><p>重合是上述两种情况的基础。空间重合不可传递。</p><p>Tips-</p><p>事件A有五种可能性，事件B有两种可能性。相互映射时，共有十种平行时空，即A的五种与B的两种分别重合，但不同重合方式为平行关系。若重合时空受外界影响导致可能性分歧，则转化为平行空间。若上述平行关系受到外界影响导致分歧无法产生，则转为重合关系。</p><p>4.相交</p><p>若多个时空中产生巨大量能并使双方衍影朝对方衍影改变，则为相交时空。相交时空可能性发生替换，即同一时空相交前后所超控的对象特征不同。</p><hr><h2 id="Part4：Some-specific-structures"><a href="#Part4：Some-specific-structures" class="headerlink" title="Part4：Some specific structures"></a>Part4：Some specific structures</h2><h3 id="1-时空类别"><a href="#1-时空类别" class="headerlink" title="1.时空类别"></a>1.时空类别</h3><p>Structures-</p><p>R时空束-平行时空</p><p>产生方式：可能性分歧</p><p>时空特征：同源而生，即部分事件的开端完全重合。</p><p>A时空-思维体思维构建的时空</p><p>产生方式：有某种相似特征的思维结合。</p><p>时空特征：思维体构建的时空先映射到主时空，再映射到其他思维体的时空。</p><p>B时空-主时空</p><p>产生方式：相似的时空相互映射后，构成的能够体现出统一规律的集合。</p><p>时空特征：有一定的规律。</p><h3 id="2-意识弧的形成与功能"><a href="#2-意识弧的形成与功能" class="headerlink" title="2.意识弧的形成与功能"></a>2.意识弧的形成与功能</h3><p>Descriptions-</p><p>1.意识形成过程为：刺激，记录，处理，合成，再处理。</p><p>2.应激反应包含：先天性行为，部分后天机械化行为。</p><p>3.一级记忆：即衍影信息，解码前不能被思维体识别。 包含简单感受和心理。</p><p>4.本态思维：无意识调节的思维，其可形成或强化应激反应。</p><p>5.本态思维呈现给器官的信息不受意识干扰。</p><p>6.行为思维受意识调节，依赖于外界环境和相似机体行为，由意识决定传递信息的方式。</p><p>7.意识能分析一级记忆，从而获取复杂心理，经验，调控状态等。</p><p>8.被分析的一级记忆和形成的本态思维构成二级记忆。</p><p>9.二级记忆能被思维体直接分析，称为“回忆*”。</p><p>10.回忆使思维体意识到自身的存在，即产生自我意识。认知塑造自我概念，而非自我拥有认知能力。</p><p>11.二级记忆能模拟刺激，从而使思维体提前兴奋或远离危险。</p><p>12.大量相似记忆的产生会导致新产生的部分差异模糊化，导致自我意识不包含新的特征。记忆可以加速处理相似记忆时的记录过程。<br><img src="/pictures/yishihu.png" alt="意识弧"></p><p>*回忆之所以为第三视角，是因为感官强化自身状态这一信息后，录入了记忆中。这可由回忆现实和回忆梦境时的视角的差异得出；同时，记忆决定自我概念，而不是思维活动决定自我概念的重要依据是“梦境溃散时观测转换为第三视角”。若是思维活动决定自我意识，则梦境溃散时不会观测到和回忆现实相似的第三视角：这是因为梦境即将结束时，感官被完整激活，自身状态的信息得到进一步强化。</p><h3 id="3-时空间关系表示"><a href="#3-时空间关系表示" class="headerlink" title="3.时空间关系表示"></a>3.时空间关系表示</h3><p>Descriptions-</p><p>A：该时空内不同思维体的部分可能性交换，之后转化为平行时空内的思维体。1，2线上外界观测为同一对象。</p><p>B：平行时空内相近思维体的部分可能性交换，之后融合为同一思维体。1，2线上外界观测为同一对象。</p><p>C：某思维体被外界观测时，能产生多种不同的特征。且这多种状态能同时被1线同观测。</p><p>D：思维体能在1线观测到2线所连接的时间点的状态，但不能被2线所连接的时间点观测。3线观测1线时，2线结束，思维体从1线连回主时空。3线观测2线时，1线结束，思维体从2线连回主时空。</p><p>其中1线为纠缠态，不进行发生率分歧。<br><img src="/pictures/shikongjian.png" alt="时空间的关系1"><br>E:X思维体先为1可能性，Y思维体先为2可能性。纠缠状态启动并且外界对纠缠态观测时，X（1）转化为Y（1）并在2时间点，Y（2）转化为X（2）并在1时间点。由于X（1）与Y（1）冲突，所以X（1）线消失。此时Y（1）与X（2）为重合关系。</p><p><img src="/pictures/shikongjian2.png" alt="时空间的关系2"></p><h3 id="4：思维和意识活动"><a href="#4：思维和意识活动" class="headerlink" title="4：思维和意识活动"></a>4：思维和意识活动</h3><p>总流程：获取（刺激），记载，编码，留存，检索，解码，映射，处理。思维体由生命、记忆、运算三核心模块、内外物质构成所组成，并能够实现成像和传递功能。</p><h4 id="Descriptions1"><a href="#Descriptions1" class="headerlink" title="Descriptions1-"></a>Descriptions1-</h4><p>【1】为信息转化元，处理外界和内部刺激并形成多线。思维体有多种信息转化方式。</p><p>【2】为思维体可观测形态和活动。同一时空内，外在状态由多个有共性的局部状态构成。</p><p>【3】为解码元，解析信息和指令，协助构成外在形态和进行思维活动并反馈信息。</p><p>【4】为时间优先级处理元，判断并优先传递正在并首次接收的信息给解码元。</p><p>【5】为意识核，形成解析信息的倾向并封装信息，能主动模拟活动信息，即思考能力。</p><p>【6】为超控因子，实现思维体在重合的多时空内发生稳定映射。</p><p>【7】为时空规则限制元，实现思维体的任意状态或活动遵守一定的规律。</p><p>思维体有许多不同的形态单元，他们共同构成思维体的形态和协助整体进行思维活动。封装信息意味着产生有相联关系的但不属于同一记载单元的多线。此外，三种单元均具有自我复制和销毁的能力，本质上是量元表观能力的内在划分，而非实际存在的功能。</p><p><img src="/pictures/xingtai.png" alt="形态单元"></p><h4 id="Descriptions2"><a href="#Descriptions2" class="headerlink" title="Descriptions2-"></a>Descriptions2-</h4><p>【1】为接收元，接收来自“记载单元”的信息。</p><p>【2】为输送元，输送信息至“形态单元-接收”。</p><p>【3】为效应激活，激活记忆输送这一过程。</p><p>记忆单元构造基本稳定且相同。记忆单元的数量，输送能力和敏锐程度即记忆&#x2F;回忆能力。</p><p><img src="/pictures/jiyi.png" alt="记忆单元"></p><h4 id="Descriptions3"><a href="#Descriptions3" class="headerlink" title="Descriptions3-"></a>Descriptions3-</h4><p>【1】为原始线，记载形态等直接观测信息。</p><p>【2】为补充线，记载心理等来自意识核的信息。该线可不存在刻录信息。</p><p>【3】为限制线，记载时间顺序及限制4的释放。并能够激活“记忆单元-效应激活”一次。</p><p>【4】为记录线，1，2，3刻录信息到4后，进一步传递信息至“记忆单元-接收元”。</p><p>自然状态下四线不断重复结合，分离的过程。1，2，3发挥作用后自我销毁并恢复至原始状态，4线保留并不断传递信息。信息可被消耗和磨损。</p><p><img src="/pictures/jizai.png" alt="记载单元"> </p></div>]]></content>
      
      
      <categories>
          
          <category> 世界之核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SCHNIE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自然-神系</title>
      <link href="/posts/3.html"/>
      <url>/posts/3.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><script>    (function(d, w, c) {        w.ChatraID = 'D5JbrYK4vHavdTNTf';        var s = d.createElement('script');        w[c] = w[c] || function() {            (w[c].q = w[c].q || []).push(arguments);        };        s.async = true;        s.src = 'https://call.chatra.io/chatra.js';        if (d.head) d.head.appendChild(s);    })(document, window, 'Chatra');</script><h1 id="Two-第九边缘关于自然的一个判断"><a href="#Two-第九边缘关于自然的一个判断" class="headerlink" title="Two:第九边缘关于自然的一个判断"></a>Two:第九边缘关于自然的一个判断</h1><p>Nurture will create a whole world 自然包含整个世界的所有答案</p><p>本文主要介绍了第九边缘下的自然观：第九边缘认为世界上所有对象由十二种元素构成。它们分别是：金木水火土阴阳雷草风光冰。</p><hr><h2 id="一、前注"><a href="#一、前注" class="headerlink" title="一、前注"></a>一、前注</h2><p>由于木元素在该论述中能表示信仰，故我们将五行分布凸显为木正位（按金水木火土依次连接，使木元素处于图案最上方且与相邻元素组成的角度最大。同时，需保证将图案最上部分向下翻转后，与规范的五行相生相克表一致）。并以风土水火元素为框架，按照克制关系和协和关系，制表如下：</p><p><img src="/pictures/ziran.png" alt="自然观"></p><p><code>说明：相同编号为相和，对线元素为对立。相和即在自然界中能够和谐共存，对立即在自然界中难以同时存在，但能够在特定条件下存在。</code></p><p>按元素的作用，我们将这些元素分为三类：分别是形：客观存在的形态；律：客观运转的规律；法：应对客观的方法。按元素的类型，我们分为四类：分别是阴：融入；阳：排斥；虚：分散；实：汇聚。并分别选取阴元素，阳元素，光元素，冰元素作为代表。下面进行详细介绍。</p><hr><h2 id="二、总述"><a href="#二、总述" class="headerlink" title="二、总述"></a>二、总述</h2><h3 id="（一）-自然哲法"><a href="#（一）-自然哲法" class="headerlink" title="（一）.自然哲法"></a>（一）.自然哲法</h3><p>自然哲法指出各元素的类别及对我们的核心要求。即：<br>以五者联外物：明金之法则，持木之信仰，悟水之联觉，立火之契约，存土之方位。<br>依三方修内心：精雷之瞬变，同草之随形，觉风之乘势。<br>通阴阳之道：知阴之相融，会阳之相斥。<br>控虚实之方：予冰之凝虚，结光之破实。</p><h3 id="（二）-自然自意"><a href="#（二）-自然自意" class="headerlink" title="（二）.自然自意"></a>（二）.自然自意</h3><p>自然自意指出各元素的根本性质。即：无形融入谓之阴，有形相斥谓之阳。随异而动谓之草，坚守自适谓之木。瞬息万变谓之雷，长存不变谓之金。化异为等谓之火，承纳万物谓之水。因势顺起谓之风，持久沉聚谓之土。化实为虚谓之光，凝虚为实谓之冰。</p><hr><h2 id="三、神束"><a href="#三、神束" class="headerlink" title="三、神束"></a>三、神束</h2><p>按照元素之间的相似程度，我们将其分为不同“束”。下面我们将具体分析这些元素的核心代表及主要体现等。</p><h3 id="（一）-五行神束"><a href="#（一）-五行神束" class="headerlink" title="（一）.五行神束"></a>（一）.五行神束</h3><p>五行神束包含对传统五行的第九边缘解释。其中【五行方位】指出该元素在五行关系中代表的含义。</p><h4 id="恒常-金【正行·逆运】"><a href="#恒常-金【正行·逆运】" class="headerlink" title="恒常-金【正行·逆运】"></a>恒常-金【正行·逆运】</h4><p>神束方位：【实形】【施予规则约束】【更替交叠之形】<br>五行方位：【天理】<br>主控方位：【凝聚】【消亡】<br>代号&#x2F;天星：【祈泽】<br>星象：【长存不变】<br>神名：【Quadra’heories】<br>释义：<br>三元起，四象之秘。以世界之语，规范行为。<br>司控<br>恒常（正逆&#x2F;核心代表）：普遍的规律，稳定的真理。参照“化学性质”<br>所谓真理，即创造、记录、感知构建出空泛、异动、融合、连接、繁荣、持续、消散。<br>凝聚（正行&#x2F;主要体现）：特质按规则汇聚[相和的特质]于一体。参照“矿物聚集”<br>祂并不会主动出现在我们的生活中，但祂一旦出现，就能够给我们带来绝对可用的财富。<br>消亡（逆运&#x2F;主要体现）：特质按规则分散[汇聚的特质]于各方。参照“电子流动”<br>耐性是有上限的：当人们不再考虑天平的量度，将造成不可逆的极大破坏。<br>传承<br>代表五月：是时候走向规范了。<br>守护自然规律：最直观的天理。<br>守护理智：人类窃取的世界之语。<br>守护力量：刺穿规则之物。<br>守护气质：使臣服凝聚。<br>守护丰收：付出有更大的回响。<br>守护人类知识：虚构的，蕴含于确切可靠对象的，定向抽化的动态结果。<br>神谕<br>做一些对自然规律的验证，尤为科学实验。在这种情况下，我们更能感受到金之神的影响。<br>祈运<br>约束型人格：约束自己，遵循天理而非肆意。<br>五行交汇<br>正：土生金-引导生被动<br>土之基位，使特质向指定特质凝聚；<br>土之构造，使指定的系列特质消亡。<br>逆：火克金-主动克原态<br>火之集束分立不同的特质，拖消亡；<br>火之归统同化不同的特质，阻凝聚。</p><h4 id="联觉-水【微观·宏态】"><a href="#联觉-水【微观·宏态】" class="headerlink" title="联觉-水【微观·宏态】"></a>联觉-水【微观·宏态】</h4><p>神束方位：【阴形】【融入万态万物】【链接同类之形】<br>五行方位：【资质】<br>主控方位：【联系】【循和】<br>代号&#x2F;天星：【凌枫】<br>星象：【承纳万物】<br>神名：【Trigeranwaves】<br>释义：<br>一触即动，波纹扩散。<br>司控<br>联觉：贯通[多类信息]。参照“水流涌动”<br>外界的所有信息都会在水中迅速传递。但它们如波纹般，只有细腻的人才能够区分。<br>联系：连接特质进而传递信息。参照“生命系统”<br>无论是强者还是弱者，一旦需要其他个体作为自身能力的外延，便会接纳水的渗透。<br>循和：调整特质继而实现循环。参照“水系生态”<br>连接过去与未来，让它们能够共存：交互将不同时空连为一个整体，虽然它的力量足以抵消时间的意义。<br>传承<br>代表十月：世界的信息是丰富的。<br>守护资质：不可多得的灵敏。<br>守护团结：相同的精神之核。<br>守护人脉：以网状覆盖世间。<br>守护思维：一种不断变化的信息。<br>神谕<br>倾听世界的无生命物的语言，非具体之语。在这种情况下，我们更能感受到水之神的影响。<br>祈运<br>掌握型人格：掌握万态，洞悉万物而非猜疑。<br>五行交汇<br>正：金生水-规律生架构<br>金之凝聚使特质连接，推进联系；<br>金之消亡使矛盾隐藏，达到循和。<br>逆：土克水-逻辑克感知<br>土之基位使状态稳定易观，舍弃联系；<br>土之构造使整体不断优化，冲击循和。<br>*架构：特质间交互而构建的基础性结构，参考“生态系统”。</p><h4 id="仰仗-木【内敛·外御】"><a href="#仰仗-木【内敛·外御】" class="headerlink" title="仰仗-木【内敛·外御】"></a>仰仗-木【内敛·外御】</h4><p>神束方位：【阳法】【漠视新生变化】【编织所识之法】<br>五行方位：【信仰】<br>主控方位：【环抵】【调适】<br>代号&#x2F;天星：【御临】<br>星象：【坚守自适】<br>神名：【Constabtructs】<br>释义：<br>为世界定下你的标签，作为旧世之树的枝条。<br>司控<br>仰仗：接收内外的信息。参照“吸取资源”<br>防御的力量将以降临的形式出现。外界的体系强加你，使你不被复杂的生活吞没，不被生物天性所腐蚀。<br>调适：扩展或舍弃局部状态。参照“根系生长”<br>对不可视世界有必要的关注：从对迷幻事物的信仰，到对真切规律的追求，因我们来源于此，而非外界。<br>环抵：积累旧信息后抵抗新变化。参照“抵抗风雨”<br>抵抗的下一步是以互斥的形式结合，而非完全排斥。或许这是消极的接纳，或者是精妙的吸收。<br>传承<br>代表二月：我们应该为前行做好准备。<br>守护信念：信念支撑着我们不断前行。<br>守护研究：新的发现应不断刷新理论。<br>守护模仿：模仿是极高效的适应方式。<br>神谕<br>承认并使用这个世界上已存在的概念，而不是独立地构造自己的世界体系。在这种情况下，我们更能感受到木之神的影响。<br>祈运<br>处理型人格：处理信息，应对真相而非逃避。<br>五行交汇<br>正：水生木-融洽生主观<br>水之联系使已有特质形成信息共体，产生环抵；<br>水之循和使相关的内外特质存交集，引发调适。<br>逆：金克木-运转克记录<br>金之消亡破坏整体，瓦解环抵；<br>金之凝聚抛弃异端，阻碍调适。</p><h4 id="契约-火【破坏·强化】"><a href="#契约-火【破坏·强化】" class="headerlink" title="契约-火【破坏·强化】"></a>契约-火【破坏·强化】</h4><p>神束方位：【阳法】【同化异象另态】【交换所需之法】<br>五行方位：【取舍】<br>主控方位：【集束】【归统】<br>代号&#x2F;天星：【契灵】<br>星象：【化异为等】<br>神名：【Equallequence】<br>释义：<br>平等地开始，平等地结束。<br>司控<br>契约：使一状态转变成另一等价状态。参照“钻木取火”<br>契约是有判断力的灵魂：契约的存立不依赖于主观意识，主观意识并不能改变契约条件。<br>集束：削弱特质之后使双方存在性同一。参照“冶炼金属”<br>没有人希望自己被带有集体色彩的低级手段戏弄；除非这是戏弄他人的最为轻易的手段。<br>归统：使不同的特质缩合为唯一的特质。参照“燃烧产物”<br>认知的闭锁来自于根源上的脆弱和愚蠢，思想的跳跃来自剽窃的人权和智慧。<br>传承<br>代表四月：付出行动，才能获得。<br>守护取舍：明白什么是你想要的。<br>守护利益：利益关系是契约关系的代表。<br>守护交换：契约的实现方式。<br>神谕<br>付出长久的改变，并且是有效的改变。在这种情况下，我们更能感受到火之神的影响。<br>祈运<br>主动型人格：主动出击，改变现状而非沉寂。<br>五行交汇<br>正：木生火-包容生平等<br>木之环抵使特质排斥中共存，发生集束；<br>木之调适使异常的状态显化，促成归统。<br>逆：水克火-安定克创造<br>水之循和使各方和谐相处，阻碍归统；<br>水之联系使不同信息隔离，减少集束。</p><h4 id="方位-土【沉积·渐进】"><a href="#方位-土【沉积·渐进】" class="headerlink" title="方位-土【沉积·渐进】"></a>方位-土【沉积·渐进】</h4><p>神束方位：【实形】【组建结构灵魂】【赋灵各方之形】<br>五行方位：【机缘】<br>主控方位：【基位】【策略】<br>代号&#x2F;基石：【丰箴】<br>星象：【持久沉聚】<br>神名：【Sequentiracleu】<br>释义：<br>各有其位，神谕赋魂。<br>司控<br>方位：稳定融合的动态与固定意义。参照“乡土情结”<br>我们自身便是神灵。赋予外物灵魂，以承载我们自身的灵魂。<br>策略：整合特质从而使全局有更佳的发展。参照“陶土工艺”<br>在这片土地上，涌现过太多对天理的拙劣模仿。或许我们只需要一种更直观的方式，去抵抗自身的腐败。<br>基位：使新生变化逐步稳定且有效的基石。参照“土壤养分”<br>赐予变化以身躯和能量，直到他们的生命被土地吸收后，再度变成平庸之辈。<br>传承<br>代表七月：漂泊之灵，落地生根。<br>守护祝福：纵使现状不如意，也希望你能够前进。<br>守护机缘：理念结合实物。<br>神谕<br>回到家乡，回顾成长。在这种情况下，我们更能感受到土之神的影响。<br>祈运<br>承纳型人格：承载寄托，砥砺向前而非彷徨。<br>五行交汇<br>正：火生土-至诚生客观<br>火之集束便于整体的调整，促进构造；<br>火之归统使方向得以显化，形成基位。<br>逆：木克土-封闭克发展<br>木之环抵使特质强制合并，抗拒构造；<br>木之调适使异常持续积累，瓦解基位。</p><h3 id="（二）-自然神束"><a href="#（二）-自然神束" class="headerlink" title="（二）.自然神束"></a>（二）.自然神束</h3><p>自然神束包含对建构元素的第九边缘解释。其中【自然方位】指明该元素在自然关系中代表的含义。</p><h4 id="自然-风【封锁·逸散】"><a href="#自然-风【封锁·逸散】" class="headerlink" title="自然-风【封锁·逸散】"></a>自然-风【封锁·逸散】</h4><p>神束方位：【虚律】【分散物间联系】【有界无控之律】<br>自然方位：【安逸】<br>主控方位：【自由】【守护】<br>代号&#x2F;天星：【瑞凯莱特】<br>星象：【因势顺起】<br>神名：【Recountleavid】<br>释义：<br>流荧逆行之际，离别之末，即为生命。<br>司控<br>自然：顺应外界的变化。参照“气压差异”<br>风是一切的开始，也是最原始的力量。<br>自由：在界限内单一地支配主体。参照“空中飞行”<br>保护一切，在你不逾越的地方。<br>守护：消除外界可能造成的伤害。参照“风蚀地貌”<br>封锁是一种祝福，而并非所有无知者都能承担。<br>传承<br>代表一月：一切开始的地方。<br>守护天真：我们应该享受当前状态。<br>守护个性：个性应该得到自然发展。<br>守护存护：任何事物，不当泯灭。<br>神谕<br>回到之前去过的地方，直到体验完所有的细节。在这种情况下，我们更能感受到风之神的影响。<br>灾厄<br>自在型缺陷：中我人格-认为所有的错误行为皆是对方故意诱导自己进行，所有的不利条件皆是与自身无关的其他因素刺激产生。</p><h4 id="表态-冰【解构·转呈】"><a href="#表态-冰【解构·转呈】" class="headerlink" title="表态-冰【解构·转呈】"></a>表态-冰【解构·转呈】</h4><p>神束方位：【实形】【改变内涵显态】【体现具象之形】<br>自然方位：【外观】<br>主控方位：【运作】【运行】<br>代号&#x2F;基石：【淮魄】<br>星象：【凝虚为实】<br>神名：【Contrealworld】<br>释义：<br>将虚构的信息，连向真实的世界。<br>司控<br>表态：主体的表观状态。参照“凝水成冰”<br>强调材料的珍惜，那是弱后文明的逻辑。正如表态折射的是其功能，而非其本质。<br>运作：主体接收外界信息后处理信息。参照“吸收热量”<br>观察行为本身也会让我们身陷困境：而你却回避此假设而不自知。<br>运行：主体接收外界刺激后做出反应。参照“折射光线”<br>追随着光线而奔跑，直到被其引入无尽的黑暗之中。<br>传承<br>代表九月：关注事物的表象，这是第一直觉。<br>守护道德：机体对异己行为进行演绎后，产生的一种协调利益的态度和建立于同己情境下的评判标准。<br>守护外表：我们最直接的体现。<br>神谕<br>分析真切看到的事物，理会结构和功能的关系。在这种情况下，我们更能感受到冰之神的影响。<br>灾厄<br>扩散型缺陷：报复人格-若自身处于“正确或被亏欠方”的地位，那么一切手段都是理所应当。<br>思维-光【偶发·必然】<br>神束方位：【虚律】【传递动态信息】【叠合万态之律】<br>自然方位：【概率】<br>主控方位：【均衡】【泛化】<br>代号&#x2F;天星：【宇沫】<br>星象：【化实为虚】<br>神名：【Interconstant】<br>释义：<br>寻找连接宇宙的非变量，或者界定新的可能性。<br>司控<br>思维：变化状态所呈递的信息。参照“小孔成像”<br>所测量的事物具有共同的底层逻辑，个体的存在决定着所触之物的逻辑。<br>均衡：主体的活动由多种因素决定。参照“机器学习”<br>主体的最终行为，由不同特性的活动以各自的概率共同决定<br>泛化：主体以稳定方式将信息抽化。参照“字符编码”<br>所有事物并不是有效存在的，或者说，具有共性的具体之物并无意义。<br>传承<br>代表三月：是时候走入世界了。<br>守护概率：世上没有必然发生的事情。<br>守护意识：意识是不可多得的自主之物。<br>守护规范：抽化的标准，必然的结果。<br>守护后天真理：后天真理未必蕴含在具体事物中：数学是对抽象之物的抽象。<br>神谕<br>在关键节点，参加大型的考试。在这种情况下，我们更能感受到光之神的影响。<br>灾厄<br>冲撞型缺陷：领导人格-绝对信赖却又鄙夷某物，认可其价值而又歧视其存在。<br>关联<br>冰和光：表运作，内泛化。表运行，内均衡。</p><h4 id="禁锢-阴【同质·统一】"><a href="#禁锢-阴【同质·统一】" class="headerlink" title="禁锢-阴【同质·统一】"></a>禁锢-阴【同质·统一】</h4><p>神束方位：【阴律】【隐含禁制未知】【非知非行之律】<br>自然方位：【情感】<br>主控方位：【平衡】【转化】<br>代号&#x2F;基石：【未名】<br>星象：【无形融入】<br>神名：【Imperceporder】<br>释义：<br>世界之外的，不可感之约束。<br>司控<br>禁锢：阻碍未知状态的出现。参照“编码违例”<br>即便你有能力知晓祂是何物，但请你默契地做到不越权的瞭望。<br>平衡：使某方发展时其矛盾面并行发展。参照“生死相随”<br>生中隐含着死亡的因子，这也常常是导致一触即溃的陷害。<br>转化：使某方发展能够变化为其他发展。参照“知识迁移”<br>发现的新发展，是按可知理论演化而来，或是一种认知上的怠惰与侥幸。<br>传承<br>代表六月：你做不到某些认为做得到的事。<br>守护狩猎：规律之外，必当抹除。<br>守护边界：不可思，不可言，不可做。<br>守护奉献：舍弃自己，照亮他路。<br>守护顿悟：突发而然，必有此然。<br>神谕<br>无能为力的失落，不可知且不可变的走向。在这种情况下，我们更能感受到阴之神的影响。<br>灾厄<br>局限型缺陷：具现人格-无法理解抽象事物，不能同时处理多种抽象信息。</p><h4 id="动生-阳【冲突·独立】"><a href="#动生-阳【冲突·独立】" class="headerlink" title="动生-阳【冲突·独立】"></a>动生-阳【冲突·独立】</h4><p>神束方位：【阳法】【排斥另象异物】【区分各态之法】<br>自然方位：【运动】<br>主控方位：【制衡】【差异】<br>代号&#x2F;天星：【赤核】<br>星象：【有形相斥】<br>神名：【Movemcreatery】<br>释义：<br>因动而生，因静而灭。<br>司控<br>动生：因活动而不断获得新状态。参照“绝对运动”<br>所有事物都需不断试探着寻找最优解：因不断地有其它对象去冲击它的存在。<br>制衡：发展方向不相容而相互间制约发展。参照“矛盾双方”<br>着力于陷害他人的同时，也在阻碍自己的前进。<br>差异：发展方向有区别而向不同结果发展。参照“理念分歧”<br>既然选择了不同的方向，那便不足以吞并相离的分量。<br>传承<br>代表十二月：最后，为世界注入力量吧。<br>守护运动：动起来，才有机会。<br>守护价值：不会平白获得。<br>神谕<br>不断重复的运动，稍作停留，便感空洞。在这种情况下，我们更能感受到阳之神的影响。<br>灾厄<br>侵略型缺陷：救世人格-不存具体目的地与外界频繁互动，自认正确地攻击非自身接纳的对象。<br>关系<br>阴和阳的关系：平衡合差异，差异转转化，转化合制衡，制衡转平衡。发展包含朝固定方向的发展(实)，也包含发散式的发展（虚）。</p><h3 id="（三）-天格神束"><a href="#（三）-天格神束" class="headerlink" title="（三）.天格神束"></a>（三）.天格神束</h3><p>天格神束包含对人类社会的第九边缘解释。其中【天格方位】解释该元素在天格关系中代表的含义。</p><h4 id="构型-雷【本质·形式】"><a href="#构型-雷【本质·形式】" class="headerlink" title="构型-雷【本质·形式】"></a>构型-雷【本质·形式】</h4><p>神束方位：【虚律】【传播动态特性】【守序变化之律】<br>天格方位：【文明】<br>主控方位：【发展】【更替】<br>代号&#x2F;天星：【七行】【敕命】<br>星象：【瞬息万变】<br>神名：【Marsforionete】<br>释义：<br>可知而不可见，或可见而不可知。<br>司控<br>构型：所创造对象的违背自然。参照“人类创物”<br>那是令人迷乱的陷阱：以生命为代价，来换取片刻的血亲。<br>发展：特质延续时新旧特质在内涵上相似。参照“数量积累”<br>每一局部特征与整体特征相融，或是继承，或是依附。<br>更替：特质取代时新旧特质有不同的形态。参照“质量突变”<br>将祂的秘密，层层掩盖：以欺骗新到的愚众，守候时代。<br>传承<br>代表十一月：产生最终的冲撞。<br>守护社会：文明的具体体现。<br>守护超越：抗拒源于自然的命运。<br>守护文化：相传而不断优化。<br>守护流程：有必要，并非总有效。<br>守护封装：精细的形式。<br>守护精神：界限可被修饰，内涵不断充实。<br>神谕<br>感受人类的文明、探索、领悟。在这种情况下，我们更能感受到雷之神的影响。<br>灾厄<br>社会型缺陷：排异高尚人格-信奉正面信息，抨击负面信息，执拗地认为外界所有攻击都在协助自身成长，无法认同负面信息的价值和合理性。</p><h4 id="共途-草【巩固·收束】"><a href="#共途-草【巩固·收束】" class="headerlink" title="共途-草【巩固·收束】"></a>共途-草【巩固·收束】</h4><p>神束方位：【阴法】【聚焦活动轨迹】【顺应扰动之法】<br>天格方位：【目标】<br>主控方位：【积蓄】【约束】<br>代号&#x2F;天星：【纳尔】<br>星象：【随异而动】<br>神名：【Unkguidanfate】<br>释义：<br>未定的引导，沿着命运前行。<br>司控<br>共途：类型一致时活动相似。参照“生态适应”<br>我们总是不可避免地从众：劣质的自保早已刻录进自我。<br>积蓄：变化受阻时积累力量。参照“破石而出”<br>将静止不动视作突破障碍，借用时间的流逝来寻求宽慰。<br>约束：途径变化而结果不变。参照“向阳生长”<br>和自己争夺命运：不过那些没有超出界限的争夺，徒为庸碌。<br>传承<br>代表八月：接受你的“安排”吧。<br>守护目标：弯弯绕绕，终达远方。<br>守护命运：你的未来，已模糊可知。<br>神谕<br>去理解相似的事情的发展方式，并预知大致的结果。在这种情况下，我们更能感受到草之神的影响。灾厄<br>命途型缺陷：失我人格-过于强调身份环境，忽视个体的主动性，只致力于向单方向发展，以消极的手段和态度对待外界。</p><h4 id="极阳-日"><a href="#极阳-日" class="headerlink" title="极阳-日"></a>极阳-日</h4><p>神束方位：无<br>天格方位：【混沌】<br>主控方位：【毁灭】【极化】<br>混沌：矛盾共存，无法定义。<br>毁灭：相撞而灭，不复存在。<br>极化：同源双方，对立而行。</p><h4 id="聚阴-月"><a href="#聚阴-月" class="headerlink" title="聚阴-月"></a>聚阴-月</h4><p>神束方位：无<br>天格方位：【涣散】<br>主控方位：【断裁】【同谐】<br>涣散：无法得知，不可寻找。<br>断裁：独有一态，压制万象。<br>同谐：相合为一，同形变化。</p><h4 id="常守-元"><a href="#常守-元" class="headerlink" title="常守-元"></a>常守-元</h4><p>神束方位：感知，记录，创造<br>天格方位：【自我】<br>主控方位：【虚无】【知行】<br>自我：可想，可引，可做。<br>虚无：未有状态，得失状态，销匿状态。<br>知行：发觉灵感，记载知识，不断构造。</p><hr><h2 id="四：通感"><a href="#四：通感" class="headerlink" title="四：通感"></a>四：通感</h2><p>灵魂通感指明对象的不同核心元素构成。依照一定标准，元素分为生命元素和协和元素。生命元素构成对象的基本特质，协和元素协调对象的发展。</p><h3 id="Part1：生命元素"><a href="#Part1：生命元素" class="headerlink" title="Part1：生命元素"></a>Part1：生命元素</h3><p>规则金，连接水，意识光，资源土，表态冰。</p><h3 id="Part2：协和元素"><a href="#Part2：协和元素" class="headerlink" title="Part2：协和元素"></a>Part2：协和元素</h3><p>知识木，契约火，封锁阴，动生阳，构型雷，共途草，自然风。</p><p>Tips：现对相关的生命元素做出解释：<br>金：时空决定的规则，来自所处世界的不同。<br>水：网络决定的特性，来自后天能力的不同。<br>光：环境决定的表达，来自信息类型的不同。<br>土：背景决定的财富，来自存在形式的不同。<br>冰：基因决定的倾向，来自物质组成的不同。</p><p>Tips：现对相关的协和元素做出解释：<br>木：知识决定的认知，来自学习程度的不同。<br>火：方法决定的效率，来自行事手段的不同。<br>阴：身份决定的偏差，来自所处立场的不同。<br>阳：行为决定的收益，来自行动能力的不同。<br>雷：文化决定的取向，来自生活地域的不同。<br>草：规划决定的积累，来自所选策略的不同。<br>风：心态决定的韧性，来自认知方式的不同。</p><hr><h2 id="五：反应"><a href="#五：反应" class="headerlink" title="五：反应"></a>五：反应</h2><p>我们选取核心代表及两个主要体现来充当元素反应的内核。以下不进行详细解释，仅说明该元素的效益。生效场指对象能够对主体造成某种影响的范围。</p><h3 id="金"><a href="#金" class="headerlink" title="金"></a>金</h3><p>神束方位：【实律】<br>【恒常】：使阴、阳、虚、实生效场的能量内部流转<br>【凝聚】：收敛阴、实生效场<br>【消亡】：发散阳、实生效场</p><h3 id="水"><a href="#水" class="headerlink" title="水"></a>水</h3><p>神束方位：【阴法】<br>【联觉】；使阴、阳、虚、实生效场的影响得以叠加<br>【联系】；转移阴、实生效场内对象的能量<br>【循和】：循环阴、虚生效场内对象的状态</p><h3 id="木"><a href="#木" class="headerlink" title="木"></a>木</h3><p>神束方位：【阳法】<br>【仰仗】：使阴、阳、虚、实生效场的效果显于对象<br>【环抵】：维护阳、实生效场内对象的状态<br>【调适】：调整阳、虚生效场内对象的状态</p><h3 id="火"><a href="#火" class="headerlink" title="火"></a>火</h3><p>神束方位：【阳法】<br>【契约】：使阴、阳、虚、实生效场的性质相互转化<br>【集束】；弱化阳、虚生效场内对象的特性<br>【归统】：极化阳、实生效场内对象的特性</p><h3 id="土"><a href="#土" class="headerlink" title="土"></a>土</h3><p>神束方位：【实律】<br>【方位】：使阴、阳、虚、实生效场的根基稳于物质<br>【基位】：稳定阴、实生效场内对象的状态<br>【策略】：优化阳、实生效场内对象的状态</p><h3 id="风"><a href="#风" class="headerlink" title="风"></a>风</h3><p>神束方位：【虚律】<br>【自然】：使阴、阳、虚、实生效场的范围受限扩张<br>【自由】：隔离阳、虚生效场<br>【守护】：消除阴、虚生效场</p><h3 id="冰"><a href="#冰" class="headerlink" title="冰"></a>冰</h3><p>神束方位：【实形】<br>【表态】：使阴、阳、虚、实生效场的力量具有形态<br>【运作】：拆分阴、实生效场<br>【运行】：引发阳、实生效场</p><h3 id="光"><a href="#光" class="headerlink" title="光"></a>光</h3><p>神束方位：【虚形】<br>【思维】：使阴、阳、虚、实生效场的扰动可被虚化<br>【均衡】：组构阳、虚生效场<br>【泛化】：规范阴、虚生效场</p><h3 id="阴"><a href="#阴" class="headerlink" title="阴"></a>阴</h3><p>神束方位：【阴形】<br>【禁锢】：使阴、阳、虚、实生效场的存在满足规律<br>【平衡】：复用阴、虚生效场<br>【转化】：转变阴、实生效场</p><h3 id="阳"><a href="#阳" class="headerlink" title="阳"></a>阳</h3><p>神束方位：【阳形】<br>【动生】：使阴、阳、虚、实生效场的状态不断更新<br>【制衡】：冲撞阳、虚生效场<br>【差异】：离散阳、实生效场           </p><h3 id="雷"><a href="#雷" class="headerlink" title="雷"></a>雷</h3><p>神束方位：【虚律】<br>【构型】：使阴、阳、虚、实生效场的属性可以定制<br>【发展】：延续阴、虚生效场内对象的特性<br>【更替】：封装阳、虚生效场内对象的特性</p><h3 id="草"><a href="#草" class="headerlink" title="草"></a>草</h3><p>神束方位：【阴法】<br>【共途】：使阴、阳、虚、实生效场的类型能够划分<br>【积蓄】：强化阴、实生效场内对象的状态<br>【约束】：同化阴、实生效场内对象的状态</p></div>]]></content>
      
      
      <categories>
          
          <category> 世界之核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SCHNIE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九边缘：金泽范式</title>
      <link href="/posts/8.html"/>
      <url>/posts/8.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><script>    (function(d, w, c) {        w.ChatraID = 'D5JbrYK4vHavdTNTf';        var s = d.createElement('script');        w[c] = w[c] || function() {            (w[c].q = w[c].q || []).push(arguments);        };        s.async = true;        s.src = 'https://call.chatra.io/chatra.js';        if (d.head) d.head.appendChild(s);    })(document, window, 'Chatra');</script><p><code>既然一开始就会出现那么多失误，那或许我们并不需要这么多抉择。</code></p><p>探世篇</p><h2 id="世界四十问"><a href="#世界四十问" class="headerlink" title="世界四十问"></a>世界四十问</h2><p>接纳别人的人生本来就是荒谬的。我们也无需统一的价值观。<br>在很多时候，我们认为的正确上道，或许只是适用于我们人生其他特性的产品，而非一个自己践行的标准。<br>改变别人的看法同样也是荒谬的。自以为的正确，或许只是你尝试去改变别人看法前的源动力。<br>语言无需准确。不同的人们自有不同的理解，也有不同的收益。<br>举例无需贴切。理论是明确且稳固的框架，用以精细地解决理想问题：而复杂问题是理想问题的结合。<br>不过，我们或许可以参照一种略脱离平常认知的价值观。无需接纳，思考才是最终的目的。<br>世外之问，为构想。<br>断层之问，为权衡。<br>人性之问，为思考。<br>变数之问，即世界。<br>经验蕴含真理，真理产生经验。无需多言，言自有其形，自在自身。</p><p><code>以下观点仅供个人思考所用。</code><br><strong>所写必予未见之人以启示。</strong></p><hr><h2 id="世外：过程本身就有价值，何必强求远方和意义"><a href="#世外：过程本身就有价值，何必强求远方和意义" class="headerlink" title="世外：过程本身就有价值，何必强求远方和意义"></a>世外：过程本身就有价值，何必强求远方和意义</h2><h3 id="第一问：道德-我们为何仅参考道德影响？"><a href="#第一问：道德-我们为何仅参考道德影响？" class="headerlink" title="第一问：道德-我们为何仅参考道德影响？"></a>第一问：道德-我们为何仅参考道德影响？</h3><p>Tags：标准、道德属性、人性<br>1.道德并非纵容弱者行恶。<br>2.超过分寸的善是为愚蠢，不足分寸的恶是为明智。<br>3.任何野性与强权，都可以从道德层面散发染血的光辉。<br>4.如果你没有给他们带来独到的收益，而他们又没有能力去获得，或是他们富裕到思维简陋、贫穷到自施苦难，便会在言语上大肆抹黑你的行径。<br>5.没有物质财富绑定的奖励是虚妄的，这些人正以一种不劳而获，高尚地谴责朴素的不劳而获。<br>6.所谓人品道德，皆为某种属性的表态，没人可保证其能够反映确切的实质：其可间接，也可扭曲。<br>7.没有一种行为能够定性一个人的品格，也没有一种特征能彻底否定一个人的价值：并非所有所谓的低劣行径的背后，都是低劣的发源。<br>8.任何的贬义词汇皆有其必需之处，任何的褒义词汇也有其阴暗面。我们在认同一些价值观时，需要把握情感色彩的强度，不因其虚伪而否定，不因其高尚而屈服。</p><h3 id="第二问：矛盾-为何存在自相矛盾的事物？"><a href="#第二问：矛盾-为何存在自相矛盾的事物？" class="headerlink" title="第二问：矛盾-为何存在自相矛盾的事物？"></a>第二问：矛盾-为何存在自相矛盾的事物？</h3><p>Tags：矛盾、标准、发展<br>1.认为“提出标准的对象应为区分标准中一种”。<br>2.认为“特征是状态而非过程”。<br>3.混淆前提与标准。<br>4.相关的定义并不严谨。<br>5.不平衡的事物才能存在，有倾向的事物才能发展。<br>6.我们无需把一些不合理的现象，当做自己不得不担负的责任：我们没有任何必要去为一些不合理的事物，找到折中但可用的“理由”。</p><h3 id="第三问：冲突-我们如何看待有价值的逆境？"><a href="#第三问：冲突-我们如何看待有价值的逆境？" class="headerlink" title="第三问：冲突-我们如何看待有价值的逆境？"></a>第三问：冲突-我们如何看待有价值的逆境？</h3><p>Tags：逆境、本性、发展<br>1.若自身是金子，那便自有抗拒风尘的本性。<br>2.在土中不如泥沙，不意味着自身不会再闪亮。<br>3.万物都需光：逆境本身仅是一种灾厄。<br>4.在违背自己本意的边缘之处，方能见证一些真相。<br>5.先进技术的出现，会让落后的苦难更加愚蠢。<br>6.冲击能让我们对自己的认知更明确。</p><h3 id="第四问：逻辑-为何推理无法解决所有问题？"><a href="#第四问：逻辑-为何推理无法解决所有问题？" class="headerlink" title="第四问：逻辑-为何推理无法解决所有问题？"></a>第四问：逻辑-为何推理无法解决所有问题？</h3><p>Tags：逻辑、手段、发展、发源<br>1.逻辑推理当以客观事实为基础，而不应该使判断标准推理出的情况反过来影响逻辑判断。<br>2.假设一件事情发生，和一件事情不发生，并不能构成该事情的所有情况。因为这种假设是否存在也需要得到充足的判断。<br>3.本体正确，不意味着喻体也正确。具有强大煽动性的类比和归纳的错误运用，会导致自己逻辑不清而不自知。<br>4.未知事物总包含着不稳定的因素。<br>5.若仅仅就实际情况而言，而忽视双方对信息的掌握情况，极易造成不可调和的矛盾，因为双方掌握的信息就是冲突的。</p><h3 id="第五问：真理-我们如何看待知识？"><a href="#第五问：真理-我们如何看待知识？" class="headerlink" title="第五问：真理-我们如何看待知识？"></a>第五问：真理-我们如何看待知识？</h3><p>Tags：本性、发展、价值选择<br>1.知识依托于现实的信息，也依赖形式来考察，但其本身并不是一种形式，而是形式与逻辑的结合。<br>2.知识有助于塑造我们的思维能力和改善思维方式，在学习前期，这远比掌握知识本身重要。<br>3.知识是一种特殊的商品：尊重知识的份量，但也要认清知识的价格。<br>4.求知欲不是胜负欲，不能为了个人的排名，而忽略个体尊严和社会责任。<br>5.知识能够扩展一个人的教养，对已有知识的支配方式反映一个人道德素质的高低。</p><hr><h2 id="断层：往昔的烙痕，即便成长也敏感"><a href="#断层：往昔的烙痕，即便成长也敏感" class="headerlink" title="断层：往昔的烙痕，即便成长也敏感"></a>断层：往昔的烙痕，即便成长也敏感</h2><h3 id="第六问：纵容-为何不纠正“不正确”的事物？"><a href="#第六问：纵容-为何不纠正“不正确”的事物？" class="headerlink" title="第六问：纵容-为何不纠正“不正确”的事物？"></a>第六问：纵容-为何不纠正“不正确”的事物？</h3><p>Tags：价值选择、人际牵扯、手段、发展<br>1.逾越者不能言，惊起者不敢言。心照不宣的交织，却已是相看两厌。<br>2.有些时候，实现平等的方式不是消除异端，而是在另一个地方创造新的不平等。<br>3.自身时代的幸福，未必是新的时代想要的。</p><h3 id="第七问：回绝-为何谨慎接纳他人的“好处”？"><a href="#第七问：回绝-为何谨慎接纳他人的“好处”？" class="headerlink" title="第七问：回绝-为何谨慎接纳他人的“好处”？"></a>第七问：回绝-为何谨慎接纳他人的“好处”？</h3><p>Tags：价值选择、人际牵扯、发展<br>1.对当前的自己来说无意义的事情，对未来或许有意义。<br>2.受到伪善者的援助，必受其制约。<br>3.若不想自身处处是弱点，则无需接受其公义的施舍。<br>4.一种药物的滥用，虽表面上出奇的好，但实际上会让你千疮百孔。</p><h3 id="第八问：冷漠-为何不过度纠结一些不公平？"><a href="#第八问：冷漠-为何不过度纠结一些不公平？" class="headerlink" title="第八问：冷漠-为何不过度纠结一些不公平？"></a>第八问：冷漠-为何不过度纠结一些不公平？</h3><p>Tags：价值选择、逻辑、手段<br>1.我乐意看到需要帮助的人得到及时的帮助，正如我正视我自身受到的非必要损伤无法得到弥补。不过，当我们察觉到根本利益被侵害时，应当把事情的严重性升级到对方无法承受的地步。<br>2.有些“弱者”的收益，来自强者赐予的机会。无需嫉妒弱者，因为你无力指责强者。<br>3.揭发者总奢望通过个例，来博得人们对某一类问题的关注。但实际上，人们只关心如何去嘲讽，那因单纯的不幸，而被选中的双方。但请保护他们，因为他们申请得来的光亮，迟早会照到你。<br>4.在主观评分的竞争中，自认为的用心往往很多余：你永远比不过那些善于利用规则，或者节外生枝的人。</p><h3 id="第九问：无言-为何认为一些辩驳是愚蠢的？"><a href="#第九问：无言-为何认为一些辩驳是愚蠢的？" class="headerlink" title="第九问：无言-为何认为一些辩驳是愚蠢的？"></a>第九问：无言-为何认为一些辩驳是愚蠢的？</h3><p>Tags：价值选择、标准<br>1.辩论应当展示出对极端问题的理性理解；而非强调为满足他人的情绪价值而进行的，逻辑不洽的低俗攻击。<br>2.在一些是非问题上，即便两败俱伤，也不需要失去公正的和稀泥。<br>3.有些人擅长于堵住他人的嘴，逼迫其接受虚伪的调解：最终，使我们得到的不是混乱牵强的糊弄，就是基于我们自身缺陷的指责。对于这样的“无解”状态，没必要浪费自己的时间。<br>4.有些时候的妥协，是因为我们在理性上落败，就试图在感性上说服自己：因为自身早已疲于应对。<br>5.现实事物自有分隔，抽象事物则易被无知者混杂判断：他们或服从单一的理想，或随意拼凑不同理论的特征，以批判那些不满足个人喜好的事物。</p><h3 id="第十问：贪心-为何抛弃安逸，寻求挑战和改变？"><a href="#第十问：贪心-为何抛弃安逸，寻求挑战和改变？" class="headerlink" title="第十问：贪心-为何抛弃安逸，寻求挑战和改变？"></a>第十问：贪心-为何抛弃安逸，寻求挑战和改变？</h3><p>Tags：价值选择、判断、本性<br>1.唯寒冷，使人铭记生存之幸。热气翻涌，朽木不存。<br>2.存护之下，培养的是虚假而懦弱的工具。<br>3.尝试过，才能找到内心真正的归属。<br>4.挑战能带来更大的收益。</p><h3 id="第十一问：执拗-为何坚持一些模糊难行的方向？"><a href="#第十一问：执拗-为何坚持一些模糊难行的方向？" class="headerlink" title="第十一问：执拗-为何坚持一些模糊难行的方向？"></a>第十一问：执拗-为何坚持一些模糊难行的方向？</h3><p>Tags：逆境、判断、手段、发展<br>1.当我们能力不够时，自身对外界的量度是混乱的。<br>2.混沌的逻辑，或能为我们带来稳定的希望。<br>3.人生总是需要很多关键的选择，它或许就是模糊的。<br>4.愚行统治愚者，但愚行不由愚人所引导。</p><h3 id="第十二问：愚昧-为何有人维持一些“无用”的事物？"><a href="#第十二问：愚昧-为何有人维持一些“无用”的事物？" class="headerlink" title="第十二问：愚昧-为何有人维持一些“无用”的事物？"></a>第十二问：愚昧-为何有人维持一些“无用”的事物？</h3><p>Tags：判断、手段、发源<br>1.当你觉得某种事物无用时，或许你并非它可获得或带来利益的对象，暗示、威慑、约束才是它真正的目的。<br>2.其是一种以暴力为特征的，对奴性训练的崇拜。有些人早已被驯化，而不知实情。<br>3.一部分庸人喜欢向外界展示自己的纯粹之善，来达到商业目的或获得一种自恋式的赞颂。<br>4.简单意味着坚固。<br>5.总有人需要承担阴暗的后果，来为其他人带来福运。</p><h3 id="第十三问：失礼-为何无需全部回应他人的期待？"><a href="#第十三问：失礼-为何无需全部回应他人的期待？" class="headerlink" title="第十三问：失礼-为何无需全部回应他人的期待？"></a>第十三问：失礼-为何无需全部回应他人的期待？</h3><p>Tags：判断、人性、发展、矛盾<br>1.真言也可拼凑出假象。<br>2.真正愿意为你考虑的人，不会希望你勉强自己。<br>3.有些时候的“指引”，是出于侥幸，觉得他人受骗的程度比自己大。<br>4.有些人热衷于自施苦难，然后以期待的形式强迫他人感恩。</p><h3 id="第十四问：欺骗-为何对某些人隐瞒特定真相？"><a href="#第十四问：欺骗-为何对某些人隐瞒特定真相？" class="headerlink" title="第十四问：欺骗-为何对某些人隐瞒特定真相？"></a>第十四问：欺骗-为何对某些人隐瞒特定真相？</h3><p>Tags：人性、发源、手段<br>1.俗人只有见识到恐惧后，才会试图去理解恐惧。<br>2.人们若完全坦诚交流，极易造成不可缓和的冲突：有原则的隐瞒、欺骗，也不失是一种信任和保护。<br>3.隐瞒意味着界限，即你自身依旧看重这份影响，虽然坦诚能加强彼此的信任，但可能会使行为失去一些分量。<br>4.任何关系都需要谨慎经营。过度坦诚，试图用现在的良好印象和一些花言巧语来封锁对方正常的价值判断，或是期待对方信任抽象的描述而无条件接纳一些潜在威胁，并不明智。</p><hr><h2 id="人性：不应苛责，他们逃脱不幸的拙劣方式"><a href="#人性：不应苛责，他们逃脱不幸的拙劣方式" class="headerlink" title="人性：不应苛责，他们逃脱不幸的拙劣方式"></a>人性：不应苛责，他们逃脱不幸的拙劣方式</h2><h3 id="第十五问：懒惰-思维单一的人，为什么是可悲的？"><a href="#第十五问：懒惰-思维单一的人，为什么是可悲的？" class="headerlink" title="第十五问：懒惰-思维单一的人，为什么是可悲的？"></a>第十五问：懒惰-思维单一的人，为什么是可悲的？</h3><p>Tags：逻辑、发展、发源<br>1.跪久的人，认为别人和他一样低劣而标正。他们找不到问题所在，却自顾自地幼化深层含义。<br>2.先进的生产力，会激化很多落后的矛盾。而这正是他们持续受益的源头。<br>3.认知的闭锁来自于根源上的脆弱和愚蠢，思想的跳跃来自剽窃的人权和智慧。</p><h3 id="第十六问：软弱-避免视线的人，为什么是明智的？"><a href="#第十六问：软弱-避免视线的人，为什么是明智的？" class="headerlink" title="第十六问：软弱-避免视线的人，为什么是明智的？"></a>第十六问：软弱-避免视线的人，为什么是明智的？</h3><p>Tags：发展、矛盾、人性<br>1.思潮的焦点，注定处于被动：融入即失去，脱离即落伍。<br>2.所谓非你不可，或许是出事前唾弃，出事后依赖 。<br>3.一些简单淳朴的行为，容易被心机者套上一层融入规则和秩序的否定。</p><h3 id="第十七问：破坏-轻视外界的人，为什么是卑微的？"><a href="#第十七问：破坏-轻视外界的人，为什么是卑微的？" class="headerlink" title="第十七问：破坏-轻视外界的人，为什么是卑微的？"></a>第十七问：破坏-轻视外界的人，为什么是卑微的？</h3><p>Tags：逻辑、价值选择<br>1.蔑视世俗并不是因为你有多高贵，而是相比于自己的努力，答案来的太简单。<br>2.对手不同于自己的特征，永远能作为自己不足之处的遮羞布。</p><h3 id="第十八问：欲望-强化平等的人，为什么是野蛮的？"><a href="#第十八问：欲望-强化平等的人，为什么是野蛮的？" class="headerlink" title="第十八问：欲望-强化平等的人，为什么是野蛮的？"></a>第十八问：欲望-强化平等的人，为什么是野蛮的？</h3><p>Tags：人性、逻辑、发展<br>1.从来没有什么“对等的”交换，是不需要额外代价的。<br>2.平等在于规则上，而不在于结果。<br>3.低地位对高地位的“平等”来自于内心的追求，或对高地位的鄙夷否定，高地位对低地位的“平等”来自于内心的悲悯，或对低地位的虚情假意。<br>4.不顺从他们因弱势而获得的特权，意为“不平等”。<br>5.他们追求低级雷同，而非高度一致。<br>6.遵守不同约束、遵守相同规则是“平等”的不同体现：平等依赖于具体事物，不同性质的群体有不同的平等标准。<br>7.追求平等并不意味着我们应该空泛地追求扩大化的单向受益，而是意味着我们应当更加苛刻地对待付出与回报的关系。</p><hr><h2 id="变数：见过的景色，将成为你的眼界，世界的参差，将不断逼迫独行。"><a href="#变数：见过的景色，将成为你的眼界，世界的参差，将不断逼迫独行。" class="headerlink" title="变数：见过的景色，将成为你的眼界，世界的参差，将不断逼迫独行。"></a>变数：见过的景色，将成为你的眼界，世界的参差，将不断逼迫独行。</h2><h3 id="第十九问：自我-关于情感："><a href="#第十九问：自我-关于情感：" class="headerlink" title="第十九问：自我-关于情感："></a>第十九问：自我-关于情感：</h3><p>Tags：情感价值、逻辑、标准、矛盾、人际牵扯<br>1.守护、符号、责任，以及物质性因素：血缘、财富、性爱等，共同表达出亲情，友情，爱情等情感。这些情感在人类认知下的重心和作用不同：亲情重在社会责任和爱护，友情重在双向认可和陪伴，爱情重在共赴生活和守护，感动是情理上的认同，喜欢是价值上的认可，冲动是意念上的满足——情感是我们生活的痕迹。<br>2.然而，即便情感是宽泛的，但是我们对动物（事物）的情感应该从属于对物质的需要，而不应当和对人的情感相提并论：这是文明社会(重视人的价值的社会)和稳定秩序(重视客观影响的秩序)所决定的约束。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>果不可代因，往不可还来，正是因为有情感存在。情感将每个个体联系起来，将我们与世界联系起来，是永不可灭的纽带。</p><h3 id="第二十问：自我-关于性别："><a href="#第二十问：自我-关于性别：" class="headerlink" title="第二十问：自我-关于性别："></a>第二十问：自我-关于性别：</h3><p>Tags：标准、逻辑、价值选择<br>1.性是显化的、界限分明的差异。身体的完整是先天赋予的外界认知，也是我们应该尊重和表达的自我性质。<br>2.性不是一种阻碍，而是一种社会责任的分配，其应该满足内外的双向认可，但也应该留有足够的弹性空间：每个人都应该能在不影响其他个体的情况下，达到精神自由，这是随文明程度提高而获得的特权。<br>3.许多人对真美、价值的判断基于性别，把自己当做原始文明的捍卫者：他们把异性间的繁衍当成人生的第一任务，摆脱不了意识束缚的同时企图把性别差异当成一种正误。</p><h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><p>性从来不是特权，也不是一种能力。作为标志而言，它的产生意味着有别，但也意味着允许契合。</p><h3 id="第二一问：自我-关于生命："><a href="#第二一问：自我-关于生命：" class="headerlink" title="第二一问：自我-关于生命："></a>第二一问：自我-关于生命：</h3><p>Tags：情感价值、发源、发展、矛盾、价值选择<br>生命是一场被推动着规划的旅行，只有动起来才能认识到生命的意义：不在于结果，而在于生命过程本身。<br>立足于现在，熟悉的事物依然熟悉，此前闯荡的经历宛如一场梦境。我既憧憬梦境的美好，又担心此刻的现实会变成无法复原的碎片。<br>我想珍惜我之前所珍惜的，又希望追求我现在所追求的。最后的结果，便是既无法正视过去，也不敢再迈步向前。<br>然而，现实的复杂和诙谐总能将我们纯粹的恐惧挫败，一旦我们接纳情绪的波动，这遥远而虚妄的恐惧，便会被眼前的喜怒哀乐所替代。<br>我不会以此麻痹自我，我依然会慎重考量生命的价值，我会不断地充实自身的世界，直到未来的我不再感到惊慌害怕。<br>Addition-1. 生命在自然上是不平等的，更强大的生命具有更高层次的力量。</p><h3 id="第二二问：自我-关于死亡："><a href="#第二二问：自我-关于死亡：" class="headerlink" title="第二二问：自我-关于死亡："></a>第二二问：自我-关于死亡：</h3><p>Tags：逻辑、含义、发展<br>1.死亡是众多消逝中最宽恕的一种，因为你没有足够的时间，来对死去的自我感到痛苦和悲伤。<br>2.对死亡的恐惧，具体来说是我们既渴望有新的发展，又害怕失去旧的体验。我们每时每刻都在修改自己，但也只有新的自己会惧怕旧的自己消亡。<br>3.我们无法理解自我如何诞生，也无法理解死如何实行。</p><h4 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h4><p>既然对死亡的恐惧来自对过去自我的认知，那我们也无需用其来畏惧新的自己。当你向前走的时候，新旧认知的融织将作为过渡的桥梁，既接纳旧的自己，也诞生新的未来。</p><h3 id="第二三问：自我-关于消逝："><a href="#第二三问：自我-关于消逝：" class="headerlink" title="第二三问：自我-关于消逝："></a>第二三问：自我-关于消逝：</h3><p>Tags：含义、情感价值、逻辑、自我<br>我惧怕失去自我的意识，也知道我的意识最终必然因身体溃败而消散。<br>说到底，我希望我所有重视的事物都能永远地沉浸在我认为的美好之中，哪怕只有一会，也远比注定消散的生命让我认同。<br>可美好来自于理想与现实的差异，沉浸过久，便无法认同自身处在美好之中。拥有这种落差，岂不是真正地在品尝美好的滋味？<br>我也无需担忧，我没有足够的时间去接纳所有的美好。万物同根同源，最终改变我们自身情绪的是我们自己的认知。形式再变化，我依旧能保留我对美好的追求。有追求，那便拥有一切美好的凝结之处。<br>Addition-1.物质结构总会被瓦解，一切都只是思维构建的投影。我们在混沌初刻，尚能回忆一生所为：直到混沌的力量大于清晰，一切才被盖过。我们是世界既有信息的组合，生命以分散的形式融入世界，也是另一种生命。</p><h3 id="第二四问：相逢-关于爱情："><a href="#第二四问：相逢-关于爱情：" class="headerlink" title="第二四问：相逢-关于爱情："></a>第二四问：相逢-关于爱情：</h3><p>Tags：标准、情感价值、价值选择、人性、发源<br>1.爱情不是一门生意，也不是只爱和自己有世俗关系的事物。爱情是一种陪伴的需要，是心智成熟者的自由意志，意味着情感上的善和恶，将得到同行者的干涉，但并不意味着你有权利把对方的隐私和弱点当成自己引以为傲的武器，毁掉别人的生活。<br>2.动物性欲与反叛意识的结合，会使一部分人觉得获取一个高级的私人财产是一件非常光荣的事情。但是，爱情绝非是一种利用道德的操纵关系。低等动物沉迷于控制和封锁，实际上，用欲望来判断自己的情绪和想法，最为毒害陪伴的一切意义。<br>3.为获得单方向照顾，或为传宗接代而结婚的动物本能，并不是值得肯定的情感。即便有善举和温柔填塞，这种直指目的基于怜悯的手段，也不过是动物狡诈的伪装。我们自己本身在爱人之前，就应该是有强大的能力而独立前进的个体。<br>4.成熟的爱情是保持尊严和个性条件下的结合。爱情需要真诚的谦恭、勇气、忠诚、自制，爱的意识不是一种人类商品，也不是痴恋的感情，更不是不是放纵和不可清醒，而是一种创造性活动。如果一个人没有外在能力去实践爱，没有内在品质去奉献自己的生命活力，那他也不配得到别人的爱。<br>5.爱情和生育并不冲突。若你追寻属于自己的幸福，同时又认为自己无法对后代负责，无法带给他们应有的幸福，那也可以寻找适合你的远光。若你选择后代，那需注意：我们绝不可利用长辈的权威，对后代进行冒犯和侮辱：别拥有全面支配别人人生的能力后，忘了怎么当人。<br>6.我们因为理性而感到孤独，因为孤独而感到焦虑、恐慌、自卑。人们会选取感性的方式来达到结合，或酒色成瘾，或佯装合群，或顺从欲望，或冲动行事。但我们也能够创造，在与世界的协调中实现自我价值，也可以选择爱和被爱，在追寻他我中领悟生命真谛。<br>7.专一的爱是扩散了的自我主义，是自我情感缺陷的填补。爱是不服从于任何目的的，可以是平等或者不平等，可以因“存在”而不具条件，也可因理性、权威而具有条件，但终是自由而纯净。</p><h4 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h4><p>若我们能够明知可触却留有距离，分离理想符号与现实寄托，区分欲望与爱意，那便可得真实的契合：爱可以不是泛滥冲动的，也能够严肃而崇高。然而，大部分人承认的爱情，仅仅是占有、索取、性的结合体。</p><h3 id="第二五问：相逢-关于后代："><a href="#第二五问：相逢-关于后代：" class="headerlink" title="第二五问：相逢-关于后代："></a>第二五问：相逢-关于后代：</h3><p>我无法给予他绝对安稳的物质生活，也无法保证他能够在形式教育中出类拔萃。我无法确保他不被低俗的乐趣侵蚀崇高的本心，也无法期待他能够在世俗中还有超脱世俗的眼光。<br>生活过方知其苦，在苦难中寻找欣喜的能力，仅个人被世俗认可的成就根本无法支起。不妨就此终结血脉延续的苦难，善待自己，因自己从那泥潭中挣扎而出。<br>别忘记了善待亲人，因他们牺牲自己的舒适而选择拥有你；善待周围的人，因为他们和你一样，也是臣服于低劣，却无能去解脱的人。<br>若你决定拥有后代，那便需要将人超越物质世界的一部分构成交给他，将精神世界的主权交给他，使其敢于面对自己的困境和不足，使其能够理解世界和认识自我，使其有能力拥有更好的生活：才算是育人而非养人的底线。</p><h3 id="第二六问：相逢-关于快乐："><a href="#第二六问：相逢-关于快乐：" class="headerlink" title="第二六问：相逢-关于快乐："></a>第二六问：相逢-关于快乐：</h3><p>Tags：发源、情感价值、自我<br>1.工具式教育冲刷了我们大半生命力，浅薄的娱乐方式正好迎上追寻自我的第一个缺口，它解构了严肃的专业知识，不断地误导我们：这使得我们缺乏坚定和热爱，难以摆脱浮躁与空洞。<br>2.追寻快乐也同样重要。事物发展、选择增加、能力提高的同时，我们也会失去很多追寻纯粹快乐的资格。当一些快乐仅存在于被封存的记忆中时，我们便再也无力找回。<br>Addition-3.钝化恶评。我们追求的是自己认可的事物，而非持有对立立场的恶评者心中的事物。<br>Addition-4. 我们对任何事都有不喜欢的权利，也有发声的自由，但不能强迫别人迎合你的不喜欢，也不能够用不喜欢的自由来否定别人喜欢的自由。</p><h4 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a>总结：</h4><p>当你感到疲惫时，不妨追求不为纪念、不为团聚、不为铭记、不为反思的简单的纯粹的快乐。</p><h3 id="第二七问：相逢-关于助人："><a href="#第二七问：相逢-关于助人：" class="headerlink" title="第二七问：相逢-关于助人："></a>第二七问：相逢-关于助人：</h3><p>Tags：人性、逻辑、人际牵扯<br>有部分被帮助的人认为，你并不重视这份对你并不关键的价值，而这份价值对他们更“有益”：出于整体的局面考虑，你应该自愿牺牲代价而使共同的价值最大化。<br>但实际上，他们也常常高估一些信念，轻薄地浪费这份价值。最终，他们自身对自身的亏欠心理，使得他们并不愿意直面这份责任。<br>若选择帮助他人，那我们也同时选择了接纳帮助带来的负面影响。我们可以宽容他人所遭受的不可避免的灾厄，但绝非理所应当。</p><h3 id="第二八问：相逢-关于大群："><a href="#第二八问：相逢-关于大群：" class="headerlink" title="第二八问：相逢-关于大群："></a>第二八问：相逢-关于大群：</h3><p>Tags：本性、矛盾、价值选择<br>1.我们在认知早期，热爱集群行动的原因之一是认知匮乏。因为认知不清晰、不深刻，我们无法理清真实的逻辑联系，也无法辨别哪些事物从属于客观世界，哪些事物仅来自主观绑定，而无意识地被熟悉或带有色彩的浅薄手段戏弄。<br>2.集体会给我们带来共享的安全感和荣誉感，但也会使人忽略他人的缺点，抬高自己的身位，而不再追求个体真切的卓越，而希望集群整体能够保持一种庸俗的平衡。<br>3.我们在迎合大群的途中，也会失去我们的优点。最终，我们无法满足那些对我们有偏见的人，也会失去原来赞美我们的人。</p><h4 id="总结：-5"><a href="#总结：-5" class="headerlink" title="总结："></a>总结：</h4><p>摆脱大群并非是什么拙劣的选择。我们可以选择适合自己的生活方式，也能够从自己的选择中确定生活的价值。</p><h3 id="第二九问：改变-关于学习："><a href="#第二九问：改变-关于学习：" class="headerlink" title="第二九问：改变-关于学习："></a>第二九问：改变-关于学习：</h3><p>Tags：价值选择、发展、矛盾<br>1.学习并不完全是为了获取知识。抽象之物在达到一定深度前，并无太多含义。它可以虚构，也可以真实。选择后者，是因其在逻辑上无可挑剔。<br>2.学的通透，不仅意味着思维能力的提升，也意味着你被证明有继续学习的能力。虽然这种证明方式是面向大众的，有时候会抹杀部分天才的创造性。<br>3..在难以见到光明的时候，比起远方，我们更需要脚踏实地，比起广阔，我们更需要向前的意志。比起接纳趣味、技巧和远光，我们更需要关注基础、技能和现状。<br>4.若你过早追求理想或是真相，过早拥有自己的思想，那么遗憾的是无法支配这份行为的你，必须付出更多的代价来逆行大势之流。<br>5.广泛学习的目的，在于让我们明确地知道自己想要单一地追寻什么。泛而不精、大而不全绝非我们应当存有的价值选择，维持生计的同时追寻自己“单一的”乐趣远比各方认定的“全面发展”重要。<br>Addition-6.错题本、笔记、思维导图等若使用不当，则容易被固化思维，并让自己无法正视差距，而将落后的原因归结为这种假努力做的不够。若要好好利用，则需：记忆力强，能跳跃、整体记住所写内容；或笔记高度凝炼，高度概括大量信息；或本身极其优秀，已不需课本、试卷上的资源来提升自己等。<br>Addition-7.对于普通人而言，高考工厂、幼年竞赛，是另一种遏制认知能力发展的极端。被人赞颂是因为结果理想，自身认可是因为自己从来没有过独立判断的能力。他们在获取被高雅认可的极大成功的同时，失去自主创造力，不能够做出良性的逻辑判断，也不能够妥善处理好人与人之间的连接属性，即便他们会拥有一种更加尖锐但回避庸俗的三观，但这是否值得用一生的认知水平来豪赌，还有待考量。</p><h4 id="总结：-6"><a href="#总结：-6" class="headerlink" title="总结："></a>总结：</h4><p>在有能力自主学习之前，我们也不应该静止、孤立、片面地迷信权威，把专家的观点当做世界运行的固有规则。</p><h3 id="第三十问：改变-关于探索："><a href="#第三十问：改变-关于探索：" class="headerlink" title="第三十问：改变-关于探索："></a>第三十问：改变-关于探索：</h3><p>Tags：含义、发源、发展、本性、价值选择<br>1.没有探索是毫无意义的。人类在探索规则时必然有很多假设，虽然某些假设是错误的，但正是前人的失败才让后人走上了正确的道路。就我们个体而言，即便直接得到的结果不如意，也有其他的结论具有价值，或失误的探索本身就起到了为后继者排除一种方案的作用。<br>2.绝多数探索的最外层是森林，繁杂且神秘；当你试图进一步探索时，便会遇到护城河：它会展露入骨的肮脏和卑劣；麻痹之后，方可抵达城堡，宏伟而崇高。<br>4.操纵莲花的是泥潭，孕育莲花的也是泥潭。在所谓的公平，高尚的源点，也可能为不可见光的恶劣低俗在操控。</p><h4 id="总结：-7"><a href="#总结：-7" class="headerlink" title="总结："></a>总结：</h4><p>使愚昧的变得清醒，未必是一种祝福。若我们可以保持愚昧的同时远观到真相，那我们应该慎重地考虑这是否值得深入探索。</p><h3 id="第三一问：改变-关于智能："><a href="#第三一问：改变-关于智能：" class="headerlink" title="第三一问：改变-关于智能："></a>第三一问：改变-关于智能：</h3><p>Tags：本性、矛盾、逻辑、发展<br>1.AI筛去了愚蠢、低效的活动方式，但也成为了愚蠢低效人的武装。至于要不要反对AI，或者说要不要排斥先进生产工具来维护“旧派”的利益，要看将来的人类能不能在新的技术基础上，提出更高的质量与效率的需求。<br>2.艺术是精神与精神沟通而产生的美学体验。抵制AI画作的一个重要原因，是人类非常忌讳非授权的、过于直白的模仿行为。实际上，即便不同人类画师有不同的风格，但AI的风格基于对人类风格的拼凑，而非起源于创造性思维：这是AI画和人类画最大的不同点，也是AI艺术无法被有知人类容忍的原因。当然，AI绘画反映着先进的技术，它多样、迅速、成本低，这也是一种艺术形式，但绝不是搞违规抄袭、引起二元对立的理由。<br>3.AI能够帮助我们管理死记硬背的知识，忽略作为时代余孽而出现的人情世故；同时调用我们的信息库，协同人类专有的社会、情感、创造属性，与人类一同实现对人类文明的更好管理。在那时候，记忆力、假人际、虚形式将不再成为我们跪拜苦难、庸碌此生、恶性竞争的核心。</p><h4 id="总结：-8"><a href="#总结：-8" class="headerlink" title="总结："></a>总结：</h4><p>最终，我们需要让AI识别、筛选、管理我们的知识库，搜索、归纳、与表达我们的知识体系，实现真正的知识共享。然而现实却是，AI在大部分情况下沦为了资本的工具，像癌细胞一样，强大到扼杀生命，旺盛到肆意扩散，而非是为人服务的利器。</p><h3 id="第三二问：改变-关于竞赛："><a href="#第三二问：改变-关于竞赛：" class="headerlink" title="第三二问：改变-关于竞赛："></a>第三二问：改变-关于竞赛：</h3><p>Tags：矛盾、价值选择、发展<br>大学竞赛，尤其是非现场的限时竞赛，参赛选手只需要往其中投入适中的庸碌，连接恰当的人脉，便有随机的概率取胜，并能享受和真实竞赛者相同的校内待遇。<br>但这些水赛，在扭曲那些人对竞赛的看法，让他们觉得学习意味着回报，时间意味着努力，冗长意味着优秀，虚浮意味着正式的同时，使得他们对天赋、积蓄、创造、灵感的力量不屑一顾。真正的大学竞赛应该是残酷的，而不是如此幼稚而高雅的草台班子。那些靠颠倒昼夜、持续训练、天赋加上机遇而非时间加上人际取胜的参赛者，更有资格对竞赛体系做出评判。<br>当然，一般人没有这么多时间，甚至短如三个月，但靠水赛基数、靠企业资金、靠人脉渠道而获得娱乐性质的奖项的参赛者，是否应该更含蓄些？</p><h3 id="第三三问：改变-关于教育："><a href="#第三三问：改变-关于教育：" class="headerlink" title="第三三问：改变-关于教育："></a>第三三问：改变-关于教育：</h3><p>Tags：矛盾、发展、本质<br>许多专业知识并不需要较高的认知能力与知识基础。<br>在传统的教学结构中，掌握它们需要我们在低效的自学体系中抵抗前人的傲慢。然而，当预设的敬畏被剥去后，那些表观复杂的事物会在低年级群体中被轻易分解：这也说明随时间而自然获得的成就总是无效的，他们并没有获得任何改进。<br>但若要学到事物的抽象本质（虽然传统教育过大地夸大其重要性而导致其过于形式化和落后），而非仅拥有表面成绩或灵活运用一些生产工具，外界的速成式辅导能力总是薄弱的。这需要我们自己去探索，即便这被视为“不负责的教育方式”而排斥大部分学习者，但有需要接触抽象概念的人本就是少数中的少数。</p><h3 id="第三四问：约束-关于天赋："><a href="#第三四问：约束-关于天赋：" class="headerlink" title="第三四问：约束-关于天赋："></a>第三四问：约束-关于天赋：</h3><p>Tags：价值选择、逆境、矛盾<br>1.天赋约束着努力的效果，努力的程度应该建立在和天赋适配的基础上。然而，很多大众化的事物比起对天赋的需求，更加看重一些廉价努力。<br>2.我们应当承认没有天赋的自己。在严苛的环境里，努力是天赋展现的渠道，而非弥补自身天赋不足的台阶。<br>3.没有天赋的努力是一种践踏生命价值的剥削，而没有努力的天赋是一种淡化生命价值的埋汰。<br>4.我们不需要从自己的天赋中找到答案，这个世界有很多力量能成为天赋的扩展。我们不需要用身体上的勤快，掩盖心灵上的懒惰：只吃小事的苦，吃不了大事的苦。</p><h4 id="总结：-9"><a href="#总结：-9" class="headerlink" title="总结："></a>总结：</h4><p>成功来自于天赋和努力的独特组合。我们应该谨慎地投入时间和精力在象征天赋的陡峭道路上，但也不可轻视象征努力的平坦大道带来的广阔机遇。</p><h3 id="第三五问：约束-关于道德："><a href="#第三五问：约束-关于道德：" class="headerlink" title="第三五问：约束-关于道德："></a>第三五问：约束-关于道德：</h3><p>Tags：标准、手段、人性<br>1.道德不可是施加在弱者身上的强权文化。强权者应当引领弱者，而非控制弱者。<br>2.部分人操纵道德时，会产生一些畸形的脉络：不论他们的所作所为如何，他们只要在毫不相干的细节上大加批判，便能获得那些虚伪而慵懒的拥护者们的信任。<br>3.获取自身应有待遇的行为，对外可能表达出贬义的自私属性，因其并未服务于其他人的利益。狭隘的自私者总会奢求你应当不留余力地帮助他人，而宽宏的自私者指责你应当竭尽全力封锁自己的能力。我们需要在自身和外界中寻找一个权衡点，不过分地扩大自身的影响，也不扭曲他人的需求。<br>4.部分人在依附强权的同时，又单方肯定着自己道德的高尚自由，实际上只得扭曲一些虚妄的言辞，来抬高自己的残破认知，或以合适的名义，来不合理地支配资源。<br>5.道德最大的问题在于能不能和免费划等号。使流程更加规范，可以避免很多道德争论。<br>6.在帮助弱势群体时，我们无需盲目地寻求道德上的优越感，去作秀和施恩。对弱势群体的帮助，更多地是论迹不论心。<br>7.被道德问题困扰的恶人们，既想追逐俗物，又放不下自尊心；既对抗不了资本，又对抗不过规则。他们用道德去压迫同样的苦难人，把工具推入深渊，夺取收益后大肆谴责。<br>Addition-8. 贫困补助使贫困生拥有标准的生活条件，并这不意味着他们享有与常人同样的权益：然而，消费观念本就是个人的观念而不依赖于经济水平。我们不需要用居高临下的人文关怀去指点他们对生活的追求：作为规则因素的评审和发放标准，它们的缺陷会给道德判断带来难以反驳的冲击。</p><h4 id="总结：-10"><a href="#总结：-10" class="headerlink" title="总结："></a>总结：</h4><p>道德正在被低劣的人滥用，我们需谨慎对待各种节奏。同时，衡量一个人是否有道德的标准总是主观而模糊的，我们无需太重视他人的评价：但谨慎地保护好自己的道德直觉，那是为数不多能证明我们是“人”的高价之物。</p><h3 id="第三六问：约束-关于善恶："><a href="#第三六问：约束-关于善恶：" class="headerlink" title="第三六问：约束-关于善恶："></a>第三六问：约束-关于善恶：</h3><p>Tags：含义、逻辑、本性、道德属性<br>1.恶中寻善是伪善，善中寻恶是傲慢。纯善纯恶，过于死板，时善时恶，难掩凌乱。对恶物的美德招来自欺欺人的报应，对善物的偏见反映整个生命的悲哀。<br>2.在大多数时候，比起关注问题的善恶属性，我们更应该关注解决问题的方式。比起一个人的立场，我们更应该考量他的手段，和认知此问题的方式。<br>3.在大多数时候，单独的手段无所谓善恶，同时善比恶更容易掩盖卑劣的手段。有时候那些出于善意而自愿给予的回报，恰是卑劣手段的直接目标。<br>4.帮助不该帮助的人，或者以一种曲折低效的方式，帮助需要帮助的人，是在纵容恶。<br>5.人一旦成长，就应当有洞察事物之恶、正视并利用恶的能力，而不是无原则地接纳主流之包容妥协之善。<br>6.代人行恶，非其恶。三观正不正，不以某人的三观为标准，也不以某些人的利益为标准，不困扰他人而善于生活，是为正的开始。<br>7.人有善恶才能立足。批判恶才知如何利用他人的恶，拥护善才能保护自己的善。</p><h4 id="总结：-11"><a href="#总结：-11" class="headerlink" title="总结："></a>总结：</h4><p>当直觉无法很好地判断问题性质时，我们不妨提供善恶等同重量的解决方法，遏制双方力量，规范双方手段，使其都能够朝着平稳和谐的方向发展。</p><h3 id="第三七问：约束-关于规则："><a href="#第三七问：约束-关于规则：" class="headerlink" title="第三七问：约束-关于规则："></a>第三七问：约束-关于规则：</h3><p>Tags：标准、逻辑、价值选择、矛盾、手段<br>1.认可宽松的规则，正视适度的规则，慎待苛刻的规则。我们在遵守规则的同时，需要分清是应当遵循规则本身，还是依照实际情况做出调节。<br>2.不违反规则的人，无需为别人带给自身的不幸负责；若违反某些规则会让你承担硬性责任，而蔑视实际或践踏道德能让你不被规则制裁，我们也不应该这么做。<br>3.有的规则，自产生起，就被当作压迫人格、闭锁认知的武器。这些规则构建不成规矩的规矩：但我们的实力和利益，能允许我们在一定条件下打破这些规则。<br>4.若维护崇高理想的规则，没有考虑个人简单的善意，那为彰显权威以约束共性，个人的行为就可能被规则迫害。</p><h4 id="总结：-12"><a href="#总结：-12" class="headerlink" title="总结："></a>总结：</h4><p>规则不是绝对的，我们可以在适度范围之内进行调整：不漠视，不惧怕，也不去怨恨，不去崇拜。规则是我们的保护伞，但绝不是我们冷漠狭隘的底气。</p><h3 id="第三八问：约束-关于平等："><a href="#第三八问：约束-关于平等：" class="headerlink" title="第三八问：约束-关于平等："></a>第三八问：约束-关于平等：</h3><p>Tags：含义、本性、矛盾<br>人既是自然的，又是社会的。劳动能力、身体状态、思维方式的不同使我们在自然上不平等，所处时代、社会关系、知识学历的不同使我们在社会上更为不平等。<br>那为何要追寻平等？社会上的不平等能够弱化自然上的差异，自然上的不平等又能够减少社会属性对生命的干预：以一种不平等去制衡另一种不平等，是为“平等”；或者说，予主观的平等足够的力量，才能够缓解客观的不平等。</p><h3 id="第三九问：约束-关于文化："><a href="#第三九问：约束-关于文化：" class="headerlink" title="第三九问：约束-关于文化："></a>第三九问：约束-关于文化：</h3><p>Tags：矛盾、价值选择、自我<br>1.保守或开放不是“正确”文化的标签，它仅是每个人对待不同文化的选择倾向。持有不同文化观点的人们，在冲突问题上做到彼此隔离且互相尊重，而非单向尊重或彼此辱骂，才能保证自己的世界观不走向极端化，且不被恶意团体利用。<br>2.但无论如何，我们都不该大张旗鼓地宣传或支持小众文化，利用其更加开放或更加专制的特性，去诱导心智脆弱的人信奉不受约束的开放或不具包容的保守：除非它被广泛地证明是对社会秩序，对人生发展有折中效益的得体文化。<br>3.不喜欢不意味着你能用一些下三滥的语句去攻击一些对象，这取决于个人素养；但也不意味着你需要把厌恶包装地冠冕堂皇：在说服他人或表达自己观点时，理性分析永远重于情绪表达。<br>4.文化因相互制约而平衡。再理想的文化成分，若不受约束而被过度放大，支持者因其理想而拥护，反对者因其手段而抗拒：对立属性的显化挑起，会使施暴者陈腐或极端，会让无知者麻木或敏感，会让观望者频繁从相关事物中受害，直到某一理想面再无翻身可能，而这一失去局部协调的文化，终会因新的争端而逐步走向整体瓦解。<br>Addition-1. 文化、教育、经历、媒体等共同影响个人的价值观。处于主导地位的个人价值观引导并规范其他的价值观发展，共同构建出整体价值观；这种多元并蓄的整体价值观会成为新的文化部分，并通过教育、媒体等影响个人的价值观发展。</p></div>]]></content>
      
      
      <categories>
          
          <category> 不可演算之枝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 世界真理与恶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九边缘：火神契约</title>
      <link href="/posts/6.html"/>
      <url>/posts/6.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><p><code>绝佳的方法是认识世界的途径， 但这并不妨碍那些自欺欺人的恶意。</code></p><h2 id="引导：神契"><a href="#引导：神契" class="headerlink" title="引导：神契"></a>引导：神契</h2><p>至平等之人：</p><p>当你打开这封信件的时候，我想，你早已做好了签订契约的准备。</p><p>所谓“契约”，乃是以平等的关系来交换利益，一旦签订，不可终止，除非说出交易双方，名字以及外物。所以，你务必要想清楚，你要交换什么。无论是分量，格调，乃至是签订时间，都尤为重要。</p><p>接下来，我会为你说明契约的特征，以使你在断言前再次考虑。简单来说，我需要对等的关系，精神的维持，物质的连接。</p><p>第一点：我们共享一具身体的感受，却拥有绝对分立的人格。但不管是欺瞒，控制，还是叛变，凡在契约之外的行为，我都不会干涉：寻找共同的利益，才是我们一致的目标。</p><p>第二点：你当明确用何物交换何物。若你破坏契约的平等关系，也就是使用你作为筹码的能力—我必将施以罪行之名，破坏你所有的能力。</p><p>第三点：我需要拥有一个名字。你可赋予我，我自会认同，或是从古籍中寻找—-名字只是个代号，若便于回忆，那随你意。不过，希望你想好，你需要我做什么，成为什么，皆匿于名。</p><p>第四点：我需要一个外物。契约需建立在新的人格上，而且这人格需纯净有效，且由外物生，凝结外物之形。只有借助外物，你才能保证你的意识不会影响到契约的稳定。对于这个外物，信仰，知识，甚至是书本—皆可。</p><p>第五点：我将赐予你能力。幻绫或是白绫，白剑或是赤剑，统领或者抹除，由你选择：</p><p>白剑乃是你最初的能力，为坚定意志而生，其具化异为等之形。</p><p>但剑为威慑，绫方为动。白剑化作幻绫，既是为了司控外界，同时也为了在面对真正危险时，有能力作茧自缚—这不失为一种保护。</p><p>回绫于手，便可凝出剑；赤剑破茧，便可化为白绫。白绫可抹除你无法控制的障碍，但也会使你失去一个催化契约的机会。你还需记住，在面对黑暗时，你绝不可依赖于契约的能力。所以请你合理运用这份力量。</p><p>第六点：你需在绫上布满铃铛。心存敏锐，目光锐利，便可布上铃铛。你应知，风之声，风之气，总将时间与逻辑孕于无形。化无形为有形，方可优于外界。</p><p>第七点：若你在催化契约的途中遇到苦难，可赋予我其它的名字，以集中你期待的能力。以平等之名，便可将我唤出，以外物驱使，便可使用我的力量。</p><p>契约之行，必当长久。希望你能够在这场交易中，获取你真正想要的东西。</p><p>基于武力的契约，即以他人之生命换取他人之效忠，不可轻易建立。</p><p>此外，你还需记住三灵的约定：</p><p>1.元</p><p>在胜者的约束下，他者可被泯灭，也可以归统。你如何做，需考虑清楚。</p><p>2.塑</p><p>创造之物，必有一个确切的结果。你在创造时，必与这个确切的世界有关。</p><p>3.识</p><p>意识之物，依于形，难自定。你应当坚持契约，不轻易动摇你的初心。</p><p>此外，契约还有以下规则：</p><p>1.契约破损后，一切建立在契约基础上的约定无效;</p><p>2.契约之名可制止一切衍生约定;</p><p>3.契约接纳与行为小范围冲突;</p><p>4.契约可自主提前停止，停止后一段时间内不可进行有关行为。</p><p>契灵</p><p>2022年8月7日</p><hr><h2 id="掌控于统御：建构"><a href="#掌控于统御：建构" class="headerlink" title="掌控于统御：建构"></a>掌控于统御：建构</h2><p>万物皆有结构。抽象之物，需要建构。</p><p>所谓建构，即用一定的逻辑，构造出解决问题的方案。</p><p>在契约上的建构，会随着契约条件的改变或是契约的消散而改变。即当根本的交换关系改变时，你可以拒绝遵守一些约定。</p><p>你将知晓建构的特征和方式。</p><p>建构包含建构目的本身，建构途径分支，建构对己影响，建构对他影响，以及建构退出方式。</p><p>目的本身即符合契约要求的最终目的。目的本身可以是确切的结果，也可是抽象的抉择，也能是一个暂时存在的平台。</p><p>有了目的，一切行为便能展开。失去目的，便需要善尾。</p><p>其次是途径分支。值得注意的是，你的所作所为和目的无关。不管目的是如何地正当和高贵，都无法掩盖某些行为的拙劣。</p><p>途径分支力在分析出不同的选择，不同的机遇带来的发展，以便对接下来的行为做出指引。途径分支应尽可能细腻而全面，同时也需要留有一定的弹性。毕竟，不管自身所想之事是否在控制范围内，外界之事总会给予一定程度的冲击。</p><p>接下是对己影响。在做任何事情之前，必须考虑其影响。不管是社交形象，还是思维层次，甚至是当前和自身“无关”的事物，均需考虑。明确行为的影响，才好在不同途径间相比较，使接下来的决定更有些分量。</p><p>对他影响是另一个层次。你并不需要过多考虑他人的感受和看法，但恶化的形象或者是对外的损害极有可能阻碍契约的进行。</p><p>或者选取一个简单的解释。对他的影响能为你保留懦弱和依靠的资本。若你暂时放下契约或者对契约的衍生约定产生动摇，在不违背根本核心时，自可选择退让。这看外界对你是否包容。</p><p>最终，你需要一个退出方式。你不可保证该目的完全正确。在当时的驱使下，你也可能无法分析出这些行为的弊病。</p><p>以静制动，是为灵动，以动克静，是为冲撞。有趣的是，没有足够的悔恨，不会轻易抗拒诱惑；有了过多的经验，不会轻易相信外物。</p><p>故，你需要一个依赖于外界的退出方式。这可以是有同类指出你的逻辑错误，也可以是托付信赖之人出手制止。记住，万事都要留有一定的余地，即便你认为自己有十足的把握。</p><p>时刻做好最坏的准备。也时刻做好失去所拥有一切的准备。一个良好的退出方式，虽不能保证让你全身而退，但至少可以做到“及时止损”。在有绝对的把握之前，不应该做绝。</p><p>你大体可不为“消极之静”而担心。在掂量无数次后，你自可知道，有些事情需要大胆试一试。</p><hr><h2 id="约束于离析：切片"><a href="#约束于离析：切片" class="headerlink" title="约束于离析：切片"></a>约束于离析：切片</h2><p>在大部分人的认知里，认为一件事物非对即错并不是科学的判断。</p><p>不过，将一件事物划分为对己有利和对己无利两部分，能让我们更好地行动。</p><p>即，明确地找到某件事物的关键冲突所在。我们将得到的划分标准称作“切片”。</p><p>准确找到“切片”，才有比较的意义。例如A课程和B课程相比，谁的贡献多，若选取“贡献谁多”作为切片，那不管是什么回答都会显得有失公正—当然同时肯定或者同时否定除外。当然这是一个不恰当的例子，因为肯定某方不意味着否定另一方。</p><p>不过，“哪种都多”或者“哪种都不多”，在我们看来并非是一种好的观点。分析事物的第一步在于表明立场，而非兼容并蓄或是中庸圆滑。</p><p>或者说，这是一种“自然成立”的观点，这两种回答之一或许便是“正确”的选择。这便说明“切片”选取地并不准确。一个问题假定的对立面，如果你中有我，我中有你，相互纠缠，那很难得到有效的结论。</p><p>这也是我们不赞成异己辩论的一个原因。本就属于不同的切片，却极力在语言修辞上紧追逻辑错误而非观点分歧，穷极定义方式而非达到共识，并不适合来寻找良好的解决方案。</p><p>当然，我们认可辩论对我们的思维有诸多好处。辩论能够活跃我们的的思维，也能够提高我们言辞的严谨程度。我们在此处“否定”其作用，是为了表明我们划分“切片”时，无需去过多参考他人的观点，尤其是那些和你具备相反价值观的对象，他们的描述可能会让你本就不清晰的逻辑更加混乱。</p><p>再回到“切片”这一话题上。好的切片应能让人一眼便做出取舍。你可能并看不起某些回答：当有同伴向长者提问时，年长者似乎“不直接回应而是侧面解释”。这也和切片的选取有关。对一种知识了解程度不同的人选取的切片不同。或许前面提到的长者从未考虑过同类所提出的问题，但又不方便当场下定论，又需要给予一种有效的观点，最终选择“侧面解释”这一较合理应答。这就好比你问，无穷大的平方和无穷大哪个更大：这个“问题”的解释层出不穷，各有奇妙之处；但如果你问当X接近无穷大时，X和X平方哪个更大，便有一个确切而统一的答案。故，切片有优劣之分。</p><p>切片也不该太过抽象。如果把做某件事情的理由划分为“合理”还是“不合理”，“应当”还是“不应当”，那我们很难得到做出选择。合理若有瑕疵，也可是它成为不合理的理由。</p><p>最后，我们回到最开始提出的问题上。这的确不易做出使众人信服的解答。当然你也许会觉得，一个问题本就不应该有支持者也有反对者吗？确实如此。但至少，支持一种观点的理由，应该使大部分支持它的人信服。如果大部分理由在其对立观点也成立，那这种切片也没有存在的必要。</p><hr><h2 id="敏锐于焰刃：利益"><a href="#敏锐于焰刃：利益" class="headerlink" title="敏锐于焰刃：利益"></a>敏锐于焰刃：利益</h2><p>追求“利益”并不低级。</p><p>有责任，乐于贡献，并不意味着在贬低或回避利益。</p><p>或是那是服务于他人的利益的一种方式，又或是存粹的陋习。</p><p>不过，回避利益比直言利益更为可怕。后者起码能够直面相关的问题，并给出有效的建构方案。我们认为前者是一种不理智而且不明智的选择。在一种虚妄而空泛的标准下，很少有得到“无私正义”嘉奖的人不会做出一些惊人而愚蠢的让步。除非你是发自内心的高尚，而非享受被敬仰的乐趣。</p><p>那么我们该如何追寻利益？</p><p>我们并不需太过理想化。许多时候，你自认为的崇高，或许是被社会广为认可的价值所感染。存在的价值有维持它存在的原因，而禁得起人性和作用批判的更多是利益。</p><p>我们并不需要付出廉价的努力。当然，这建立在你有足够的能力之后。所谓廉价的努力，便是通过大量时间的累积，大量经验的堆砌，来达到一个良好的结果。若是为了追求远方或者目标，其无可厚非；若是为了表现自己或是“闲来无事”而把边边角角“修到极致”，那可大为荒谬。这种行为不仅会给同伴带来不应有的压迫，也会给后来者带来许多徒劳无用，背离利益的形式。</p><p>我们需要避免成为概率的牺牲品。方法规则，虽可能不是最佳的，但至少是较符合当前状况的，能以较低的成本达到良好的目的。在那些考试能够取得好成绩的人里面，学习情况好的人占比大于成绩不突出里面学得好的人占比。相比于细细核查每一个人的学习情况，考试是一种即有效又低成本的方式。我们需避免获得一些被排斥的优秀，如果你不具备绝对的实力的话。</p><p>我们应该避免去验证“谎言”。去查证一个信息是否为真实的，或是发现其是虚假之后弥补或摧毁的措施，势必会损耗一部分利益。若没有足够的底气和资本的话，不要随意去查证。大可保持一种“谨慎观望”态度。</p><p>我们需要积攒足够的资本。有足够的资本，才能够在时机来临时，更有能力实现你想做之事。平时多一些有方向但结果不明确的“盲目”，很有可能在真切需要时实现其用途。当然，这些盲目来自于可信者真诚但不适用于目前的你的建议。</p><p>我们在合作时需要明确的分工。随口而谈，虽乐而行，很可能会让你承担本不属于自己的职责。利益驱使我们竭尽所能去达到目的，而混乱的分工会让我们丧失动力。他人的懒散会让你付出本不该付出的奉献，他人的越权又会让你感到难堪和挑衅。而当你为了自身利益不受损而去干扰别人的利益时，变成为一些灾难的发源。我们不需要危险无用的附庸，而是一个匹配的合作者。</p><p>值得注意的是，我们需要注意手段的高明性。并不是所有维持利益的手段都是“正当的”，也不是所有维持利益的时机都是“恰当的”。</p><p>比起维护利益，我们必先做一个恪守本分的参与者，在思想成熟，能细腻而精确地洞察出这个社会，这个世界的逻辑或是漏洞时，才应该“支配”利益。手段不危害他人，利益不浮现在表面，是最应该遵守的原则。</p><p>最后，我们有必要争取自身的利益，而非为了他人的利益而奉献自己。若你感到压力重重，不妨捏碎被赋予的欲望，寻回属于自己的时间和动力。</p><hr><h2 id="模仿于扉页：文明"><a href="#模仿于扉页：文明" class="headerlink" title="模仿于扉页：文明"></a>模仿于扉页：文明</h2><p>文明是一个非常特殊的词汇。</p><p>在我们的认知中，文明即强调形式。在一个具备文明的地方，许多看似简单的事物都有很复杂的“流程”或是“仪式”。你认为它们非常无用且虚伪，这可能与你受到的教育有关。</p><p>力争上游，用命拼搏，在这样一种充满斗争和重视速度的体制里，你会很容易放弃那些“无用之物”。学习上的非对即错，解答上的非简即繁，留给我们的思考是，错过细节，便是失败。若用这种思维看待那些“虚伪的东西”，便发觉它们的外在体现和目的没有任何关系。明明可以直达目的，为何要含蓄，为何要浮夸呢？</p><p>这便是文明。在那些为生计发愁的年代，弱肉强食，才是世界的真理。当多余的资源，多余的懦弱，使得我们去关心那些弱势群体，使我们向他们伸出援手，使我们做出对自己没有物质影响的事情时，便有了文明。</p><p>从此，关心并非怜悯，而是换位思考带来的善意；帮助并非多事，而是由此及彼带来的温和……你可能会觉得这很奇怪。明明结果相似，为何还要做这种无用的改写？</p><p>当生活不是简单的生存之后，公有秩序，社会价值，会成为新的生存。我们的情绪因物质繁荣而变得细腻，我们的行为因关联过多而变得谨慎，这让我们面对一些本可以直接应答的事物时，所作所为会变得更加地精致优美。</p><p>含蓄，尊重，雅观，这些看似与生存无关的形式，凝聚成了文明。</p><p>对自然的敬重，对前辈的尊重，对人世的责任与关怀，都是文明的产物。虽然如此，但你也不可过分柔弱。过度关心世界，甚至为此用文明的语句去攻击那些“虚伪”的事情，实为整个文明的叛徒。</p><p>文明赋予了我们相应的责任。我们从出生开始，生命便融入到相应的秩序中。外界对我们的帮助和培养绝非是无缘无故，我们应该用自己的方式回报外界。</p><hr><h2 id="乐观于自我：失范下的反击"><a href="#乐观于自我：失范下的反击" class="headerlink" title="乐观于自我：失范下的反击"></a>乐观于自我：失范下的反击</h2><p>无论如何，最后都需要回到自己。一切的准备都是为更好的前行服务，契约也是如此。<br>然而，前行的轨迹总是陷入泥泞。<br>这是一个教学与实践脱轨的时代，也是自媒体、网络直播能够无下限恰烂钱的时代。虽然传统的努力之道不至于分崩离析，但无时无刻都有不当人员在贩卖焦虑。他们无非就利用敏感的信息，利用一些争论，但这些方式总能起到作用：因为它们是真实的。<br>有人听闻，有人不屑。那些为之建立信念的人，将其当做自己迷茫时刻的最后的救赎，拼尽自己的全力，东拼西凑毫无下限，甚至歪曲三观、放弃尊严，为的是“爬到顶就不用怕”：一种非常浅薄和不负责的诓骗。<br>他们这样做，很好理解。时代问题是客观存在的。若我们没有足够的后备资本，没有足够的天赋，那如何有更好的生存环境？如何证明自己的优秀？<br>靠廉价的努力。<br>靠成为彻头彻脑的工具。<br>把生活过成一张简历。那些不可以加分的事物，皆为无用之物。<br>他们争夺更好的利益无可厚非，但问题在于如今的竞争的激烈的。在资源有限的前提下，又有多少人能对同伴的内卷毫不在意？<br>有人放下身段，去获得微薄的待遇；那也会有人利用这种微薄，逼迫后来者不断降低标准。<br>失去规范。<br>从契约的角度来看，这完全不等价。<br>被窃取的回报，构成了一张互相压制的网络。你可以比其他人变得更“优秀”，如果你愿意放弃应有的成果。<br>摆烂绝非应对内卷的绝佳方式。它会让你“失去”更多，当然这建立在其他人进行的是有效内卷的基础上。<br>然而，以保研为例，诸多学校的保研规则不公开透明，保研学生的课业成绩基本持平，在这种急需孤注一掷赌上所有的情况下，诸多无效竞赛、论文代写花钱出国的机构映入眼帘，又有哪个选手真正不愿意为了一些零头加分而不择手段，争地你死我活？“优等生们可以为之‘上水课’、卷不喜欢的竞赛、甚至去献血；宿舍里的“背刺”和“举报”是常见竞争手段”，所幸还是不幸的是，教育资源受到本科学校的隔离，以另一种不公平的方式，稍微缓和了这种不公平。<br>在这种情况下，摆烂是相对来说的明智之举。当然，这不是说你就需要享受人生，放纵自我，而是在其他人为了不合理的规定而冲锋陷阵时，找准自己的定位，或提前学习就业技能，或提前准备入职面试，也可以以兴趣为原点，参加自己热爱的竞赛（不可盲目跟风参加一些PPT和人际关系构成的草台班子），以真理为目标，了解更加专业的知识。这并不是说保研、考研不是合理的，若你具备读研的前提，能较为轻松地完成课内学业，顺带参加一些有效的认证、活动，那读研也是很好的选择；这也不意味着工作、竞赛就是轻松的，不管读研还是不读研，前提都在于“找准定位”。<br>总的来说，我们需要努力，但不是无效的努力，也不是被机构、流言所吹捧的努力。<br>如何鉴别有效无效？我们是否应该及时舍弃在“标准道路”上的付出？这并非很好把握的问题。若为了“追求真理”，而舍弃自己稍加应付便可得的“大好前程”，并非是值得赞颂的举动：我们不应该损害到手的回报，即便它对其他的奋斗者来说是不公平的。<br>我们现在能做的，唯有乐观。接纳自己的不足，认清自己的能力，肯定自我的价值：再在此基础上，找到自己的目标，以高效、纯净的方式赢得最后的胜利。<br>目标在哪，这是我们一生的课题。不管何时出发，都不算迟钝。<br>那是短暂的停留之后，发自内心的清醒，是蔑视破败规则的最佳抉择。</p></div>]]></content>
      
      
      <categories>
          
          <category> 灵耀体系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 世界规则与智 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九边缘：木刻神格</title>
      <link href="/posts/7.html"/>
      <url>/posts/7.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><h1 id="一．网络游戏：基于未知状态下的轻蔑抉择"><a href="#一．网络游戏：基于未知状态下的轻蔑抉择" class="headerlink" title="一．网络游戏：基于未知状态下的轻蔑抉择"></a>一．网络游戏：基于未知状态下的轻蔑抉择</h1><p>“游戏”作为一种娱乐方式，从古至今都难以被赋予书面的积极的意义。在我们看来，其根本原因在于批判者认为我们在“游戏”中获得的一切并不能给周围人或将来的自己带来实际的收益。其次，大部分“游戏”的逻辑不严密性很可能弱化我们的思维方式，使我们获得一种“毫无缘由”的思考回路。再者，我们在“游戏”中创造的价值并不能得到社会的广泛认可，而付出同等的时间在现实上却能获得更多的认同。以上只是理性批判者们“反对游戏”的部分内层原因。<br>可现实却是，批判者们并不真正思考过“游戏”的缺点。在他们看来，游戏会浪费学习知识和体验生活的时间，甚至浪费金钱。我们并不认为这能成为他们反对游戏的理由。首先，我们学习的现实知识未必具有丰富的逻辑，即便其本身包含激发各种素养的能力，我们也未必能够摆脱现实生活的粗糙逻辑，去主动精细化一种被强迫接纳的信息。这并不利于越加丰富的生活体验下的开放、广泛、全面思维的发展。然后，无论是体验生活的理由还是浪费钱的理由，出发点都是“游戏”是虚假的，不真切的。不过因不了解，就否认做一件事物的价值，并不是一种明智的判断。游戏因其困锁在“概念”世界里便被套上了虚无的标签，然而这和部分人崇拜的课堂知识相比，似乎只是缺少了一些权威的笼罩：不严格地讲，大部分批判者们碍于面子，不得不自称是“主动”学习知识的原因在此。</p><h3 id="1-逻辑虚构性"><a href="#1-逻辑虚构性" class="headerlink" title="1.逻辑虚构性"></a>1.逻辑虚构性</h3><p>这里我们不得不谈及“游戏”的一个“优点”：逻辑虚构性。绝大多数“游戏”的逻辑是虚构的，它们的结果自然也是虚构的。虽说其逻辑大多数都是可见且清晰，但其信息的密集程度刚好能够利用这种逻辑特性，来构建一种比现实能力更容易掌握的接口。在虚构的条件下，我们并不用为我们的所作所为承担责任（当然在不触及现实法律的前提下）。你可以选择欺诈，也可以选择信任；你可以选择结盟，也可以选择独行。在没有“顾忌”的交互中，这恰能体现我们内心真正认同的人格；在这场约束放开的思维实验中，我们或许能够依赖虚构的逻辑来建立自己真实的认知观点，和增强对一些信息的确切敏感性。当然，我们没必要为游戏中的特定行为焦虑或忏悔：在虚构的世界中，我们能放松自己，放松过后，我们应当会有意愿在现实中“伪装”：强大的落差，混沌的障碍，使得我们在现实生活中难以获得剧烈的积极反馈，而避免冒险以失去更多的精力。举个不恰当的比喻：“游戏”像一个盒子，能把我们的“暴力人格”装入，以使我们对待现实的情绪平和而稳定。</p><h3 id="2-社交独立性"><a href="#2-社交独立性" class="headerlink" title="2.社交独立性"></a>2.社交独立性</h3><p>批判者们可能又认为，若我们打游戏，那如何进行社交？这便能引出下一个“优点”：社交独立性。市面上的大部分“游戏”都有“聊天”和“联机”功能，况且我们能通过社交平台分享。前面提到，“游戏”能反映我们的真实人格，那么在“游戏”中我们所认识到的另一个“真实人格”，更能比现实社交引起我们的共鸣。在这里我们不得不思考：我们追求的社交，是标准化回答的机械式社交，还是自己悦纳，自己期待的社交？毫无疑问是后者。虽然我们与一个人熟络后，能了解到他的“真实人格”。但这种“真实人格”中很可能掺杂着“伪装”的痕迹，况且现实的熟络会让双方的现实生活有交织：若我们懊悔于这场社交，那也是避之不及，或我们不慎传递了一些敏感的信息，很可能会破坏我们现实生活的稳定性。但是，若我们通过“游戏”社交，便能很好地避免这一“后果”。在“游戏”中，我们能够主动地找到期待的人格，而不受现实中各种关系的阻碍；我们能聊及各类真实态度，而不必担心身边的人知道我们的“反叛”；我们能够有稳定的社交关系，因为基于“游戏”上的社交难以牵涉到现实中各种利益，也无需牵涉那些肮脏的不可见利益：每个人的选择都很多，无需被“近邻”的社会关系束缚。</p><h3 id="3-现实相容性"><a href="#3-现实相容性" class="headerlink" title="3.现实相容性"></a>3.现实相容性</h3><p>最后，我们简单分析“游戏”的另一个关键特性：现实相容性。游戏的创作者们来源于现实，他们创造的“游戏”也与现实有密切的关系。游戏中的文化我们熟知，游戏中的操作我们理解，这使得游戏所呈递的故事，我们能够知晓和理解。我们能够从这些故事中找到与现实相似的地方，能从这些故事中找到我们感受过的情绪。而这些，能让我们的生活更为立体，而不再是简单的线条：每一场故事，都是我们对于自身的回忆，都是遥不可及的过往的最好表达。而新鲜的故事，也能够为我们之后的行径给出有一定参考价值的引导。而那些天马行空的设定，岂不是更能够弥补我们因物质条件而被困锁在眼前的有限世界的遗憾？那是基于现有文明的另一种人生，是迷茫的我们最后的理想。（注意：现实相容性不意味着游戏能够和生活等同，这一点在下文有说明）同时，游戏融合了很多抽象的科学、哲学概念，能给我们对现实、对宇宙、对人生的超出课本内容、超出常人思维的认知，带来高效的改善。</p><p>我们除了解“游戏”的特性外，还需要知道我们在体验“游戏”时，应当注意的一些问题，这有利于我们更好地了解“游戏”的价值。</p><h3 id="1-关注情绪的表达"><a href="#1-关注情绪的表达" class="headerlink" title="1.关注情绪的表达"></a>1.关注情绪的表达</h3><p>我们在游戏不应充斥大量负面情绪。虽然游戏能够调节我们的情绪，但这并不意味着我们应该完全暴露出我们的负面人格。游戏并不是一个人独有的游戏，我们可以表达我们的不满，但也不应该影响到他人的游戏体验。若一个人过于自私，狂暴，易怒，那游戏也无法带来有效缓解：一个在生活中都失去情绪约束的人，又怎么能够正视这两者的区别？</p><h3 id="2-接受游戏的变化"><a href="#2-接受游戏的变化" class="headerlink" title="2.接受游戏的变化"></a>2.接受游戏的变化</h3><p>我们不应该抗拒游戏的发展。事实上，这是不可避免的。一个游戏一经上线，便势必要遭到现实文明的冲击：若不迎合，很难立足。现实的碰撞，很大程度上改变了游戏的性质，使它变得“幼稚低俗”。若你不追求“众人皆醉我独醒”的高贵品质，那应该也能够接受“假装愚昧”，在低幼的环境里，真正划清自己的理想地和游戏运营、玩家素质本身的界限。我们需要物质化的生存，人构建的游戏，也需要为人而生存。它失去我们认为的高光，我们为何不能暂时放下我们的“傲慢”？游戏是一个理想的国度，但运营方并没办法照顾到所有玩家的情绪。我们如果遇到自己不喜欢的事物，那便忘记就好。只属于自己的精神世界不应被污染，而是由自己把握。</p><h3 id="3-不忽视现实价值"><a href="#3-不忽视现实价值" class="headerlink" title="3.不忽视现实价值"></a>3.不忽视现实价值</h3><p>我们不应该沉迷于游戏。我们的情绪得到调节，我们的现实价值也应得到调节。沉迷于游戏会使得我们弱于改变现实价值，这对我们的未来生活、游戏体验都是不利的。一个游戏可以退出，但生活这场“游戏”却没有暂停键。诙谐地讲，我们在做“游戏”这个支线任务时，岂能够忘却生活这一艰难但是奖励极其丰厚的“主线”？况且，这还是个危机四伏，竞争激烈的现实世界。</p><h3 id="4-明确游戏的方式"><a href="#4-明确游戏的方式" class="headerlink" title="4.明确游戏的方式"></a>4.明确游戏的方式</h3><p>我们应该准确把握自己喜欢的游戏方式。游戏既能够是益智的玩具，还可以是精美的艺术。和免费的乐趣和重复的试验相比，精致的完美和必备的交互也有一定的吸引力。前者用于摆脱现实的枯燥，放松自己的精神状态，而后者来自于工作状态的延续，是一种对游戏内核，基于游戏设定的理念世界的高度认同。</p><p>总而言之，我们应当正视和把握游戏的价值。相互尊重是人际交往的良方，兴趣爱好的不同并不能够赋予拥有者歧视他者的权力。对于一件事物的重视是在感兴趣的前提下，正如我们并不知道游戏的前方是什么，也能够毅然决然地参与其中：它只是一个游戏，我们无需对其负责。也没有人应当多足到试图让我们对自己的轻蔑一步负责。</p></div>]]></content>
      
      
      <categories>
          
          <category> 不可演算之枝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 探世研事之篇 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
