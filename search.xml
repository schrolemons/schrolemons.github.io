<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HEXO美化：弹窗、昼夜切换调用</title>
      <link href="/posts/567f21d7.html"/>
      <url>/posts/567f21d7.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="sweetalert弹窗"><a href="#sweetalert弹窗" class="headerlink" title="sweetalert弹窗"></a>sweetalert弹窗</h2></div><div class="note info flat"><h3 id="step1：butterfly引入"><a href="#step1：butterfly引入" class="headerlink" title="step1：butterfly引入"></a>step1：butterfly引入</h3></div><p>在<code>inject</code>的<code>bottom</code>处加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><div class="note info flat"><h3 id="step1：nexT引入"><a href="#step1：nexT引入" class="headerlink" title="step1：nexT引入"></a>step1：nexT引入</h3></div><p>修改<code>_layout.njk</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;&#123;&#123; page.lang &#125;&#125;&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &#123;&#123; partial(&#x27;_partials/head/head.njk&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;</span><br><span class="line">  &#123;%- include &#x27;_partials/head/head-unique.njk&#x27; -%&#125;</span><br><span class="line">  &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt;</span><br><span class="line">  &#123;&#123; partial(&#x27;_third-party/analytics/index.njk&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;</span><br><span class="line">  &#123;&#123;- next_inject(&#x27;head&#x27;) &#125;&#125;</span><br><span class="line">  &lt;noscript&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;&#123; url_for(theme.css) &#125;&#125;/noscript.css&quot;&gt;</span><br><span class="line">  &lt;/noscript&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body itemscope itemtype=&quot;http://schema.org/WebPage&quot;&#123;% if theme.motion.enable %&#125; class=&quot;use-motion&quot;&#123;% endif %&#125;&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">+【修改这里】  &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;main class=&quot;main&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;column&quot;&gt;</span><br><span class="line">      &lt;header class=&quot;header&quot; itemscope itemtype=&quot;http://schema.org/WPHeader&quot;&gt;</span><br><span class="line">        &#123;%- include &#x27;_partials/header/index.njk&#x27; -%&#125;</span><br><span class="line">      &lt;/header&gt;</span><br><span class="line">      &#123;%- if theme.sidebar.display !== &#x27;remove&#x27; %&#125;</span><br><span class="line">        &#123;% block sidebar %&#125;&#123;% endblock %&#125;</span><br><span class="line">      &#123;%- endif %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure><div class="note info flat"><h3 id="step2：点击式调用"><a href="#step2：点击式调用" class="headerlink" title="step2：点击式调用"></a>step2：点击式调用</h3></div><p>在指定文章内，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;btn1-1&quot; class=&quot;btn btn-primary btn-lg m-3&quot;&gt; 按钮文字 &lt;/button&gt;</span><br></pre></td></tr></table></figure><p>并在文章末尾，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  $(&#x27;#btn1-1&#x27;).click(function () &#123;  //名字要与调用时的button id一致</span><br><span class="line">    swal(&#123;</span><br><span class="line">  title: &quot;Good job!&quot;,</span><br><span class="line">  text: &quot;You clicked the button!&quot;,</span><br><span class="line">  icon: &quot;success&quot;,</span><br><span class="line">  button: &quot;Aww yiss!&quot;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>效果：<button id="btn1-1" class="btn btn-primary btn-lg m-3">点我</button></p><p>更多效果请翻阅sweet官方文档。</p><div class="note info flat"><h3 id="step2：自动调用"><a href="#step2：自动调用" class="headerlink" title="step2：自动调用"></a>step2：自动调用</h3></div><p>在文章任意位置，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">if (sessionStorage.getItem(&quot;isPopupWindow&quot;) != &quot;1&quot;) &#123;</span><br><span class="line">    swal(&#123;</span><br><span class="line">  title: &quot;TITLE&quot;,</span><br><span class="line">  text: &quot;text&quot;,</span><br><span class="line">  icon: &quot;success&quot;,</span><br><span class="line">  button: &quot;OK&quot;,</span><br><span class="line">&#125;);</span><br><span class="line">sessionStorage.setItem(&quot;isPopupWindow&quot;, &quot;1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><div class="note primary flat"><h2 id="昼夜切换调用"><a href="#昼夜切换调用" class="headerlink" title="昼夜切换调用"></a>昼夜切换调用</h2></div><div class="note info flat"><h3 id="step1：修改自定义js（如custom-js）"><a href="#step1：修改自定义js（如custom-js）" class="headerlink" title="step1：修改自定义js（如custom.js）"></a>step1：修改自定义js（如<code>custom.js</code>）</h3></div><p>添加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">darkmod</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-theme&#x27;</span>, <span class="string">&#x27;dark&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;theme-color&quot;]&#x27;</span>) !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;theme-color&quot;]&#x27;</span>).<span class="title function_">setAttribute</span>(<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;#0d0d0d&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lightmod</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-theme&#x27;</span>, <span class="string">&#x27;light&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;theme-color&quot;]&#x27;</span>) !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;theme-color&quot;]&#x27;</span>).<span class="title function_">setAttribute</span>(<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;ffffff&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><h3 id="step2：修改导航栏"><a href="#step2：修改导航栏" class="headerlink" title="step2：修改导航栏"></a>step2：修改导航栏</h3></div><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">模式 || fas fa-adjust hide:</span><br><span class="line">  黑夜模式:  javascript:darkmod()</span><br><span class="line">  白昼模式: javascript:lightmod()</span><br></pre></td></tr></table></figure><p>当然，也可以用超链接的方式调用：<br><a href="javascript:darkmod()">黑夜模式</a><br><a href="javascript:lightmod()">白昼模式</a><br>许多function都在内置文件中。利用<strong>相似的方法</strong>，可以自行调用很多函数。</p><script>  $('#btn1-1').click(function () {    swal({  title: "Good job!",  text: "You clicked the button!",  icon: "success",  button: "Aww yiss!",});  })</script>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs保研经验贴|高等数学</title>
      <link href="/posts/2025g.html"/>
      <url>/posts/2025g.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="保研资料：高等数学"><a href="#保研资料：高等数学" class="headerlink" title="保研资料：高等数学"></a>保研资料：高等数学</h2></div><h3 id="可微、连续、可导"><a href="#可微、连续、可导" class="headerlink" title="可微、连续、可导"></a>可微、连续、可导</h3><p>可微：设函数在P的领域内有定义，如果全增量deitaZ&#x3D;Adeitax+Bdeitay+o(p),其中A,B是不依赖deitax，deitay的常数，则称呼z在P点可微，Adeitax+Bdeitay为P点的全微分。<br>导数：描述的是某点切线的斜率。<br>极限：去心领域内有定义<br>微分：描述的是一点的函数值的增量，且该增量是自变量与一个和自变量无关的常数的乘积，含义为用一条线性函数在某点逼近原函数。相较于导数，微分更具有直接的形式，能够更方便地解决微分方程、进行积分，并扩展到多元的情况。<br>连续：<br><img src="/../../pictures/am/img.png" alt="img.png"><br>一元函数：可微和可导等价；可导必连续，连续不一定可导（狄利克雷函数，处处连续，处处不可导）；连续必可积，可积不一定连续</p><p>多元函数：偏导连续一定可微，可微一定连续、偏导存在；连续不一定可微；连续必可积，可积不一定连续<br>有四则运算法则、求导&#x2F;偏导&#x2F;微分的链式法则（需要分清哪些是自变量、中间变量）。<br>一阶导数&#x2F;全微分的形式不变性：无论被求导&#x2F;全微分的变量是自变量还是中间变量，最后的形式相同。</p><h3 id="中值定理"><a href="#中值定理" class="headerlink" title="中值定理"></a>中值定理</h3><p>条件：闭区间连续，开区间可导。<br>（1）罗尔定理：往复运动必有一时刻速度为0；<br>（2）拉格朗日中值定理：物体从一个地方移至另一个地方的过程中，必有一时刻加速度为0；<br>（3）柯西中值定理：一段曲线运动过程中，必有一点的切线斜率，等于两端点的割线的斜率，即速度与位移方向相同。</p><h3 id="洛必达法则"><a href="#洛必达法则" class="headerlink" title="洛必达法则"></a>洛必达法则</h3><p>在x0的领域内有定义、且极限为0比0或无穷比无穷型、同时在x0的去心领域内可导且分母的导数不为0。</p><h3 id="函数极值与极限"><a href="#函数极值与极限" class="headerlink" title="函数极值与极限"></a>函数极值与极限</h3><p><img src="/../../pictures/am/img_1.png" alt="img_1.png"><br><img src="/../../pictures/am/img_2.png" alt="img_2.png"><br><img src="/../../pictures/am/img_3.png" alt="img_3.png"><br>不可导点、驻点统称为可能极值点。<br>函数极限、数列极限的性质：极限唯一性、f(x)在x0去心领域有界、保号性。</p><h3 id="三大公式"><a href="#三大公式" class="headerlink" title="三大公式"></a>三大公式</h3><p>格林公式：沟通了沿闭曲线的曲线积分与曲线所围区域上的二重积分之间的联系，将曲线积分转化成二重积分求解。</p><p>高斯公式：建立了沿空间封闭曲面的曲面积分与曲面所围区域的三重积分之间的联系，将曲面积分转化为三重积分求解。</p><p>斯托克斯公式：将三维上的曲线积分转化为曲面积分求解，它是格林公式的一般情形。<br>梯度：一个向量，表示一个标量场在某一点处的最大变化率及变化的方向。</p><p>高斯公式：通过一个闭合曲面的通量等于该曲面内部的散度的积分。<br>散度：一个数，指单位体积内所产生或吸收的通量，反映向量场发散程度。</p><p>斯托克斯公式：沿着闭合曲线的环流等于该曲线所围成的曲面上的旋度的通量。<br>旋度：一个向量，表示一个向量场在某一点的旋转趋势，和向量场的环流量有关。<br>曲率：当弧长趋于0时，切线转角的大小与弧长比值的极限即为曲率。</p><h3 id="曲面积分和二重积分等"><a href="#曲面积分和二重积分等" class="headerlink" title="曲面积分和二重积分等"></a>曲面积分和二重积分等</h3><p>二重积分是在二维平面上对某个区域D上的二元函数f(x, y)进行积分的过程。第一类曲面积分的积分区域是三维的曲面。第二类曲面积分再加上方向。<br>第一型曲线积分：是对弧长的曲线积分，曲线长度、面积。计算方法：利用参数方程的公式转换。<br>第二型曲线积分：是分别对坐标x，y 的曲线积分，变力沿曲线做的功，积分下限不需小于积分上限。计算：第二型转第一型（利用方向余弦），第一型转一次积分。<br>两类曲线积分之间的联系，可以通过方向余弦联系起来。<br>第一型曲面积分：面积、体积。计算：利用参数方程的公式转换。是在三维空间里的对面积的曲面积分。<br>第二型曲面积分：流体流向曲面一侧的流量，对坐标平面积分。计算：分面投影法、合一投影法为二重积分；用方向余弦转为第一型曲面积分。</p><p>二重积分计算方法：将积分区域D划分为x型域或y型域，再二次积分；二次积分也能借用二重积分为中转，进行换序以简化运算。<br>三重积分计算方法：先一后二法（先算一次积分，再算xy域的二重积分）、先二后一法、三次积分法、柱坐标法、球坐标法、换元法（利用雅可比行列式）。<br>二重极限：当函数在一个点的去心领域内有定义，自变量x，y同时、无论路径地趋近一个点时，函数值趋近一个常数A。二次极限：分步骤趋近，两个二次极限未必相等。但二重极限、二次极限都存在时，必相等。<br>连续：<br>一致连续：不论在区间中的任何部分，只要两个自变量的数值接近到一定程度，就能使它们对应的函数值达到所指定的接近程度。<br>一致收敛：…<br>收敛：<br><img src="/../../pictures/am/img_4.png" alt="img_4.png"></p><p>闭区间上，一致收敛和收敛等价，连续和一致连续等价。<br><img src="/../../pictures/am/img_5.png" alt="img_5.png"><br><img src="/../../pictures/am/img_6.png" alt="img_6.png"><br><img src="/../../pictures/am/img_7.png" alt="img_7.png"><br><img src="/../../pictures/am/img_8.png" alt="img_8.png"><br><img src="/../../pictures/am/img_9.png" alt="img_9.png"></p><h3 id="梯度、方向导数"><a href="#梯度、方向导数" class="headerlink" title="梯度、方向导数"></a>梯度、方向导数</h3><p>方向导数：是一个数；反映的是f(x,y)在P0点沿方向v的变化率。<br>导数：描述的是一个极限，即当自变量的增量趋近0时，函数值的增量与自变量的增量的比值，含义为某点的变化率。<br>偏导数：是多个数（每元有一个）；是指多元函数沿坐标轴方向的方向导数。</p><p>梯度：指函数值增长最快的方向。<br>偏导数连续才有梯度存在。<br>梯度可用于求法向量&#x2F;法平面，进行梯度下降优化（最小化损失函数）。</p><h3 id="泰勒级数与泰勒公式"><a href="#泰勒级数与泰勒公式" class="headerlink" title="泰勒级数与泰勒公式"></a>泰勒级数与泰勒公式</h3><p>泰勒多项式 (Taylor Polynomial)内容： 指泰勒公式&#x2F;定理中的多项式部分 P_n(x; a)。</p><p>“将函数进行泰勒展开”，得到的结果可以是有限阶的泰勒公式&#x2F;多项式，也可以是无穷的泰勒级数（如果收敛且等于原函数）。<br>泰勒级数是由泰勒公式中的多项式部分 P_n(x; a) 在 n → ∞ 时形式地取极限得到的。它是泰勒公式&#x2F;定理的无限延伸。泰勒定理的余项 R_n(x) → 0 (当 n → ∞) 是泰勒级数收敛到 f(x) 的充分必要条件。<br>具有Lagrange型余项的Taylor公式对于x0点邻域内的任意x都成立，而具有Peano型余项的Taylor公式只对充分靠近xo的x才成立。</p><h3 id="反函数"><a href="#反函数" class="headerlink" title="反函数"></a>反函数</h3><p>连续性+ 严格单调（单射） ⟹ 反函数存在且连续；<br>一一映射&lt;—&gt;反函数存在；</p><h3 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h3><p>积分计算方法：公式法、分步积分法、第一类换元积分法（凑微分法）、第二类换元积分法（变量代换法）、万能代换（有可能使计算复杂化）。<br>闭连：函数可积、定积分估值定理、积分中值定理。<br>闭连：积分上限函数可导，存在原函数。<br>闭有界，有限个第一类间断点：可积。<br>可积函数分步可积、四则运算可积。<br>有原函数和可积无关系。可积只和选定区间内被积函数的有界性和连续性有关。<br>牛顿-莱布尼兹公式将求定积分的问题和求不定积分联系起来，转化为原函数两个值相减。</p><h3 id="级数和幂级数"><a href="#级数和幂级数" class="headerlink" title="级数和幂级数"></a>级数和幂级数</h3><p>单调有界的数列必收敛，满足夹挤定理的数列收敛。<br>级数发散；若末项的极限不为0，则发散。<br>正项级数收敛的充要条件：前n项和数列{Sn}有上界。<br>正项级数敛散性：比较判别法、比较判别法的极限形式、比值判别法、根值判别法、积分判别法（对于非负递减函数）、利用几何级数和p-级数。<br>其他：柯西收敛准则、莱布尼兹判别法（交错级数）、M-判别法。</p><p>函数级级数一致收敛：和函数在收敛区间内连续、和函数在收敛区间内逐项可积、和函数在收敛区间内逐项可导（可由此求和函数），且收敛半径相同。<br>求幂级数的收敛域：abel定理——由单点的收敛性求收敛域。<br>幂级数展开：直接展开、已知展开式的积分、已知展开式的求导。可展开的条件：存在任意阶导数、拉格朗日型余项的极限为0。<br><img src="/../../pictures/am/img_10.png" alt="img_10.png"><br><img src="/../../pictures/am/img_11.png" alt="img_11.png"><br><img src="/../../pictures/am/img_12.png" alt="img_12.png"><br><img src="/../../pictures/am/img_13.png" alt="img_13.png"><br><img src="/../../pictures/am/img_14.png" alt="img_14.png"></p><h3 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h3><p>傅里叶级数展开：函数可积。<br>傅里叶级数收敛：满足狄利克雷条件，即连续或只有有限个第一类间断点、有限个极值点。<br>幂级数在中心点附近高精度逼近、傅里叶级数将函数拆解为不同频率的谐波。<br>奇展开偶展开：展开式不含cosx或sinx。<br>傅里叶变换：可以处理非周期性信号（一个信号可以看成一个周期性无穷大T-&gt;∞的信号）。傅里叶变换将一个信号从时域转换到频域，得到该信号的频谱。</p><h3 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h3><p>特殊：可分离变量微分方程、齐次微分方程、全微分方程（用格林公式解）、可降阶的高阶微分方程（即按步求导）、欧拉方程。</p><p>一阶非齐次线性微分方程（常数变易法解决。其中解含有任意常数的为通解，利用初值条件消除任意常数的问题叫做“柯西问题”、特殊的：伯努利方程）</p><p>高阶齐次线性微分方程（已知一解，求另一解的置换法、幂级数解法）、高阶非齐次线性微分方程（常数变易法(列出矩阵)）</p><p>常系数齐次线性微分方程（特征方程法，根据特征根写出通解）、常系数非齐次线性微分方程（待定系数法（不用积分就能求出特解）））</p><h3 id="立体几何"><a href="#立体几何" class="headerlink" title="立体几何"></a>立体几何</h3><p>平面：点法式方程、三点方程（行列式形式）、一般方程、截距式方程<br>直线：对称式方程、参数方程、一般方程（联立两平面） </p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs保研经验贴|计算机基础知识</title>
      <link href="/posts/2025e.html"/>
      <url>/posts/2025e.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="保研资料：计算机基础知识"><a href="#保研资料：计算机基础知识" class="headerlink" title="保研资料：计算机基础知识"></a>保研资料：计算机基础知识</h2></div><h3 id="malloc-和-new"><a href="#malloc-和-new" class="headerlink" title="malloc 和 new"></a>malloc 和 new</h3><p>new从堆区和自由存储区上分配内存，malloc从堆上分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。<br>malloc只负责分配一块指定大小的内存空间，返回一个指向该空间的void*类型指针。new无须指定内存块的大小，它会在分配内存的同时调用构造函数初始化对象，并返回一个指向该对象的指针。<br>new 可以调用对象的构造函数，对应的 delete 调用相应的析构函数；malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数。<br>new在遇到内存分配失败时会抛出std::bad_alloc异常，而malloc则返回NULL指针表示分配失败。</p><h3 id="函数名，函数指针，函数的入口地址："><a href="#函数名，函数指针，函数的入口地址：" class="headerlink" title="函数名，函数指针，函数的入口地址："></a>函数名，函数指针，函数的入口地址：</h3><p>函数名：c语言中，函数名就是一个函数指针。<br>入口地址：函数时执行的第一条指令的地址，通过这个地址可以找到该函数。<br>函数指针：指向入口地址，就可以通过该指针调用函数了。</p><h3 id="数组名，数组首地址，数组指针："><a href="#数组名，数组首地址，数组指针：" class="headerlink" title="数组名，数组首地址，数组指针："></a>数组名，数组首地址，数组指针：</h3><p>数组名不是指针，是数组首地址。但 sizeof 时返回整个数组地址大小。<br>编译器会自动将 数组名 a 替换为 指向该数组首元素的指针 &amp;a[0]。</p><h3 id="递归和循环"><a href="#递归和循环" class="headerlink" title="递归和循环"></a>递归和循环</h3><p>相同点：<br>递归和循环的本质都是代码复用。<br>递归和循环在理论上具有相同的计算能力。<br>不同点：<br>递归需要系统维护一个系统工作栈，规模小，受到系统工作栈大小的限制。</p><h3 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h3><p>指针和引用都是用于处理变量的间接访问。<br>指针是一个变量，存储了另一个变量的内存地址，可以被重新分配给其他变量，也可以指向空地址（NULL）。引用是目标变量的别名，它是对目标变量进行直接访问，一旦被初始化，就不能再改变它所引用的变量。</p><h3 id="栈区和堆区"><a href="#栈区和堆区" class="headerlink" title="栈区和堆区"></a>栈区和堆区</h3><p>内核空间：应用程序不允许访问的部分，只能由内核进行操作，操作系统的内核程序映射到这个区域。<br>栈区：编译器自动分配释放、内存分配连续、生长方向向下、存放函数参数和局部变量、返回地址等。效率高，硬件提供支持，压栈和出栈都有专门的指令。<br>堆区：堆的内存分配和释放需要显式地进行管理、内存分配不连续、它们是不同区域的内存块通过指针链接起来的。由库函数或运算符来完成申请与管理，效率较低，而且容易产生内存碎片。<br>静态存储区（全局内存区）：全局内存区是用于存储全局变量、静态变量和静态常量的一块内存区域。这块内存在程序启动时被分配，并在整个程序的生命周期中一直存在，直到程序结束才被释放。<br>常量区：常量区用于存储常量字符串和其他常量数据。这些数据在程序运行期间是只读的。<br>程序代码区：代码区存储程序的指令，也就是可执行代码（编译后的机器代码）。</p><h3 id="底层容器"><a href="#底层容器" class="headerlink" title="底层容器"></a>底层容器</h3><p>vector 是连续的，deque 则是分段连续。deque 会维护不同 array 之间的关联信息，使用户无需关心分段这个事实。<br>stack、queue使用deque作为底层容器。<br>priority_queue 使用 vector 作为底层容器。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs保研经验贴|计算机网络</title>
      <link href="/posts/2025b.html"/>
      <url>/posts/2025b.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="保研资料：计算机网络"><a href="#保研资料：计算机网络" class="headerlink" title="保研资料：计算机网络"></a>保研资料：计算机网络</h2></div><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p>计算机网络：计算机技术和通信技术相结合的产物，独立自治、相互连接的计算机集合。分为硬件、软件、协议；广域网城域网局域网；广播、点对点；资源子网、通信子网。<br>电路交换、报文交换、分组交换。<br>拓扑结构：总线型（信息传输不存在路由和转发的问题，总线长度和连接的设备数受到限制，容易冲突）、星形、环形、网状，树状，混合型。（分析点：拓扑结构简单、健壮性好、便于管理、成本低）<br>指标：速率、带宽、吞吐量、时延。<br>计算机网络的体系结构：计算机网络的各个层次及其协议的集合。<br>码元：数字信号的计量单位。<br>奎纳斯定理：理想低通信道中，为了避免码间串扰（高频分量不能通过信道），极限码元传输速率为2W波特。<br>香农定理：带宽受限且有噪声干扰时的极限数据传输数率。Wlog（1+信噪比）。<br>无线介质：无线电波（WLAN）、微波、红外线、激光。<br>ALOHA协议：发送前不进行监听。<br>路由转发算法：1.检查特定主机路由；2.进行按位与，找到下一跳；3.转发给默认路由。<br>RIP使用UDP的520号端口；OSPF：网络层协议，仅链路状态变化时，才洪泛；OSPF划分区域、OSPF 对于不同类型的业务可计算出不同的路由；BGP是基于TCP的应用层协议，除了首次外，只交换有变化的部分；<br>端口号：熟知端口号、登记端口号（供没有熟知端口号的应用程序使用）、客户端端口号。</p><h3 id="分层原则"><a href="#分层原则" class="headerlink" title="分层原则"></a>分层原则</h3><p>原则：不同等级的抽象建立一层、功能相近的分在一层、每层的功能明确、边界信息要尽量少、层次数量应适当。<br>“分层”可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理。<br>优点：各层之间是独立的、灵活性好、结构上可分割、易于实现和维护、有利于标准化工作；<br>缺点：降低效率；功能重复出现。<br>HTTP与HTTPS<br>安全性：HTTP不安全，因为它以明文形式传输数据，容易遭受中间人攻击。HTTPS则通过SSL&#x2F;TLS加密数据包，提高了传输过程的安全性；<br>端口号：HTTP通常使用80端口，而HTTPS使用443端口；<br>性能：HTTP的页面响应速度通常比HTTPS快，因为HTTPS在建立连接时需要更多的步骤，包括SSL握手，这会增加延迟；<br>证书：HTTPS需要使用CA（证书颁发机构）颁发的SSL证书来验证服务器的身份，而HTTP不需要；</p><h3 id="七层模型"><a href="#七层模型" class="headerlink" title="七层模型"></a>七层模型</h3><p>OSI开放式系统互联通信参考模型（英语：Open System Interconnection Reference Model，缩写为 OSI）。分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>TCP&#x2F;IP分层（4层）：网络接口层、 网际层、运输层、 应用层。<br>相似之处：都分层且相似、都基于独立的协议栈、都可解决异构网络互联。<br>不同：OSI通用性良好，适合描述各种网络；OSI在网络层支持无连接和面向连接的通信，传输层仅面向连接；TCP没有区分物理层和数据链路层。OSI 协议体系结构概念清楚，理论也较完整，但它过于复杂没有得到商业应用。<br>每一层的协议如下：</p><p>物理层：RJ45、CLOCK、IEEE802.3    （中继器，集线器，网关）</p><p>数据链路：PPP、FR、HDLC、VLAN、MAC  （网桥，交换机）</p><p>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）</p><p>传输层：TCP、UDP、SPX</p><p>会话层：NFS、SQL、NETBIOS、RPC</p><p>表示层：JPEG、MPEG、ASII</p><p>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</p><p>物理层：负责如何将计算机连接到通信媒体上。</p><p>数据链路层：处理相邻节点的数据传输。（提供物理地址寻址、数据的成帧（分段传输，错误隔离，误差校验，数据恢复）、流量控制、差错控制（处理损坏、丢失、重复、乱序。方法：错误检测、编号确认、自动重复请求、超时重传）、链路管理、透明传输等功能）<br>LCC子层：向上屏蔽底层网络差异。提供三种服务。<br>介质访问控制子层：局域网中各结点是对称的，并支持广播，需要多点平衡配置。对共享信道的访问管理。分为静态分配、动态分配（竞争、无冲突&lt;如令牌环&gt;、有限竞争&lt;在低负载下用竞争法获得较短的延迟，在高负载下用无冲突技术获得良好的信道效率&gt;）。</p><p>网络层：任意节点的数据传输，负责数据包从源到宿的传递。（分组交换、路由转发、拥塞控制、流量控制、网际互连）</p><p>传输层：提供端到端的报文传递，服务点的寻址、拆分和组装、连接控制。</p><p>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</p><p>表示层：对数据进行翻译、编码和变换。（表示协议数据单元PPDU）</p><p>应用层：处理用户的数据和信息、完成用户所希望的实际任务。<br><img src="/../../pictures/cs_exp/cn/img.png" alt="img.png"><br><img src="/../../pictures/cs_exp/cn/img_1.png" alt="img_1.png"><br><img src="/../../pictures/cs_exp/cn/img_2.png" alt="img_2.png"><br><img src="/../../pictures/cs_exp/cn/img_3.png" alt="img_3.png"><br><img src="/../../pictures/cs_exp/cn/img_4.png" alt="img_4.png"></p><h3 id="不同网络设备"><a href="#不同网络设备" class="headerlink" title="不同网络设备"></a>不同网络设备</h3><p>三层交换机的最重要的功能是加快大型局域网络内部的数据的快速转发，加入路由功能也是为这个目的服务的。如果把大型网络按照部门，地域等等因素划分成一个个小局域网，这将导致大量的网际互访，单纯的使用二层交换机不能实现网际互访；如单纯的使用路由器，由于接口数量有限和路由转发速度慢，将限制网络的速度和网络规模，采用具有路由功能的快速转发的三层交换机就成为首选。<br>DTE(Data Terminal Equipment)是具有数据处理能力及发送和接收数据信息能力的设备。<br>DCE(Data Circuit-Terminating Equipment)是能够通过网络发送和接收模拟或数字信号形式数据的设备。<br>网桥：过滤通信量、扩大了物理范围、可连接不同MAC层的局域网。<br>以太网交换机：即插即用。</p><h3 id="协议选择"><a href="#协议选择" class="headerlink" title="协议选择"></a>协议选择</h3><p>HDLC：0比特填充<br>IEEE 802：违禁编码法、曼彻斯特编码。以太网对于检查出的无效 MAC 帧简单丢弃，无需重传。<br>802.11 停止等待协议<br>滑动窗口协议：循环重复使用有限的帧序号、接收窗口驱动发送窗口的转动、累积确认。</p><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>Ipv4长度字段：20-60字节。<br>Ipv6长度字段：不包含头部的长度。<br>UDP首部长度：全部长度。<br>TCP数据偏移：首部长度，20-60字节。MSS：TCP的数据字段最大长度</p><h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h3><p>数字信号：归零编码、非归零编码、反向归零编码、曼彻斯特编码、差分曼彻斯特编码；<br>模拟信号：幅移键控、频移键控（抗干扰强）、相移键控、正交调幅。<br>基带信号：来自信源的信号，未进行频谱搬移和变换。包含有较多的低频成分，甚至有直流成分。<br>带通信号：使用载波信号传输基带信号的过程称为调制(modulation)。<br>码分复用：复用时根据码型结构的不同来实现信号分割的多路复用，用户使用同一频率，占用相同的带宽。<br>循环冗余校验码常用于数据链路层。通信双方约定一个生成多项式G(x)，最高阶为m。</p><h3 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h3><p>同步传输方式中发送方和接收方的时钟是统一的、字符与字符间的传输是同步无间隔的。<br>异步传输方式并不要求发送方和接收方的时钟完全一样，字符与字符间的传输是异步的。</p><h3 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA&#x2F;CD"></a>CSMA&#x2F;CD</h3><h3 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA&#x2F;CA"></a>CSMA&#x2F;CA</h3><p>有连接有确认。</p><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>IP层引入ICMP来进行流量控制、差错控制，并将错误或是信息交给上层处理。<br>拥塞控制：开环控制、闭环控制（显式反馈：拥塞点发警告；隐式反馈：源端主动判断）。方法：预分配缓冲区、丢弃包、限制网内包数量。<br>服务质量保证方法：过度配置、流量整形（调节网络数据流平均速率和突发性速率）、数据包调度。<br>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。<br>早期IP 地址的设计确实不够合理：地址空间的利用率有时很低、两级的 IP 地址不够灵活。提出了划分子网（缩小广播域、充分利用地址资源。问题：仍然浪费、路由表爆炸）、CIDR、NAT等。</p><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>为什么固定用户端端口号：DHCP服务器不知道客户端IP地址，它知道的是DHCP客户端的端口号。因此，DHCP服务器以等于10000的客户端端口号广播分组。如果所有DHCP客户端都没有为DHCP应用程序分配端口号10000，则可能有些客户端正在端口号10000上运行另一个应用程序。来自DHCP服务器的数据包将被传递到错误的客户端应用程序。因此，DHCP最好使用众所周知的端口号。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP可进行分段（按MSS）和组合、拼接和分割：假设有一份数据，较大，且在TCP层不分段，如果这份数据在发送的过程中出现丢包现象，TCP会发生重传，那么重传的就是这一大份数据（虽然IP层会把数据切分为MTU长度的N多个小包，但是TCP重传的单位却是那一大份数据）。<br>TCP的可靠传输：可靠传输是一种确保数据在通信过程中不丢失、不损坏且按正确顺序到达目标地的机制。关键技术：序号与确认、超时重传、滑动窗口（跟踪发送字节的状态）、校验和。<br>TCP的流量控制：滑动窗口。<br>TCP的拥塞控制：慢启动、冲突避免、快重传、快回复。<br>四种计时器：重传计时器、持久计时器（窗口为0时）、保活计时器（长连接场景，例如无数据传输时发送探测报文）、关闭状态计时器。<br>UDP 适用于实时性好的应用，如视频通话、直播、在线游戏、DNS查询等。</p><h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><p>（1）TCP（传输控制协议）是一种面向连接的、可靠的（有序，无差错，不丢失，不重复）、基于字节流的传输层协议。UDP（用户数据报协议）是一种无连接的、不可靠的、基于数据报（一次一个报文，既不合并，也不拆分）的传输层协议。<br>（2）TCP由于需要连接、要保证可靠性，通常更慢；UDP 不需要连接（不需要保存缓存、参数、序号等）、不需要保证可靠性，通常更快，首部开销小。<br>（3）TCP 以连续字节流的方式发送，因此数据会按顺序到达；UDP每个数据报独立，且有明确的边界。顺序发送的数据报可能会乱序到达接收方。<br>（4）TCP 需要保证可靠性，所以头部更大；UDP 不需要保证可靠性，所以头部更小。<br>TCP只能是点对点的（一对一）。UDP支持一对一、一对多、多对一和多对多的交互通信。</p><h3 id="三次握手、四次挥手"><a href="#三次握手、四次挥手" class="headerlink" title="三次握手、四次挥手"></a>三次握手、四次挥手</h3><p>三次握手可以确保双方都知道自己和对方具有接收和发送的能力，二次握手不能确定发送方的接受能力。<br>三次握手可以防止历史连接的建立。对比三次握手，两次握手下，服务器多了一次连接的建立和销毁，增大了开销。</p><h3 id="为什么需要2MSL"><a href="#为什么需要2MSL" class="headerlink" title="为什么需要2MSL"></a>为什么需要2MSL</h3><p>关闭时客户端需要进入TIME_WAIT状态，经过2MSL(最大报文段生存时间)才能关闭的原因：<br>为了保证 A 发送的最后一个 ACK 报文段能够到达 B，使B按正常步骤关闭； 2MSL就是一个发送和一个回复所需的最大时间（无响应时重发FIN，2MSL是一个ACK和新的FIN的时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收）。<br>防止 “已失效的连接请求报文段”出现在下一次连接中。</p><h3 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h3><p>域名全称是一个从该域到根的标签序列，以“ . ”分离这些标签。<br>使用代理技术：数据存储分散化、管理权分散化。</p><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p>用于在两台异构的主机间传输文件，可靠性由TCP保障。<br>主要功能是减少或消除不同操作系统下处理文件的不兼容性。<br>TFTP：因使用UDP协议，可用于分发程序或文件。</p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>超文本（Hypertext）是一种文本显示技术，它允许通过链接（通常称为超链接）从一个文档跳转到另一个文档或文档中的特定部分。<br>Gmail：基于万维网的电子邮件（用户与邮件服务器之间的邮件通过HTTP发送或接收）。<br>WWW：是一个分布式超文本系统。使Internet中不同计算机的文件相互链接。有用的事物用URL标识。WWW是无数个网络站点和网页的集合，构成了英特网最主要的部分。<br>HTTP是无连接、无状态的。<br>HTTP能使用持续链接（HTTP1.1）。<br><img src="/../../pictures/cs_exp/cn/img_5.png" alt="img_5.png"></p><h3 id="P2P、CS模型"><a href="#P2P、CS模型" class="headerlink" title="P2P、CS模型"></a>P2P、CS模型</h3><p>CS：主从式架构，服务器可以为多个客户服务。服务器通常在性能强大的计算机上，客户端一般在普通的个人计算机上。各计算机地位不平等，服务器能管理客户机和整个网络；客户机间不能直接通信；可扩展性差，支持的客户机数量有限。服务器必须始终处于运行状态才有可能提供服务。<br>P2P：P2P 进程在通信时并不区分服务的请求方和服务的提供方；减轻了服务器的压力，提高了系统效率；客户机之间能够直接共享文档；可扩展性好；网络健壮性强。<br>BS：界面统一，使用简单：客户端只需要安装浏览器软件；可扩展性好：采用标准的TCP&#x2F;IP和HTTP协议，具有良好的扩展性。<br>服务器进程工作方式：循环方式（一次一服务进程）、并发方式（基于TCP，同时多进程）。</p><h3 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h3><p>可创建文件夹，在不同文件夹之间移动邮件、只下载报文的某些部分。</p><h3 id="为什么出现IPv6，和IPv4相比有什么优点？"><a href="#为什么出现IPv6，和IPv4相比有什么优点？" class="headerlink" title="为什么出现IPv6，和IPv4相比有什么优点？"></a>为什么出现IPv6，和IPv4相比有什么优点？</h3><p>IPv6的可以解决IPv4地址短缺的问题。IPv6还增加了更多的功能和特性，改进首部的格式，快速处理&#x2F;转发数据报，提供更高效的路由和更好的网络配置灵活性，同时还支持更多的安全特性。<br>优点：<br>（1）大规模地址空间：IPv6采用128位地址，相较于IPv4的32位地址，IPv6的地址空间巨大到几乎无限。<br>（2）改进的性能和效率：IPv6在头部格式和地址分配方式上进行了优化，减少了路由器和主机处理数据包的开销，提高了网络性能和传输效率。<br>（3）增强网络的安全性：IPv6在设计时考虑了一些安全机制的加强，例如IPSec（IP Security）协议的原生支持，提供了对数据传输的认证、加密和完整性校验，增强了网络的安全性。</p><h3 id="IPv6和IPv4相比，报文首部的变化？"><a href="#IPv6和IPv4相比，报文首部的变化？" class="headerlink" title="IPv6和IPv4相比，报文首部的变化？"></a>IPv6和IPv4相比，报文首部的变化？</h3><p>（1）IPv6取消了首部长度字段，因为IPv6首部长度固定40字节。<br>（2）IPv6取消了区分服务字段，IPv6数据报首部中的通信量类和流表号字段实现了区分服务字段的功能。<br>（3）IPv6取消了总长度字段，改为有效载荷长度字段。这是因为IPv6数据报的首部长度是固定的40B，只有后面的有效载荷长度是不变的。<br>（4）IPv6取消了标识、标志、片偏移字段，因为这些功能已经包含在IPv6数据报的分片扩展首部中。<br>（5）IPv6把生存时间TTL字段改成跳数限制字段，这样名称与左右更加一致。<br>（6）IPv6取消了协议字段，改用下一个首部字段。<br>（7）IPv6取消了首部检验和字段，加快路由器处理IPv6数据报的速度。<br>（8）IPv6取消了选项字段，改用扩展首部来实现选项功能。</p><h3 id="为什么有MAC地址还需要IP地址？"><a href="#为什么有MAC地址还需要IP地址？" class="headerlink" title="为什么有MAC地址还需要IP地址？"></a>为什么有MAC地址还需要IP地址？</h3><p>（1）各式各样的网络使用不同的硬件地址，IP地址的作用是屏蔽异构网路的差异，使得不同网络之间的设备可以进行信息交互。<br>（2）网络的数量远远小于主机的数量。<br>（3）在设备还没有IP地址的时候(或者分配IP地址的过程中)，我们还需要用MAC地址来区分不同的设备。<br>（2）IP地址的本质是终点地址，它在跳过路由器的时候不会改变，而MAC地址则是下一跳的地址，每一次经过个路由器都会改变。<br>（3）分别用MAC地址和IP地址表示物理地址和逻辑地址方便网络分层，使得网络层和数据链路层的协议可以更灵活地替换。<br>因为路由器的隔离，IP网络无法通过广播MAC地址来完成跨网段寻址。</p><h3 id="访问链接后会发生什么？"><a href="#访问链接后会发生什么？" class="headerlink" title="访问链接后会发生什么？"></a>访问链接后会发生什么？</h3><p>（1）解析URL<br>首先解析URL，如果URL协议、域名、IP不合法，会直接交给搜索引擎。然后检查URL中是否又非法字符（空格、#和？），则对非法字符进行转义后在进行下一过程。</p><p>（2）缓存判断<br>按照浏览器缓存→操作系统缓存→路由器缓存的顺序进行检查，如果缓存中找到结果直接返回。</p><p>（3）DNS解析<br>如果缓存未命中，首先进行DNS解析，将域名转换为IP。按照本地DNS服务器→本地DNS服务器→根域名服务器→顶级域名服务器→权威域名服务器的顺序递归查询，得到IP。</p><p>（4）ARP解析<br>客户端通过ARP协议获取目标IP的MAC地址。ARP解析的过程：检查ARP缓存→局域网内发送ARP广播→目标设备回复ARP单播→更新ARP缓存。<br>（5）建立TCP连接<br>客户端创建socket，绑定本机IP和端口，通过三次握手建立TCP连接，如果使用的是HTTPS协议，三次握手结束后还要TLS的四次握手。<br>（6）发送HTTP&#x2F;HTTPS请求和响应<br>连接建立后，浏览器会向服务器发送HTTP&#x2F;HTTPS请求。可以使用GET、POST等方法。服务器收到请求后，处理并返回响应给客户端。<br>（7）浏览器渲染<br>解析HTML，构建DOM树；解析CSS，构建CSSOM树；CSSOM树与DOM树合并成渲染树，然后进行布局与绘制。</p><h3 id="如何提高一个文件的下载速度，如何加速网络传输？"><a href="#如何提高一个文件的下载速度，如何加速网络传输？" class="headerlink" title="如何提高一个文件的下载速度，如何加速网络传输？"></a>如何提高一个文件的下载速度，如何加速网络传输？</h3><p>（1）文件下载<br>① 多线程下载。将文件划分成若干块，客户端用多线程下载不同块，下载完成后再拼接起来。<br>② 减少传输量。对服务端发送的内容压缩传输（如 GZIP）。</p><p>（2）通用办法<br>① 应用层：可以使用HTTP&#x2F;2并发地发送多个请求的各个帧，然后在接收方得到帧后根据是否是同一个流来进行组装。可以使用使用QUIC协议，直接基于UDP实现低延迟传输，抗丢包能力强。<br>② 传输层：增大TCP缓冲区大小，并设置缓冲区大小为时延带宽积。<br>③ 网络层：升级网络设备，增大带宽。</p><h3 id="协议概览"><a href="#协议概览" class="headerlink" title="协议概览"></a>协议概览</h3><p>1.ARP协议：<br>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。（名词解释写到这就行）（地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。）<br>2.DHCP协议：<br>DHCP（动态主机配置协议）是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。默认情况下，DHCP作为Windows Server的一个服务组件不会被系统自动安装，还需要管理员手动安装并进行必要的配置。<br>3.DNS协议：<br>域名系统（Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。DNS协议是用来将域名转换为IP地址（也可以将IP地址转换为相应的域名地址）。<br>4.TCP协议：<br>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793 定义。<br>TCP旨在适应支持多网络应用的分层协议层次结构。 连接到不同但互连的计算机通信网络的主计算机中的成对进程之间依靠TCP提供可靠的通信服务。TCP假设它可以从较低级别的协议获得简单的，可能不可靠的数据报服务。 原则上，TCP应该能够在从硬线连接到分组交换或电路交换网络的各种通信系统之上操作。<br>5.HTTP协议：<br>超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使开发和部署非常地直截了当。<br>6.POP协议：<br>POP的全称是 Post Office Protocol，即邮局协议，用于电子邮件的接收，它使用TCP的110端口。常用的是第三版 ，所以简称为POP3。POP3仍采用Client&#x2F;Server工作模式，Client被称为客户端，一般我们日常使用电脑都是作为客户端，而Server（服务器）则是网管人员进行管理的。举个形象的例子，Server（服务器）是许多小信箱的集合，就像我们所居住楼房的信箱结构，而客户端就好比是一个人拿着钥匙去信箱开锁取信一样的道理。<br>7.ICMP协议：<br>ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP&#x2F;IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。<br>ICMP使用IP的基本支持，就像它是一个更高级别的协议，但是，ICMP实际上是IP的一个组成部分，必须由每个IP模块实现。<br>8.UDP协议：<br>Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。RFC 768 [1]  描述了 UDP。<br>Internet 的传输层有两个主要协议，互为补充。无连接的是 UDP，它除了给应用程序发送数据包功能并允许它们在所需的层次上架构自己的协议之外，几乎没有做什么特别的事情。面向连接的是 TCP，该协议几乎做了所有的事情。<br>9.FTP协议：<br>FTP（File Transfer Protocol，文件传输协议） 是 TCP&#x2F;IP 协议组中的协议之一。FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。在开发网站的时候，通常利用FTP协议把网页或程序传到Web服务器上。此外，由于FTP传输效率非常高，在网络上传输大的文件时，一般也采用该协议。<br>默认情况下FTP协议使用TCP端口中的 20和21这两个端口，其中20用于传输数据，21用于传输控制信息。但是，是否使用20作为传输数据的端口与FTP使用的传输模式有关，如果采用主动模式，那么数据传输端口就是20；如果采用被动模式，则具体最终使用哪个端口要服务器端和客户端协商决定。<br>10.SMTP协议：<br>SMTP是一种提供可靠且有效的电子邮件传输的协议。SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知。SMTP独立于特定的传输子系统，且只需要可靠有序的数据流信道支持，SMTP的重要特性之一是其能跨越网络传输邮件，即“SMTP邮件中继”。使用SMTP，可实现相同网络处理进程之间的邮件传输，也可通过中继器或网关实现某处理进程与其他网络之间的邮件传输。<br>11.TELNET协议：<br>Telnet协议是TCP&#x2F;IP协议族中的一员，是Internet远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法<br>12.IMAP协议：<br>IMAP（Internet Message Access Protocol）以前称作交互邮件访问协议（Interactive Mail Access Protocol），是一个应用层协议。IMAP是斯坦福大学在1986年开发的一种邮件获取协议。它的主要作用是邮件客户端可以通过这种协议从邮件服务器上获取邮件的信息，下载邮件等。当前的权威定义是RFC3501。IMAP协议运行在TCP&#x2F;IP协议之上，使用的端口是143。它与POP3协议的主要区别是用户可以不用把所有的邮件全部下载，可以通过客户端直接对服务器上的邮件进行操作。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs保研经验贴|计算机组成原理</title>
      <link href="/posts/2025c.html"/>
      <url>/posts/2025c.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="保研资料：计算机组成原理"><a href="#保研资料：计算机组成原理" class="headerlink" title="保研资料：计算机组成原理"></a>保研资料：计算机组成原理</h2></div><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>计算机体系结构：概念性的结构与功能特性；<br>计算机组成：实现计算机体系结构所体现的属性。</p><h3 id="各种周期"><a href="#各种周期" class="headerlink" title="各种周期"></a>各种周期</h3><p>一个指令周期包含多个机器周期（CPU周期），一个机器周期包含多个时钟周期，一个时钟周期为一个微指令周期。<br>时钟周期是计算机内部时钟震荡器发出一个完整的周期所需的时间。它是CPU工作的最小时间单位。</p><h3 id="计算机的性能指标？"><a href="#计算机的性能指标？" class="headerlink" title="计算机的性能指标？"></a>计算机的性能指标？</h3><p>总线宽度、吞吐量、CPU主频、利用率、CPI、IPS、处理机字长。<br>CPU执行时间&#x3D;CPU时钟周期数&#x2F;主频&#x3D;(指令条数×CPI)÷主频。</p><h3 id="什么是总线？总线有什么好处？总线有什么功能？"><a href="#什么是总线？总线有什么好处？总线有什么功能？" class="headerlink" title="什么是总线？总线有什么好处？总线有什么功能？"></a>什么是总线？总线有什么好处？总线有什么功能？</h3><p>总线：总线是指计算机系统中连接各个硬件组件的物理通道或逻辑通道。<br>系统总线：单总线结构、双总线结构（主存总线连接CPU、主存、通道；IO总线。优点：分离了低速IO）、三总线结构（主存总线、IO总线、DMA总线。优点：进一步提高了吞吐量）。<br>内部总线：单总线（所有组件挂载一组总线上）、多总线、专用线<br>好处：不同的设备可以通过总线发送和接收数据，实现彼此之间的通信和协作；使用总线可以减少硬件的复杂性和成本。<br>通信总线（I&#x2F;O总线）。<br>功能：<br>（1）数据传输：总线用于在不同的设备之间传输数据。它提供了数据线路，使得设备能够发送和接收数据。<br>（2）地址传输：总线可以传输地址信息，指示数据在内存中的位置或设备的寻址方式。<br>（3）控制信号传输：总线传递控制信号，用于启动、停止、同步和调度数据传输。<br>（4）中断传输：总线还可以传输中断信号，以通知CPU需要处理的事件或请求。<br>总线判优方式：链式查询、独立请求。<br><img src="/../../pictures/cs_exp/co/img.png" alt="img.png"></p><h3 id="总线的性能指标？"><a href="#总线的性能指标？" class="headerlink" title="总线的性能指标？"></a>总线的性能指标？</h3><p>总线宽度、总线带宽、信号线数、时钟同步&#x2F;异步。</p><h3 id="什么是冯诺依曼体系？"><a href="#什么是冯诺依曼体系？" class="headerlink" title="什么是冯诺依曼体系？"></a>什么是冯诺依曼体系？</h3><p>1）采用“存储程序”的工作方式：指令和数据存储在存储器中，一旦计算机被启动，计算机就会逐条执行存放在存储器中的指令。<br>2）计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5大部件组成。<br>3）指令和数据均用二进制代码表示。<br>4）指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址。<br>5）以运算器为中心。</p><h3 id="计算机从启动电源到显示图形化桌面，经历了哪些过程？"><a href="#计算机从启动电源到显示图形化桌面，经历了哪些过程？" class="headerlink" title="计算机从启动电源到显示图形化桌面，经历了哪些过程？"></a>计算机从启动电源到显示图形化桌面，经历了哪些过程？</h3><p>BIOS：一组固化到计算机内主板上一个ROM芯片上的程序，保存着计算机最重要的基本输入输出的程序（ROM）、开机后自检程序、系统自启动程序，其主要功能是为计算机提供最底层的、最直接的硬件设置和控制。<br>通电 → BIOS 硬件初始化和检查 → 控制权交给主引导记录(MBR) → MBR找启动文件并读入内存 → 控制权给启动文件 载入操作系统</p><h3 id="GPU是什么，其工作原理？"><a href="#GPU是什么，其工作原理？" class="headerlink" title="GPU是什么，其工作原理？"></a>GPU是什么，其工作原理？</h3><p>GPU（Graphics Processing Unit，图形处理器）是一种专门设计用来快速处理图像、视频和大量并行计算任务的处理器。GPU特别擅长处理可以分解成许多独立小任务的问题，这些任务可以在不同的核心上同时执行。GPU配备专用的高速显存（如GDDR6, HBM），具有极高的内存带宽。</p><h3 id="说说CPU的功能"><a href="#说说CPU的功能" class="headerlink" title="说说CPU的功能"></a>说说CPU的功能</h3><p>CPU由运算器和控制器组成。其中，控制器的功能是负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令、总线管理、处理异常和中断；运算器的功能是对数据进行加工。<br>CPU工作周期（描述的是指令处理的完整逻辑步骤，基于冯·诺依曼架构的串行执行模型）：取指周期、间址周期、执行周期、中断周期。</p><h3 id="简述多级存储系统"><a href="#简述多级存储系统" class="headerlink" title="简述多级存储系统"></a>简述多级存储系统</h3><p>为了解决存储系统大容量、高速度和低成本3个相互制约的矛盾，在计算机系统中，通常采用多级存储器结构，在图中由上至下，位价越来越低，速度越来越慢，容量越来越大， CPU 访问的频度也越来越低。<br>多级缓存的主要思想是根据访问速度和容量的权衡，将缓存划分为多个级别，每个级别的缓存大小和访问速度逐级降低。通常，L1缓存是距离处理器（CPU）最近的、最小但速度最快的缓存，而L2和L3缓存则相对较大但速度较慢。这种层次化的缓存结构可以有效地利用不同类型的缓存来提高缓存命中率，并减少对主存的访问次数，从而加快数据访问速度。<br>同时，数据cache和指令cache分离，可以解决结构冲突的问题；同时可以利用各自的局部性。</p><h3 id="影响流水线性能的因素"><a href="#影响流水线性能的因素" class="headerlink" title="影响流水线性能的因素"></a>影响流水线性能的因素</h3><p>（1）结构相关：是当多条指令同一时刻争用同一资源形成冲突。<br>（2）数据相关：当后继指令需要用到前面指令的执行结果时发生的。解决：停顿、分离寄存器的读写周期、旁路转发、nop+转发（load-use型冒险）<br>（3）控制相关：是当流水线遇到分支指令和其他改变PC值的指令时引起的。</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>运算器：ALU+通用寄存器（ACC、基址寄存器、变址寄存器、操作数计算器等）+PSW<br>控制器：PC+IR+CU、MDR、MAR<br>CU的输入：时钟信号、标志、IR、外来信号<br>存储器：内存+外存<br>CPU与主存通过地址、控制、数据三条总线连接<br><img src="/../../pictures/cs_exp/co/img_1.png" alt="img_1.png"><br><img src="/../../pictures/cs_exp/co/img_2.png" alt="img_2.png"><br><img src="/../../pictures/cs_exp/co/img_3.png" alt="img_3.png"></p><h3 id="寄存器A和ACC？"><a href="#寄存器A和ACC？" class="headerlink" title="寄存器A和ACC？"></a>寄存器A和ACC？</h3><p>A 表示了累加器中的内容，是【寄存器寻址】；ACC 表示了累加器的地址【直接寻址】。ACC用于“隐含寻址”。</p><h3 id="数制"><a href="#数制" class="headerlink" title="数制"></a>数制</h3><p>OF：对有符号数判断溢出<br>CF（进位借位）：对无符号数判断溢出<br>数分为有符号数和无符号数，有符号数分为定点和浮点。<br>规格化：使有效数字尽量占满尾数部分，使尾数的最高位上是一个有效值。（对基数为2的数来说是1）左规发生多次，右规发生一次。<br>IEEE 754中，会在小数点前隐藏一位1，使得浮点数的精度更高。<br>阶码为1时，达到最小；为254达到最大。为255表示无穷大，为0表示0。<br>为255时若尾数不为0，则为NaN，为0时若尾数不为0，则为非规格化数（隐藏位为0，用于处理下溢）。运算结果是否溢出主要看结果的指数是否溢出。<br>阶码用移码：检验特殊值（0和max）比较容易。<br>浮点数加减：对阶（小对大）、尾数加减（原码加减！！）、规格化、尾数舍入。<br>除法：恢复余数法、加减交替法。</p><h3 id="存储器（半导体、磁介质）"><a href="#存储器（半导体、磁介质）" class="headerlink" title="存储器（半导体、磁介质）"></a>存储器（半导体、磁介质）</h3><p>随机访问<br>RAM随机存储器【易失性存储器】（静态（不需要定时刷新，非破坏性读出）、动态）<br>ROM只读存储器【非易失性存储器】。包含flash（长期保存信息，在线时快速读写）、SSD（一块含多页，以页为单位读写，每次擦除一块）<br>串行访问存储器【非易失性存储器】：磁带（顺序存取）、磁盘（直接存取）、光盘；存取时间与物理地址有关<br>分为破坏性读出和非破坏性读出。<br>恢复方式——按行刷新：集中刷新（有死区）、分散刷新（无死区，按行刷新）、异步刷新（一个周期内，每一行刷新一次）≠读后再生<br><img src="/../../pictures/cs_exp/co/img_4.png" alt="img_4.png"><br><img src="/../../pictures/cs_exp/co/img_5.png" alt="img_5.png"></p><p>可采用引脚复用技术，先后通过相同的引脚输入行列地址，减半了地址引脚个数。<br>空间并行技术来优化吞吐率：单体多字（一次读出连续的m个字）、多体并行（高位交叉：高位地址表示模块号，不提高吞吐率；低位交叉：低位地址表示模块号，各模块轮流访问或同时访问，提高了吞吐率）<br>主存容量扩展提高容量：位扩展（处理数据线；每块芯片占据几位）、字扩展（处理地址线；地址的高位充当片选信号、用来选择芯片）；除此之外，还有读写线、片选线与存储器有关<br>RAID通过同时使用多个磁盘，提高了传输速率：通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量：通过镜像功能，提高安全可靠性；通过数据校验，提供容错能力。<br>Cache-主存由硬件处理，缺页处理由软件完成，主存-辅存由虚拟存储技术实现。</p><h3 id="写分配法（写不命中时）和非写分配法（写不命中时）"><a href="#写分配法（写不命中时）和非写分配法（写不命中时）" class="headerlink" title="写分配法（写不命中时）和非写分配法（写不命中时）"></a>写分配法（写不命中时）和非写分配法（写不命中时）</h3><p>写分配策略在发生写操作时，将数据加载到缓存中，并在缓存中进行修改。<br>不写分配策略在发生写操作时，直接更新主存，而不将数据加载到缓存中。</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>指令分类：零、一、二、三、四（存下一条指令的地址）地址指令；分为定长操作码、扩展操作码（指令字长有限的情况下，保留较多的种类）。<br>操作类型：数据传送（mov push pop ）、算术和逻辑运算（add sub inc dec mul div and or xor not neg）、移位（shl shr）、地址转移（jmp jcondition配合cmp&#x2F;test call&#x2F;ret）、输入输出<br>指令寻址：顺序、跳跃（相对和绝对）<br>数据寻址（指令中为形式地址）：隐含寻址（如利用ACC）、立即数寻址（表示的数据范围有限，不访存）、直接寻址（表示的地址范围有限，访存一次）、间接寻址（访存两次、范围大、且便于编制程序）、寄存器直接寻址（速度快、指令短）、寄存器间接寻址（访存一次）、基址寻址（利用值不变的基址寄存器，利于多道程序设计、存储空间分配）；变址寻址（利用值时刻变化的变址寄存器，处理数组问题）、堆栈寻址<br>地址指定方式：大端、小端<br>高级流水线技术：<br>多发射技术（CPI&lt;1，同时处理多条指令）：动态多发射技术——每个时钟周期并发处理多条独立指令（乱序执行：会发生WAR、WAW相关冲突）；静态多发射技术——将多条能并行操作的指令组合成一条超长指令）<br>超流水线技术（增加流水线级数，以提高吞吐率；但会增加流水寄存器开销）<br>一条指令对应一段微程序，一段微程序包含多条微指令。<br>指令流水线是把指令分解为若干子过程，通过将每个子过程与其他子过程并行执行，来提高计算机的吞吐率的技术。<br><img src="/../../pictures/cs_exp/co/img_6.png" alt="img_6.png"><br><img src="/../../pictures/cs_exp/co/img_7.png" alt="img_7.png"><br><img src="/../../pictures/cs_exp/co/img_8.png" alt="img_8.png"></p><p>I：立即数的算数、取数读数指令；分支跳转指令<br><img src="/../../pictures/cs_exp/co/img_9.png" alt="img_9.png"><br><img src="/../../pictures/cs_exp/co/img_10.png" alt="img_10.png"></p><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p>单周期处理器：所有指令相同的执行时间（一个时钟周期）<br>多周期处理器（不定个时钟周期）<br>流水线处理器（并行，理想情况下CPI&#x3D;1）<br>数据通路的元件：组合逻辑元件、时序逻辑元件（各类寄存器、存储器）。数据通路：数据在功能部件之间传送的路径及其经过的元件。<br>数据通路基本结构：CPU内部单总线（一个时钟周期只允许一个操作，无法完成一条指令的所有操作（一次数据传输）；需要暂存器，因为ALU需要两个输入同时进入）、CPU内部多总线（效率更高）、专用数据通路（硬件量大）<br>控制器发出控制信号的方式：<br>硬布线控制器：化简各种控制信号后用电路实现，扩展、修改麻烦。<br>微程序控制器：每条机器指令编写一个微程序，每个微程序包含诺干微指令（对应诺干个微周期，一个微周期通常为一个时钟周期），每个水平型微指令并行发出多个微命令，垂直型微指令只能执行一种微命令。<br>微指令&#x3D;操作码+下一条微指令的地址（微程序存放在控制存储器CM中，在CPU内部。同样的配件有微PC、微IR）<br>水平型微指令操作码：直接编码方式（0和1控制有无）、字段直接编码方式（需要译码器）、字段间接编码方式<br>垂直型微指令操作码：类似机器指令操作码，简单规整，但执行效率低，并行操作能力弱。</p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>内中断&#x3D;故障（软中断）、自陷（软中断）、终止（硬中断）。内中断由CPU自身检测。<br>外中断&#x3D;可屏蔽中断（INTR线；多个INTR组成中断请求标记寄存器）、不可屏蔽中断（NMI线）。外中断不和任何指令相关联。<br>异常常采用软件识别，中断则采用硬件识别。<br>中断判优逻辑：硬件判断（排队器）、软件判断<br>中断服务程序入口地址的寻找：硬件向量法、软件查询法<br>硬件识别（向量中断）：异常或中断处理程序的首地址称为中断向量，所有中断向量都存放在中断向量表中。<br>软件查询法：OS用一个统一的异常或中断查询程序，按优先级查询异常状态寄存器。<br>响应优先级由硬件线路或查询程序决定，不可改变；处理优先级可利用中断屏蔽（中断屏蔽字MASK）改变。外中断发生时，中断源改变相应中断请求标记触发器的值（硬件实现），在一条指令执行完毕后，CPU结合是否开中断、是否屏蔽了中断，来采样中断信号。<br><img src="/../../pictures/cs_exp/co/img_11.png" alt="img_11.png"><br>中断服务程序和主程序一般是无关的，而程序调用有主从关系；中断需要硬件电路；子程序嵌套可以诺干级<br><img src="/../../pictures/cs_exp/co/img_12.png" alt="img_12.png"></p><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p>IO接口：地址信息、控制信息转码；数据缓冲；通信控制。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs保研经验贴|算法设计与分析</title>
      <link href="/posts/2025f.html"/>
      <url>/posts/2025f.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="保研资料：算法设计与分析"><a href="#保研资料：算法设计与分析" class="headerlink" title="保研资料：算法设计与分析"></a>保研资料：算法设计与分析</h2></div><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>有限条指令构成，规定了解决特定问题的一系列操作。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>确定运算+确定数据集、分析时间复杂度（事前分析）、作时空性能分布图（事后测试）</p><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>缺点：子问题过多（治：反复使用分治策略，直到可以直接求解子问题）、递归工作量过多（分合）。</p><h3 id="多阶段决策过程（组合问题）"><a href="#多阶段决策过程（组合问题）" class="headerlink" title="多阶段决策过程（组合问题）"></a>多阶段决策过程（组合问题）</h3><p>前后关联的有链状结构的过程。在每一个阶段都有很多选择。多阶段决策问题的解决：贪心、动态规划，分支限界、回溯法。</p><h3 id="贪心和动态规划"><a href="#贪心和动态规划" class="headerlink" title="贪心和动态规划"></a>贪心和动态规划</h3><p>贪心-寻找最优量度标准<br>解决寻找一个输入的子集的问题，满足约束条件（可行解）和目标函数（最优解）的解。一旦证明成立后，是简单易行的高效算法。同时对许多不一定能产生最优解的问题都能产生近似最优解。</p><p>动态规划-最优子结构、无后效性、子问题重叠<br>最优子结构：问题的最优解所包含的子问题的解也是最优的。反例：求一系列数的异或最大值<br>无后效性：当前阶段的求解只与之前阶段有关，而与之后的阶段无关。反例：带负权边的最短路<br>决策并不是线性的，而需要全面考虑不同情况，分别决策。<br>步骤：寻找子问题、定义状态、导出状态转移方程、确定边界条件。</p><h3 id="回溯法和分支限界法-搜索和剪枝"><a href="#回溯法和分支限界法-搜索和剪枝" class="headerlink" title="回溯法和分支限界法-搜索和剪枝"></a>回溯法和分支限界法-搜索和剪枝</h3><p>回溯法-多米诺性质（如果部分解向量不成立，则后续所有解向量都不成立）<br>需要约束条件和目标函数。 影响回溯法（DFS）的效率（即剪枝）的因素：限界函数的计算时间（重）、通过限界函数的数目。</p><p>分支限界法（BFS、LC、D）-估价函数≤成本函数≤上界函数<br>若估价函数≤成本函数，且对于答案叶节点相同，则LC终止时就是最小成本答案节点。需要额外的存储空间维护活节点表，更利于求最优解问题。</p><h3 id="现实世界的问题-P、NP、非P"><a href="#现实世界的问题-P、NP、非P" class="headerlink" title="现实世界的问题-P、NP、非P"></a>现实世界的问题-P、NP、非P</h3><p>多项式级、指数级、不可计算（希尔伯特第十问题）、尚不确定多项式级（图着色、货郎担）。<br>P：多项式时间内用确定算法求解的判定问题。<br>NP：多项式时间内用不确定算法（猜想+验证）求解的判定问题。<br>NP完全：所有属于NP的问题都可以规约的NP问题。<br>NP-hard：所有属于NP的问题都可以规约的问题。<br>非P：不存在确定算法的多项式时间内的解。<br>如果存在一个NPC可在多项式时间解决，则所有NP问题均可在多项式时间解决，即P&#x3D;NP。<br>P包含于NP，NP真包含于非P<br>Cook定理：SAT问题是NPC问题。（还有最大可满足性问题）<br>证明一个问题是NPC问题：L是NP问题，一个NPC问题能多项式规约为此问题。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs保研经验贴|离散数学</title>
      <link href="/posts/2025i.html"/>
      <url>/posts/2025i.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="保研资料：离散数学"><a href="#保研资料：离散数学" class="headerlink" title="保研资料：离散数学"></a>保研资料：离散数学</h2></div><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>笛卡尔积：设A,B是两个集合，所有有序对（x，y）做成的集合称为笛卡尔积。其中x来自A，y来自B。<br>关系：集合A<em>B</em>C的一个子集F称为A,B,C上的一个n元关系。存储：关系矩阵、关系图。<br>传递性：等价于R²包含于R。<br>空关系：反自反、对称性、反对称性、传递性；空集合上的额外多出自反性。可用谓词、蕴含式证明。<br>商集：以R的所有不同等价类为元素构成的集合。商集是集合的一个划分。<br>最大元是最小上界；在集合中的上界必是最大元。（最大元、极大元在集合中；上界未必在集合中）。极大元对有限部分序集必存在，但未必唯一。<br>完备的偏序集：有最小元、每一个链有上确界（或仅含有穷链）。<br>一个偏序集是一个全序集，如果它本身是一条链。<br>A包含于B，当且仅当A的幂集包含于B的幂集。<br><img src="/../../pictures/dm/img.png" alt="img.png"></p><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>G与其stolen范式S的可满足性、恒假性等价。<br>主合取范式（存在且唯一）、主析取范式（存在且唯一）；前束范式、skolem范式（首标中无存在量词、母式为合取范式）。<br>有限个短语的析取式：析取范式。主析取范式由极小项组成：一个短语包含所有原子，且排列顺序与原始顺序一致。<br>利用主合取范式、主析取范式可求解判定问题：判断命题公式是否等价、求公式的成真赋值和成假赋值、验证公式的恒假恒真性质。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>集合：确定性、互异性、无序性、元素多样。<br>鸽巢原理：将 n 个物体，划分为 k 组，那么至少存在一个分组，含有大于或等于 ⌈n&#x2F;k⌉ 个物品。<br>自然数、有理数与代数数：可数无穷，基数为阿列夫0。<br>证明可数无穷：和自然数一一对应、是可数无穷个可数集合的并集、能按照某种规律排序。<br>实数：不可数无穷。<br>康托尔基本定理：集合A的元素不能与A的所有子集建立1-1映射。<br>命题公式：谓词、量词、逻辑连接词、括号组成的字符串。如果不对符号做出解释，公式无真假可言。<br>解释：指定公式中原子的一组真值。<br>形式演绎法：根据基本的等价式和蕴含式。可以随便使用前提、随便使用逻辑结果。<br>命题：有真假意义的一句话。<br>谓词：定义在n个个体集合的笛卡尔乘积上，输出是1或0 的n元函数。谓词包含常量、变量、函数，是一个命题函数。零元谓词即命题，一元谓词描述性质，二元谓词描述关系。<br>谓词逻辑的改名规则：当同一个变量在不同的量词辖域中出现时，需要使用不同的名字；当一个变量既作为约束变元又作为自由变元出现时，需要将约束变元换名。改名的目的：为了规范使得个体变元要么以约束出现，要么以自由出现，方便前束范式化。<br><img src="/../../pictures/dm/img_1.png" alt="img_1.png"><br><img src="/../../pictures/dm/img_2.png" alt="img_2.png"><br><img src="/../../pictures/dm/img_3.png" alt="img_3.png"><br>命题逻辑的缺陷：无法表达量化关系；忽略命题内部结构，将原子命题视为不可分割的整体；难以表达关系命题。<br>什么是谓词逻辑：拆解原子命题，引入个体、谓词和量词，描述对象间的逻辑关系。<br>什么是命题逻辑：将完整陈述句视为不可分割的原子命题（如 P, Q），仅关注命题间的逻辑组合关系（与、或、非、蕴含、等价、异或、同或）。<br>幂集：原集合中所有的子集（包括全集和空集）构成的集合<br><img src="/../../pictures/dm/img_4.png" alt="img_4.png"></p><h3 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h3><p>通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路，具有欧拉回路的无向图称为欧拉图；通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路。具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。<br>1.对于无向图 G , G是欧拉图当且仅当 G 是连通的且没有奇度顶点。<br>2.对于无向图 G , G是半欧拉图当且仅当 G是连通的且 G中恰有 0个或 2个奇度顶点。<br>3.对于有向图 G, G是欧拉图当且仅当 G的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。G是半欧拉图时仅G是单向连通的，允许两个顶点入度出度相差1。<br>欧拉路未必是简单路，哈密顿路一定是简单路。</p><h3 id="数论、群环域请查询其他资料"><a href="#数论、群环域请查询其他资料" class="headerlink" title="数论、群环域请查询其他资料"></a>数论、群环域请查询其他资料</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs保研经验贴|英文面试</title>
      <link href="/posts/2025k.html"/>
      <url>/posts/2025k.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="保研资料：英文面试"><a href="#保研资料：英文面试" class="headerlink" title="保研资料：英文面试"></a>保研资料：英文面试</h2></div><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>Good morning, dear professors. I’m very honored to be here for this interview. My name is *** and I major in Cyberspace Security Engineering in XX University.I will introduce myself from the following three aspects:</p><p>First of all, I think studying is the most important thing in University.I’m hardworking and self-disciplined,so I am the thrid-ranked student in my major.Also, I was honor to have a The First Prize Scholarship and School Outstanding Student from  XX University.</p><p>Second, I also attached great importance to coding competition, to cultivate my competitiveness. During my sophomore year, I participated in the 49th ACM-ICPC National Invitational Competition in Kunming and won a national first prize. Through collaboration, I further developed my innovation skills, team spirit, and ability to write programs, analyse, and solve problems under pressure. After the competition, I also participate in the Blue Bridge Cup and won the national second prize.</p><p>Besides, I believe that having a postgraduate study is a challenging next step in my life. At the same time, I will learn related knowleges and skills quickly and start in-depth research,  striving to transform my accumulated knowledge into academic achievements.</p><p>All in all,  I am looking forward to becoming a graduate student at XXXX, thanks for your listening.</p><h3 id="为什么没有科研项目？"><a href="#为什么没有科研项目？" class="headerlink" title="为什么没有科研项目？"></a>为什么没有科研项目？</h3><p>During my first year of university, I had significant disadvantages in my coding skills. Thanks to my classmates,I futher developed a great interest in programming,and I actively trained my coding abilities during my second year and third year. I believe that coding skills and subject knowledge are important foundations for scientific research.</p><h3 id="为什么读研？"><a href="#为什么读研？" class="headerlink" title="为什么读研？"></a>为什么读研？</h3><p>I believe that postgraduate studies are very different from undergraduate studies and coding competitions, so I have set it as a challenging next stage in my life. At the same time, I believe that postgraduate studies can greatly improve the way I look at the outside world.</p><h3 id="为什么参加竞赛？"><a href="#为什么参加竞赛？" class="headerlink" title="为什么参加竞赛？"></a>为什么参加竞赛？</h3><p>Coding competitions are a pure and extreme process that focuses more on perfect results than on performance, and I enjoy the passion of competition under the dynamic rankings.At the same time, I believe that coding skills are important foundations for scientific research. I hope to do my best in this area to fully prepare myself for future scientific research.<br>Through collaboration, I further developed my innovation skills, team spirit, and ability to write programs, analyse, and solve problems under pressure.</p><h3 id="为什么选择本学校？"><a href="#为什么选择本学校？" class="headerlink" title="为什么选择本学校？"></a>为什么选择本学校？</h3><p>XXXX University is famous for its rigorous academic environment and its commitment to innvation, which aligns with my academic career goals. As one of the most famous universities in China, it provides people sufficient resource and guidence to fulfill their potential.So XXXX University is my goal all the time. If I am given a chance to further education in this university, I will definitely spare no effort to do research and improve myself.</p><h3 id="为什么选择本专业（major）？"><a href="#为什么选择本专业（major）？" class="headerlink" title="为什么选择本专业（major）？"></a>为什么选择本专业（major）？</h3><p>I chose computer science because I have a keen interest and passion for computers and technology, and I enjoy solving problems and creating things. At the same time, computer science is one of the fastest-growing industries in the world today, offering vast employment opportunities. Furthermore, computer science emphasizes innovation and creativity, which are values that I pursue.</p><h3 id="介绍你的本科学校？"><a href="#介绍你的本科学校？" class="headerlink" title="介绍你的本科学校？"></a>介绍你的本科学校？</h3><p>XX University is a key national university located in XX City, XX Province. Founded in XX, it was among the first batch of ‘Double First-Class’ universities.<br>The university has consistently adhered to its motto of ‘XXXX, XXXX,’ striving to become an important base with significant influence.<br>At the same time, as a comprehensive university, XX University covers a vast area, offers a wide range of disciplines, and has a strong faculty.</p><h3 id="介绍本科专业？"><a href="#介绍本科专业？" class="headerlink" title="介绍本科专业？"></a>介绍本科专业？</h3><p>The Cyberspace Security  trains students to become “guardians of the digital world”. We learn how to protect computers, networks, and our private data from hacker attacks and leaks. The major includes courses such as cryptography and network protocol analysis.</p><h3 id="介绍你的家乡？"><a href="#介绍你的家乡？" class="headerlink" title="介绍你的家乡？"></a>介绍你的家乡？</h3><p>XX, as the ‘XX’ of XX Province, is a city with a rich historical heritage and tremendous development potential.<br>It is home to many stories, such as the touching tale from the Red Army era, ‘XXXX’ which highlights the warmth and kindness of the local people.<br>XX also has abundant natural resources such as XX and XX.making it an ideal place to live.<br>Today, thanks to its  local resources, XX is rapidly become a key base for the XX industry.</p><h3 id="介绍你的家庭？"><a href="#介绍你的家庭？" class="headerlink" title="介绍你的家庭？"></a>介绍你的家庭？</h3><p>There are six people in my family: my parents, my grandparents, my sister, and me. My parents both work in XXXX.<br>I have lived in a loving family since childhood. My parents have given me enough care to make me a grateful, honest, hard-working person. My family members place great importance on family relationships, and they are very supportive of my continuing education.<br>I love my family, and I really hope that I can send them a good message about this interview.</p><h3 id="介绍你的优缺点？"><a href="#介绍你的优缺点？" class="headerlink" title="介绍你的优缺点？"></a>介绍你的优缺点？</h3><p>I believe my greatest strength lies in my ability to break down difficult situations into smaller problems and solve them step by step, striving for what I consider to be perfection. （This often takes a lot of time, and I often get caught up in it, so it is also my weakness.）<br>My shortcoming is that I don’t do well in speaking in public unless the topic is familiar. It’s hard for me to organize languages when faced with too many people.</p><h3 id="最喜欢的小说？"><a href="#最喜欢的小说？" class="headerlink" title="最喜欢的小说？"></a>最喜欢的小说？</h3><p>My favourite novel is 《the three body problems》.The novel tells the story of an alien civilization invading Earth and humanity’s continuous struggle against it.The novel not only explores the complex situations  but also raises questions about human existence and the meaning of the universe. So I learn a lot from the novel.</p><h3 id="最喜欢的课程？"><a href="#最喜欢的课程？" class="headerlink" title="最喜欢的课程？"></a>最喜欢的课程？</h3><p>My favorite course is Programming Language, which I took when I first entered university. It not only taught me how to write programs, but also laid the foundation for me to participate in coding competitions in the future. At the same time, I meet my best friends in this course,who also like coding competitions.<br>Operation System、Data Structure、Cyber networks、Constitution Principle of Computer。</p><h3 id="最擅长的课程？"><a href="#最擅长的课程？" class="headerlink" title="最擅长的课程？"></a>最擅长的课程？</h3><p>I am good at data structure.Data structure includes logical structure and storage structure. When we need to design an algorithm, it will be efficient if we choose a suitable data structure. Before this course, I had studied many data structures and algorithms and can apply them flexibly in programming exercises.</p><h3 id="最难的课程？"><a href="#最难的课程？" class="headerlink" title="最难的课程？"></a>最难的课程？</h3><p>I think the most difficult course was Constitution Principle of Computers. This is because it covers a lot of hardware-related specific implementations, and I did not achieve the expected score.</p><h3 id="最喜欢的事物？"><a href="#最喜欢的事物？" class="headerlink" title="最喜欢的事物？"></a>最喜欢的事物？</h3><p>In my daily life, I enjoy swimming and blogging. Swimming not only strengthens my body, but also helps relieve stress. I enjoy the feeling of refreshment that swimming offers. At the same time, I believe that blogging is a great way to express my inner world, and I can also use it to share my study notes with my classmates.</p><p>In terms of my studies, I am interested in coding competitions. Coding competitions are a pure and extreme process that focuses more on perfect results than on performance, and I enjoy the thrill of competition in the dynamic rankings.</p><h3 id="最熟悉、喜欢的算法？"><a href="#最熟悉、喜欢的算法？" class="headerlink" title="最熟悉、喜欢的算法？"></a>最熟悉、喜欢的算法？</h3><p>My favourite algorithm is the backtracking greedy algorithm. Unlike traditional greedy algorithms, it offers greater flexibility and strategic options. When a particular step does not result in the optimal outcome, we backtrack one step and try a different greedy strategy.</p><h3 id="最大的成就？"><a href="#最大的成就？" class="headerlink" title="最大的成就？"></a>最大的成就？</h3><p>I think the most successful experience is that  during my sophomore year, I participated in the 49th ACM-ICPC National Invitational Competition in Kunming and won a national gold award. This competition can be said to be the starting point of my programming competitions. And It gives me a lot of confidence and advantages in the fultrue.</p><h3 id="最喜欢的app？"><a href="#最喜欢的app？" class="headerlink" title="最喜欢的app？"></a>最喜欢的app？</h3><p>My favourite app is MuBu. I often use it to take notes and record my inspirations. It looks simple, but it has comprehensive functions.</p><h3 id="最感谢的人？"><a href="#最感谢的人？" class="headerlink" title="最感谢的人？"></a>最感谢的人？</h3><p>The person I am most grateful to is my friend. Whenever I face with difficulties in my studies or life, he always encourages me and gives me advice. At the same time, he and I participated in many algorithm competitions, and his success inspired me to keep moving forward.</p><h3 id="你的性格特点？（personality-characteristics）"><a href="#你的性格特点？（personality-characteristics）" class="headerlink" title="你的性格特点？（personality characteristics）"></a>你的性格特点？（personality characteristics）</h3><p>Firstly, I am a hardworking person. I always strive to achieve my goals and never give up easily. Secondly, I am quite rational and always remain calm, which helps me make the right decisions in my personal and professional life. More importantly, I am a patient person. When someone needs help, I always lend a helping hand.</p><h3 id="你认为本科期间的收获？"><a href="#你认为本科期间的收获？" class="headerlink" title="你认为本科期间的收获？"></a>你认为本科期间的收获？</h3><p>During my undergraduate studies, I established a preliminary cognitive framework and learned many perspectives and methods that will benefit me throughout my life. At the same time, I developed an interest in programming and decided to continue exploring it in the future.<br>Compared to when I first entered university, I have made significant improvements. I believe this is very valuable and encouraging, but I will continue to improve myself in the future.</p><h3 id="你认为的重要的品质？"><a href="#你认为的重要的品质？" class="headerlink" title="你认为的重要的品质？"></a>你认为的重要的品质？</h3><p>I believe there are three important qualities:<br>First is critical thinking: we need to analyse problems in a logical and rational way,that we can solve difficult problems well.<br>Second is adaptability: we should be able to respond flexibly to new situations, learn from new informations.<br>Third is lifelong learning: the world is changing all the time,only in this way can we become a better person.</p><h3 id="你感兴趣的研究方向、了解、前景看法？"><a href="#你感兴趣的研究方向、了解、前景看法？" class="headerlink" title="你感兴趣的研究方向、了解、前景看法？"></a>你感兴趣的研究方向、了解、前景看法？</h3><p>My current focus is cloud computing. It delivers computing services—like storage, processing, and software—over the internet, striving to offer greater and sonner computing. (I am interested in this technology.)<br>Cloud computing helps us do many things online. First, we can store things like photos or files there. Second, we can use programs online, like for email or writing, without installing anything. Third, it can run heavy programs online, like for big shopping sites or video services. Even if many people use them at once, they still work well.finally, you can work from anywhere if you have the internet. So, cloud computing makes things easier, cheaper, and lets things grow bigger when needed.<br>The cloud computing field will integrate AI and edge computing to achieve more intelligent, efficient services.</p><h3 id="你研究生阶段生涯规划？"><a href="#你研究生阶段生涯规划？" class="headerlink" title="你研究生阶段生涯规划？"></a>你研究生阶段生涯规划？</h3><p>During my postgraduate studies, I will first determine my research direction as soon as possible. Then, I will quickly learn the knowledge and basic skills. After mastering the basic knowledge and methods, I will begin in-depth research,  learning advanced content and  striving to transform my accumulated knowledge into academic achievements.<br>I hope to find a research field that I am truly interested in and good at during my postgraduate studies.</p><h3 id="你毕业后的规划？"><a href="#你毕业后的规划？" class="headerlink" title="你毕业后的规划？"></a>你毕业后的规划？</h3><p>After graduating from graduate school, I plan to join a core technology team or work  in a related vertical field to explore its specific value. At the same time, I will also consider my own abilities and decide whether to promote research in universities or scientific research institutions.</p><h3 id="ABaABa？"><a href="#ABaABa？" class="headerlink" title="ABaABa？"></a>ABaABa？</h3><p>I’m sorry，could you repeat the question？<br>Sorry, I don’t know the answer. It’s not the focus of the data structure course I’ve learned.<br>It doesn’t matter, because it shows that I need to continue to work hard in some aspects. Only by constantly improving myself can I make real progress.<br>Thank you for your question.I find a bit difficult to understand the question.Could you please simplify it?&#x2F;From my understanding,you are unquiring me about…<br>English plays an indispensable role both in my academic study and daily life.</p><h3 id="专业面？（即项目的具体细节、分工、贡献等）？"><a href="#专业面？（即项目的具体细节、分工、贡献等）？" class="headerlink" title="专业面？（即项目的具体细节、分工、贡献等）？"></a>专业面？（即项目的具体细节、分工、贡献等）？</h3><p><mark>THE MOST IMPORTANT PART</mark><br>建议同学们细细准备这一块</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs保研经验贴|线性代数</title>
      <link href="/posts/2025h.html"/>
      <url>/posts/2025h.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="保研资料：线性代数"><a href="#保研资料：线性代数" class="headerlink" title="保研资料：线性代数"></a>保研资料：线性代数</h2></div><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p>线性代数的基本问题：方程组求解、最小二乘、特征值、奇异值。线性代数是关于线性空间和线性映射的代数学。<br>线性映射（ linear mapping）是从一个向量空间V到另一个向量空间W的映射，且保持加法运算和数量乘法运算，而线性变换（linear transformation）是线性空间V到其自身的线性映射。<br>线性空间：V是一个非空集合，F是一个数域，定义加法和数乘，且满足八条公理化定义，则称V为F上的线性空间，V中元素称为向量。V中的极大线性无关组称为一个基，个数称为V的维数。<br>正定矩阵的所有顺序主子式的值大于0，特征值大于0。可逆变换保正定性。<br>二次型存在标准型及规范型。<br>二阶是指最高阶只有二阶即y”<br>常系数是指y”, y’,y前面的系数p,q是常数<br>线性是指微分方程中只包含y及其各阶导数的一次幂项（y’，y’‘）,或含这些一次幂项与x的各种运算组合构成的混合项。但是，不含y及其各阶导数的高次幂项,也不含y及其各阶导数之间的混合项。例如：只含ay、by’、cxy”一类的项,不含ayy、byyy、cyy’、fxyy”一类的项.（abcf为常数）。<br>齐次是指微分方程中不含常数项,也不含仅由x的各种运算组合构成的项（比如6x,2*sinx，3cosx等）；<br>微分方程：含有参数（如x）、未知函数y和未知函数导数（如y‘，y’‘）的方程。<br>矩阵可逆<br>矩阵可逆：满秩、列向量线性无关，行列式值不为0，可经过可逆变换变成E，伴随矩阵（代数余子式构成）可逆。<br>矩阵求逆：利用伴随矩阵、利用初等变换。</p><h3 id="合同，正交，相似"><a href="#合同，正交，相似" class="headerlink" title="合同，正交，相似"></a>合同，正交，相似</h3><p>合同：两矩阵是同一二次型在不同基上的对称矩阵。<br>正交矩阵：转置等于逆阵的矩阵，每一列均为单位向量，且任意两列向量的内积为0。正交变化下，可以将向量旋转而不改变其长度、之间的夹角。<br>相似的矩阵拥有相同的特征值、秩、行列式、特征多项式。<br>对于实对称矩阵（特征值都是实数），其特征向量相互正交，因而一定满足线性无关。故可利用正交矩阵实现相似对角化，一般的合同变换只保证正负惯性性质。<br>特征值和特征向量可以用于图像压缩、降噪和特征提取等领域。例如，主成分分析（PCA）方法就利用了特征向量来提取图像中的关键特征：我们可以通过保留最大的特征值对应的特征向量进行数据降维，从而捕捉数据的主要变化趋势。</p><h3 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h3><p>矩阵作为变换的本质是把一个基底下的东西变换到另一个基底表示的空间中。<br>一个线性变换矩阵作用在一个向量上之后，若变换后的向量保持方向不变，则该向量为特征向量，沿着这个方向伸缩的比例大小就是特征值。<br>矩阵所有的特征向量组成了这个向量空间的一组基底。<br>特征向量可以用于将矩阵对角化，从而简化线性变换的描述。这在计算中能够提高效率。<br>行列式和特征向量与所选坐标系无关。<br>矩阵的秩<br>矩阵的秩有什么应用：判断线性方程组的解的情况。应用：图像压缩，秩越低，图像越模糊。<br>矩阵的秩是：行阶梯形非零行的数量、最大非零r阶子式、极大线性无关组的数量、非零特征值的数量、维数。<br>满秩：有n个互异特征值，或k重特征值对应k个线性无关的特征向量，或为对称矩阵。</p><h3 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h3><p>Cramer法则局限性：行列式值不为0，且为方阵。<br>秩为r的齐次线性方程组，其n-r个线性无关的解向量构成一个基础解系。<br>列满秩矩阵的齐次线性方程组仅有零解。<br>方程组有解：秩&#x3D;增广矩阵的秩。<br>极大线性无关组：向量组A0线性无关，且能表示向量组A中任一向量。<br>两个向量线性相关等价于对应分量成比例。</p><h3 id="Laplace定理"><a href="#Laplace定理" class="headerlink" title="Laplace定理"></a>Laplace定理</h3><p>计算行列式：拉普拉斯展开、转化为特殊矩阵、逆序数法</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs保研经验贴|概率论与数理统计</title>
      <link href="/posts/2025j.html"/>
      <url>/posts/2025j.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="保研资料：概率论与数理统计"><a href="#保研资料：概率论与数理统计" class="headerlink" title="保研资料：概率论与数理统计"></a>保研资料：概率论与数理统计</h2></div><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>无偏性：估计量的无偏性指的是，估计量的数学期望等于被估计参数的实际值。<br>一致性：在样本容量逐渐增大的情况下，估计值会越来越接近参数的真实值。<br>有效性：估计量的有效性指的是最小方差的无偏估计，估计量的方差越小，则该估计量越有效。<br>概率：对于每一个事件A，有唯一的实数与其对应，且满足非负性，规范性（必然事件&#x3D;1），可列可加性（两两不相容）。<br>古典概型：基本事件有限等可能。<br>伯努利概型：重复n次独立试验，每次实验只有两个可能结果。泊松定理：伯努利实验中稀有事件出现的次数近似满足泊松分布。<br>离散分布（对应分布律）：均匀、0-1、二项（随机变量为事件发生的次数）、几何、泊松。<br>连续型分布（对应概率密度）：均匀分布、正态分布、指数分布。当f(x,y)、fY(y)连续时，可求得X的条件概率密度函数。<br>数学期望：对于随机变量而言，指的是在其概率意义下的加权平均值。<br>方差：反映随机变量取值的波动程度，是随机变量与其数学期望差值平方的数学期望<br>三阶中心矩，偏度，衡量偏离中心的点的位置情况，均值和中位数之间的距离。<br>四阶中心矩，峰度，衡量偏离中心的点的密集程度。<br>变量和随机变量：变量是指可变的量，而随机变量的取值不仅可变，还在此基础上对每一个取值赋予了一个取到的概率。<br>贝叶斯公式：描述了后验概率与先验、似然概率之间的关系，利用先验和似然概率求解后验概率。应用：进行垃圾邮件过滤；通过将病人的先验概率与各种医学测试的似然度相结合，可以计算出某种疾病的后验概率，辅助医生进行诊断和预测。<br>全概率公式：将对复杂事件的概率转化为在不同情况下发生简单事件的概率的求和。<br>样本点：对于随机试验，把每一个可能的结果称为样本点。<br>随机事件：某些样本点的集合。<br>样本空间(或必然事件)：所有样本点构成的集合，记作 Ω。<br>样本：与总体X有着相同概率分布，且相互独立的随机变量。<br>试验：满足可重复性、可观测性、随机性。<br>连续型随机变量的概率密度函数：是描述这个随机变量的输出值，在某个确定的取值点附近的可能性的函数。<br>泊松分布：常用于对小概率事件进行建模，适合于描述单位时间内随机事件发生的次数。参数λ是单位时间(或单位面积)内随机事件的平均发生次数。<br>指数分布中，研究随机事件发生间隔，所以对应随机事件的期望是单位时间发生次数的倒数。<br>卷积：平滑操作、提取图片特征、计算存量。<br>协方差 cov(X, Y) 定义为两个随机变量X和Y偏离其期望值的乘积的期望，即cov(X,Y) &#x3D; E[(X - E[X])(Y - E[Y])] 。<br>大数定律：依概率收敛；当样本数据无限大时，样本均值趋于总体均值，事件 A 发生的频率逼近于它的概率。切比雪夫（独立，有期望有方差，方差有上界，样本均值→总体均值），伯努利（频率→概率），辛钦（独立同分布，有期望可无方差，样本均值→期望）。<br>依概率收敛：随机变量序列Xn在n很大时，接近常数a。<br>切比雪夫不等式给出了随机变量与其期望值之间的偏离程度的一个上界。<br><img src="/../../pictures/ptms/img.png" alt="img.png"><br>独立同分布，有期望有方差的中心极限定理：当样本量 n 逐渐趋于无穷大时，n 个抽样样本的均值的频数、多个随机变量的总和（或平均值）逐渐趋于正态分布。<br>依分布收敛：对于随机变量序列Xn的分布函数Fn(x)的每一个连续点，在n很大时，等于F（x）。<br>统计量：不含任何未知参数的样本函数。<br>样本均值和样本方差独立。<br>点估计：构造出适当的统计量，用其观测值来估计未知参数。<br>矩估计：根据辛钦大数定律，当样本数足够多时，样本的原点矩收敛于总体的原点矩。步骤：选取k阶矩、计算估计量、解方程。<br>最大似然估计：概率最大的事件在一次试验中最可能出现。对给定样本观测值的一个关于未知参数的函数：似然函数。<br>假性检验：提出原假设，选取检验统计量，确定拒绝域，根据样本值计算观测值，对实际问题进行分析，如果发生小概率事件，则拒绝原假设。<br>三大分布作用：进行区间估计、假性检验时需要避免使用未知的参数，故不同的统计量适用于不同的情况；且相同置信度&#x2F;显著性水平下，置信度区间长要尽可能小以减小估计误差，拒绝域要尽可能大以覆盖更多极端值，降低第二类错误。 总是控制犯第一类错误的概率不超过显著性水平（小概率事件）。<br>接受域与置信区间相同。用统计量推断参数时，如果参数未知，则这种推断叫参数估计——用统计量估计未知的参数；如果参数已知（或假设已知），需要利用统计量检验已知的参数是否靠谱，此时的统计推断即为假设检验。<br>区别：区间估计是根据样本资料去估计总体未知参数的可能范围，假设检验是根据样本资料来检验对总体参数的先验建设是否成立；区间估计立足于大概率，通常以较大的把握(1-a)去估计总体参数的置信区间。而假设检验立足于小概率，通常是给定很小的概率 a 去检验对总体参数的先验假设是否成立。假性检验倾向于接受原假设，即接受明确参数的“真”，而第一类错误就是“弃真”。<br>正态分布性质：对称性， 唯一峰值，分布范围无界，标准差决定形状，约有99.7%的观测值落在三个标准差范围内。<br>联合分布的性质：考虑其边缘分布、条件分布。<br><img src="/../../pictures/ptms/img_1.png" alt="img_1.png"></p><p>相互独立：P（XY）、F（XY）、f（XY）<br>不相关：E（XY）、D（X+Y）</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs保研经验贴|数据结构</title>
      <link href="/posts/2025d.html"/>
      <url>/posts/2025d.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="保研资料：数据结构"><a href="#保研资料：数据结构" class="headerlink" title="保研资料：数据结构"></a>保研资料：数据结构</h2></div><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>按某种逻辑关系将一批数据元素组织起来，按一定的存储方式将它们存储起来，并在这些数据元素上定义一个操作集合,就得到了一个特定的数据结构。</p><h3 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h3><p>逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。<br>线性结构：线性表。只有一个始末，每个内节点只有一个前驱和后继。线性表：数组，链表，栈，队列<br>非线性结构：层次结构（树，叶节点可能有多个）、网状结构（图）、集合。节点可能有0、多个前驱和后继。</p><h3 id="数据的存储结构"><a href="#数据的存储结构" class="headerlink" title="数据的存储结构"></a>数据的存储结构</h3><p>数据结构在计算机中的表示，也称物理结构。分为：顺序存储、链接存储、散列存储、索引存储。<br>邻接表：顺序存储的顶点表+链接存储的边链表。邻接表利于找邻接顶点。</p><h3 id="数据结构的使用"><a href="#数据结构的使用" class="headerlink" title="数据结构的使用"></a>数据结构的使用</h3><p>跳表：logn层有序链表，最底层包含所有元素。插入后以1&#x2F;2递减的概率向上插入，适合动态查找场景。实现方式：四联表。<br>拉链法很长时，使用红黑树。<br>哈希表用途：bool过滤器。<br>树是分层结构，图是网络模型结构；树有根节点，图没有根节点的概念；树的边数为节点数减一，图的边数没有限制；树不能有环，图可以有。<br>红黑树中的每一个结点的颜色不是黑色就是红色。根结点和所有外部结点（NULL节点、叶节点）的颜色是黑色。红父黑子；所有从根到外部结点的路径上都有相同数的黑色结点数量。对于红黑树查找、插入、删除的最坏时间复杂度为O(logn)，最多3次旋转。最长路径的长度是最短路径（仅黑节点）的2倍。任何节点的左右高度最多相差2倍。<br>自平衡二叉查找树：在平衡度（查找效率）和平衡成本（增删效率）间选择。<br>简单回路：起点和终点相同，且路劲长度至少为2（三个点）。<br>同时使用按秩合并、路径压缩，每个操作的均摊复杂度接近O（1）。<br>AOV网(Activity On Vertex):顶点表示活动或任务(Activity),有向边表示活动(或任务)间的先后关系。应是一个有向无环图（DAG）。拓扑序列：AOV网中所有顶点排成一个线性序列。<br>AOE网(Activity On Edges):有向边表示活动或任务(Activity), 用边上的权值表示活动的持续时间,顶点称为事件(Event)。求关键活动：先求出事件（点）的最早开始时间和最晚开始时间，再求活动的最早开始时间（等于源点的最早开始时间）和最晚开始时间（等于汇点的最晚开始时间-边长）。<br>与AVL树相比，红黑树平衡性略弱，故查找效率略低。但插入、删除引起失衡的概率也较小，故插入删除效率更高，维持平衡的成本更低。<br><img src="/../../pictures/cs_exp/ds/img_5.png" alt="img_5.png"></p><h3 id="时间复杂性"><a href="#时间复杂性" class="headerlink" title="时间复杂性"></a>时间复杂性</h3><p>基本运算：算法中起主要作用且费时最多的操作。<br>时间复杂性：算法中基本运算的次数，往往是问题规模的函数。<br>均摊时间复杂度：n次操作的总代价分摊至各操作，均摊时间复杂度考虑了各操作间的关联，且不对输入情况的分布作假设。<br><img src="/../../pictures/cs_exp/ds/img_1.png" alt="img_1.png"></p><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><p>栈：进制转换、括号匹配，计算表达式，存储网页浏览顺序、存储函数参数。<br>中缀表达式转后缀：利用运算符栈：当运算符优先级＞栈顶运算符优先级时，压栈。否则，弹栈到栈空、或优先级关系改变、或栈顶为左括号。数字直接压入表达式。<br>队列：调度度列、缓冲区队列</p><h3 id="消除递归"><a href="#消除递归" class="headerlink" title="消除递归"></a>消除递归</h3><p>尾递归转循环；<br>利用栈模拟递归过程；<br>转为递推关系式。</p><h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><p>dijstla，floyd，A*，bfs，dfs，flod</p><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p><img src="/../../pictures/cs_exp/ds/img_4.png" alt="img_4.png"></p><h3 id="最小支撑树"><a href="#最小支撑树" class="headerlink" title="最小支撑树"></a>最小支撑树</h3><p>最小跨边一定在最小支撑树里。否则，因为支撑树T是连通的，故两个集合间必有一条路径，这条路径一定包含一条跨集合边。</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树是一种数据结构，它是由n（n&gt;&#x3D;1）个有限节点组成一个具有层次关系的集合，连通无回路、有n-1条边。<br>树的存储：顺序存储-孩子表示法、双亲表示法、先根&#x2F;后根&#x2F;层次+度表示法、左儿子-右兄弟表示法。<br>树的应用：哈夫曼树、表达式树、网页与DOM树、语法树、博弈树、并查集。<br>满二叉树：叶在最后一层、非叶结点都有两个子节点。<br>完全二叉树：层次顺序下，T的所有节点恰好对应同高的满二叉树的前n个节点。叶子结点只在最后两层、最底层叶子结点都在最左边、有右孩子的前提是有左孩子。非叶节点有n&#x2F;2个。<br>线索二叉树：把空指针利用起来，指向前驱或后继。需要增加标志位，来表明是否有左右孩子。中根后继：有右孩子时，为右孩子的中根首节点；否则为将p包含于其左子树的最低祖先。<br>树转二叉树：1，所有兄弟连线、仅留和左孩子的连线。（右兄弟变右孩子）<br>二叉树转树：1.节点连左孩子的右孩子、去掉和右孩子的连线。（右孩子变右兄弟）<br>任一树&#x2F;森林对应一棵二叉树，二叉树对应唯一的树&#x2F;森林。森林的先根序列和对应的二叉树先根序列相等，后根序列与对应二叉树的中根序列相等。<br>加权路径长度WPL：外节点的权值*深度之和。所有扩充二叉树中，WPL最小的称为最优二叉树。<br>二叉树的重建：中根序列和任意一种序列都可以确定唯一一棵二叉树。<br><img src="/../../pictures/cs_exp/ds/img.png" alt="img.png"></p><h3 id="B和B-树"><a href="#B和B-树" class="headerlink" title="B和B+树"></a>B和B+树</h3><p>外存访问次数取决于查找树高度。<br>引入B树的原因：若普通二叉树作为文件系统的索引，随着数据的插入，发现树的深度会变深。而文件系统的索引在磁盘上，磁盘的数据要加载到内存中才能处理，需要反复IO影响查询的效率，于是引入了B树可以作为文件系统的索引。<br>尽量让B树每个节点大小接近一个磁盘块的大小。<br>B树是多叉树，一棵m阶B树的性质：每个非根节点最多m-1个关键字，最少ceil(m&#x2F;2)-1个关键字；最多有m个分叉，最少有ceil(m&#x2F;2)个分叉；根节点最多m-1个关键字，最少1个关键字；最多有m个分叉，最少有2个分叉。所有的失败结点（叶子节点）都位于同一层，不包含任何信息。B树每个节点可以存放键值和数据。所有结点的平衡因子都为0，叶子结点均在最后一层，倒数第二层称为终端结点。<br>引入B+树的原因：由于B树每个节点存放数据，而数据相比关键字占用的空间较大，会导致每个磁盘块存放的索引项的记录会变少。B+树的非叶子节点不存放数据，只存放指针和关键字，这样每个磁盘块就可以存放更多的记录。这样深度会减小很多，加快了IO速度。<br>一棵m 阶的B+树需满足下列条件：每个非根节点最多m个关键字，最少ceil(m&#x2F;2)个关键字；最多有m个分叉，最少有ceil(m&#x2F;2)个分叉。根节点最多m个关键字，最少1个关键字；最多有m个分叉，最少有1个分叉。结点的子树个数与关键字个数相等。所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来。所有分支结点（可视为索引的索引）中仅包含它的各个子结点中关键字的最大值及指向其子结点的指针。<br>在数据库中，B+树常被用作索引结构，用于快速查找和排序大量数据。如主键索引、唯一索引、辅助索引等。在文件系统中，B+树通常用于管理磁盘上的文件块和索引节点。树的高度意味着需要进行多少次I&#x2F;O操作，高度越少，需要进行的I&#x2F;O次数相应越少。<br>简要说说B树和B+树的区别。<br>B+树的关键码存储的是其对应子结点中关键码的最大值，利用了分块查找的思想，而B树则是利用了二分查找的思想；<br>m阶B树和B+树：B树的根节点关键字个数取值1到m-1，B+树的根节点关键字取值1到m；B树非根节点关键字取值ceil(m&#x2F;2)-1到m-1，B+树非根节点关键字取值ceil(m&#x2F;2)到m。B树分叉个数等于关键字个数+1，B+树分叉个数等于关键字个数。<br>B树的每个节点既有关键字，又有数据；B+树的数据只在叶子上，非叶子节点只有关键字。<br>B+树的叶子节点相互之间有一个链路，可以实现范围查找（通过索引结点的索引遍历）。<br><img src="/../../pictures/cs_exp/ds/img_6.png" alt="img_6.png"><br><img src="/../../pictures/cs_exp/ds/img_7.png" alt="img_7.png"><br><img src="/../../pictures/cs_exp/ds/img_8.png" alt="img_8.png"></p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>按规定的顺序，以关键词为依据，对文件内诸多记录进行排列的过程。<br>关键运算：关键词比较次数、数据移动次数。<br>稳定性。<br>分为内排序、外排序；基于关键词比较的排序、分布排序；平方阶、线性对数阶、线性算法（不依赖关键词比较）。<br>希尔排序：开始时增量值较大 , 每组中的元素较少 , 插入排序速度较快 ; 随着增量 值逐渐变小 , 大多数元素已基本有序，而插入排序在元素接近有序时速度快。<br>堆排序：非连续元素访问；归并排序：需要On的额外空间；分布排序：需要更多额外的空间。<br>归并排序的特点使其非常适用于外部排序，即当排序的数据量太大无法完全加载到内存时，可以通过分阶段地读取和写入数据进行排序。归并排序的时间复杂度始终保持在O(nlogn)，无论是最佳、最坏还是平均情况下。<br>堆：完全二叉树（结构性）、堆序性。<br>桶排序和计数排序：m个桶或数组长度，时间复杂度O（n+m）。基数排序：O（d（n+r））<br><img src="/../../pictures/cs_exp/ds/img_2.png" alt="img_2.png"><br><img src="/../../pictures/cs_exp/ds/img_3.png" alt="img_3.png"></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。<br>尽管快速排序在最坏情况下的性能可能较差，但在大多数情况下，它的平均时间复杂度要比归并排序低。相比于归并排序，快速排序的实现更为简洁，代码量更少。<br>C++ 模板有很强的 inline 优化机制，比较操作相对于赋值（移动）操作要快的多（尤其是元素较大时）。归并排序的比较次数小于快速排序的比较次数，而移动次数一般多于快速排序的移动次数。<br>归并排序在执行时会将数组分割成多个小块，然后将这些小块递归地排序并合并。尽管分割过程对局部性影响不大，但合并过程需要将数据从不同的内存位置读取并写入临时数组，这种非连续的内存访问模式可能导致较差的缓存性能。<br>优化：子数组长度≤16时，退出递归，最后进行一次插入排序；递归深度到达logn时，进行堆排序；三数取中（或随机算法，省时且降低最坏情况发生概率）；先递归处理短区间，后循环处理长区间（降低空间复杂度为logn）。</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>顺序查找、对半查找、斐波那契查找、插值查找（假设元素均匀分布，通过线性插值预测mid，平均loglogn，最坏On。缺：但引入了乘除运算，受元素分布影响。应用：先插值查找到一定的范围）。<br>二叉搜索树、AVL树、红黑树、B树。<br>哈希函数。<br>二分缺点：适合有序数组，不适合有序链表；静态查找。</p><h3 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h3><p>便于快速计算、极少出现冲突（尽可能均匀分布）。以空间换时间，装载因子不应该超过一半。最坏O（n）。且查找失败后，仅能得到关键词不在表中。<br>拉链法（效率最高，易于删除）、线性探查（很好的空间局部性）、二次&#x2F;双重探查（避免聚集）。<br>删除后：考察位置j+1到下一个空位前的元素，是否阻碍查找T[i]。<br>或用lazy Deletion统计访问次数，删除后按访问次数递减的顺序重新插入。<br>数组的存储结构<br>非压缩存储：行优先、列优先；<br>压缩存储：对称矩阵、上下三角、三对角、稀疏矩阵（三元组、十字链表）。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs保研经验贴|操作系统</title>
      <link href="/posts/2025a.html"/>
      <url>/posts/2025a.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="保研资料：操作系统"><a href="#保研资料：操作系统" class="headerlink" title="保研资料：操作系统"></a>保研资料：操作系统</h2></div><h3 id="OS实现什么？"><a href="#OS实现什么？" class="headerlink" title="OS实现什么？"></a>OS实现什么？</h3><p>有效地管理系统中软件硬件资源（处理器、存储、设备、文件）；提供计算机用户与计算机硬件之间的接口，使计算机系统更易于使用。<br>操作系统特性：并发性、共享性、异步性、虚拟性（虚拟存储管理技术扩充内存空间；虚拟设备管理把独占型设备改造成共享的设备。）。<br>PSW：CPU运算器的一部分，存放两类信息：一类是体现当前指令执行结果的各类状态信息，如有无进位、有无溢出、结果正负、结果是否为0等；一类是存放控制信息，如允许中断、屏蔽字、中断码等。<br>并发进程：间断性、非封闭性、不可再现性。并发执行的条件：Bernstein条件。<br>软件互斥算法一般适用于单处理机系统，多机环境下可并行执行的指令的效果可能是重排序执行的结果，会不满足互斥性。<br>硬件互斥：存储障碍、原子变量、测试并设置、交换、关中断（仅在单CPU有效）。多CPU下, 指令周期间交叉, test_and_set, swap指令不是原子的。<br>同步机制：信号量与PV操作、管程、会合（被调用者代调用者执行调用代码，适合分布式环境）、事件。<br><img src="/pictures/cs_exp/op/img_10.png" alt="img_10.png"></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>特征：并发性、动态性、独立性（可以调度）、交互性、异步性（进程各自独立的速度向前推进）、结构性（拥有PCB）。<br>执行中的程序。当进程发生进程切换时，需要将现场信息（PSW、PC）弹出，保存于PCB中。<br>多道程序：考虑设备、内存、处理器资源的管理问题。<br>进程：由进程映像（代码+数据）、进程控制块组成。<br>上下文：PCB、程序、系统环境（系统栈、打开文件表）。<br>中断嵌套时，栈内压入PSW、PC、中断处理程序用到的寄存器、中断处理程序的返回点、参数、返回值等。<br>进程间互斥、同步、信息交换统称为进程通信。<br>进程创建、撤销过程：向系统申请一个空闲PCB、为新进程分配资源、初始化新进程的PCB、加载程序、将PCB入就绪队列。<br>一个进程包含多个线程；线程通信容易、系统开销小。<br>Fork：复制地址空间、复制控制结构。<br><img src="/pictures/cs_exp/op/img_3.png" alt="img_3.png"></p><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>①进程是程序在其自身地址空间中的一次执行活动，是资源分配的基本单位；<br>②线程是进程中一个相对独立的执行流，一个进程包含多个线程，是调度的基本单位；<br>③进程是拥有资源的一个独立单位，有自己独立的地址空间；线程不拥有系统资源，但可以访问隶属于进程的资源，共享进程的地址空间（通讯容易）；<br>④在系统开销上，进程的系统开销大于线程；线程切换速度快；线程通讯容易。<br>⑤线程出错时，属于一个进程的其他线程也无法正常运行。<br>⑥相同：都是实现多任务并发的技术手段、都可以独立调度，父子进&#x2F;线程调度时平等竞争<br>线程的应用：内在的多控制流，具有合作性质,需要共享数据；如每个http请求，对应一个线程。<br><img src="/pictures/cs_exp/op/img_2.png" alt="img_2.png"><br>交互式作业，不需要像批处理作业那样把作业控制意图预先写成一份作业控制说明书。Unix下，对于非内部命令，会建立子进程。</p><h3 id="内核线程、系统进程"><a href="#内核线程、系统进程" class="headerlink" title="内核线程、系统进程"></a>内核线程、系统进程</h3><p>内核线程没有用户栈，只在系统态运行；<br>用户线程无法进入内核态，需要一个内核线程帮其实现调用；<br>系统进程：假脱机输入进程、假脱机输出进程；<br>系统进程包含核心线程，只运行在核心态。</p><h3 id="进程的调度性能指标有哪些？"><a href="#进程的调度性能指标有哪些？" class="headerlink" title="进程的调度性能指标有哪些？"></a>进程的调度性能指标有哪些？</h3><p>CPU利用率、系统吞吐量、周转时间、平均周转时间、等待时间、带权周转时间&#x3D;作业周转时间&#x2F;作业实际运行的时间（带权周转时间越大，说明相对等待得越久）、平均带权周转时间。<br>调度算法：先来先服务、短作业优先、最短剩余时间优先、最高响应比优先、最高优先数（动态静态）、循环轮转、多级队列、反馈排队；<br>实时：最早截止期调度（可剥夺）、速率单调调度（优先调度频率最高的实时任务）<br>多处理器：自调度、组调度（将相关线程同时分配到多处理机，避免相互等待）<br><img src="/pictures/cs_exp/op/img_9.png" alt="img_9.png"></p><h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><p>管道（也称作共享文件，简单、界面统一、延迟写策略）、消息队列（也称作消息传递，分为有缓冲和无缓冲）、共享内存（也称作共享存储）、信号量和 PV 操作、信号（进程收到信号后执行signal函数，是用户处理的中断）、套接字（Socket）。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>一组进程中的每一个进程，均无限期地等待此组进程中其它进程所占有的，因而永远无法得到的资源，这种现象称为进程死锁。<br>调度时机不合适，竞争，进程通讯，可能造成死锁。<br>必要条件：资源独占、不可剥夺、保持申请、循环等待。当每类资源只有一个实例时， Coffman条件为充要条件。<br>死锁检测时刻：只检测占有资源的进程，他是所有进程的子集。针对request数组而非need数组。检测时间：等待时检测、定时检测、资源利用率下降时检测。<br>死锁恢复：重启、剥夺资源、进程回退、终止进程。<br>忙式等待条件下发生的饥饿,称为活锁(live lock). 死锁进程等待永远不会释放的资源, 饿死进程等待可能被释放,但却不会分给自己的资源,其等待时间没有上界。死锁至少涉及两个进程, 饿死进程可能只有一个。死锁一定发生了循环等待,饿死不然。<br>发生死锁 等价于 资源分配图约减后仍然存在环。对于资源分配序列来说，即便出现环，也需要进一步判断进程能否同时推进到成环时刻。</p><h3 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h3><p>存储分配（分配表、空闲表）、存储共享、存储保护（检查越界和越权）、存储扩充（内存、外存结合）、地址映射、（程序段的动态连接）<br>内存页框分配：平均分配、按长度分配、按优先级分配。同时有交换技术、覆写技术来缓解空间。<br>解决颠簸：工作集模型、页故障率反馈模型。<br>外存页框分配：静态分配（调入后不在外存删除）、动态分配。<br>二维地址：因为段号所占的位数不确定，只给出一个逻辑地址，无法得到其段号。<br>静态等长：字位映象图、空闲页面表、空闲页面链（对于外存页面的分配和去配均需执行一次数据传输，速度较慢）。<br>动态异长：空闲区域表（最先适应、下次适应、最佳适应、最坏适应）<br>置换算法：最佳淘汰法、先进先出、最近最少使用（LRU）、最不经常使用的先淘汰（LFU）、最频繁使用的淘汰、最近不用的先淘汰（引用位、修改位。定时清零引用位）、时钟算法、带修改标志的时钟算法<br>影响缺页的因素：淘汰算法、页框数、页大小、程序本身。<br><img src="/pictures/cs_exp/op/img_4.png" alt="img_4.png"><br><img src="/pictures/cs_exp/op/img_5.png" alt="img_5.png"></p><h3 id="磁盘存储管理有哪些方法？"><a href="#磁盘存储管理有哪些方法？" class="headerlink" title="磁盘存储管理有哪些方法？"></a>磁盘存储管理有哪些方法？</h3><p>主要有三种方法，分别是连续分配、链接分配和索引分配。<br>连续分配：要求每一个文件分配一组相邻接的盘块，访问速度快，但是必须事先知道文件的大小；<br>链接分配：分为隐式链接和显示链接，隐式链接是指在每个目录项中都含有指向链接文件第一盘块和最后一个盘块的指针，每个盘块都有指向下一个盘块的指针，显示链接是指把用于链接文件各物理块的指针都存放在内存中的一张链接表中。它不支持随机访问，但是利于文件的动态增长；<br>索引分配：分为单级索引分配以及多级索引分配。它为每个文件分配一个索引表，把分配给该文件的所有盘号都记录在该索引块中。它不能支持高效的直接存取。</p><h3 id="虚拟内存的定义"><a href="#虚拟内存的定义" class="headerlink" title="虚拟内存的定义"></a>虚拟内存的定义</h3><p>虚拟内存是一种计算机系统内存管理技术，使得应用程序认为它拥有连续的可用内存（一个连续完整的地址空间），而实际上，这些内存通常被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。虚拟存储系统是忽略了主存与辅存的差异，将其都看作是主存。</p><h3 id="虚拟内存的工作原理"><a href="#虚拟内存的工作原理" class="headerlink" title="虚拟内存的工作原理"></a>虚拟内存的工作原理</h3><p>当进程开始运行时，系统会将一部分程序装入内存，另一部分暂时留在外存。当需要执行的指令不在内存时，系统会自动将它们调入内存；当内存不足时，系统会选择部分内存空间，将其中的内容交换到磁盘上，并释放这些内存空间供其他进程使用</p><h3 id="虚拟内存有什么好处？"><a href="#虚拟内存有什么好处？" class="headerlink" title="虚拟内存有什么好处？"></a>虚拟内存有什么好处？</h3><p>使得大的程序能在较小的内存中运行、使得多个程序能在较小的内存中运行、局部装入内存利用了局部性，且进程与进程是相互隔离的，提高了系统的安全性。<br><img src="//picturescs_exp/op/img.png" alt="img.png"><br><img src="/pictures/cs_exp/op/img_1.png" alt="img_1.png"></p><h3 id="分页的好处是什么，分页和分段有什么区别？"><a href="#分页的好处是什么，分页和分段有什么区别？" class="headerlink" title="分页的好处是什么，分页和分段有什么区别？"></a>分页的好处是什么，分页和分段有什么区别？</h3><p>分页的好处：</p><p>（1）实现了虚拟内存：分页将进程的逻辑地址空间划分为固定大小的页，并将物理内存也划分为相同大小的页框。这样，每个进程只需要将所需的页加载到物理内存中，而不需要一次性加载整个进程。</p><p>（2）内存利用率高：分页可以更灵活地分配内存，当进程的大小不是固定的且不规则时，分页可以更好地利用内存空间，减少内存碎片的产生。</p><p>（3）页表简单：由于页的大小是固定的，页表可以更加简单有效地实现。</p><p>分页和分段的区别：</p><p>（1）分页以固定大小的页作为单位进行管理，而分段以逻辑段作为单位进行管理。分页的大小是固定的，由操作系统指定；而分段的大小是可变的，由程序员决定。</p><p>（2）由于分页使用固定大小的页，会产生内部碎片，而分段可以更好地适应变长的逻辑段，避免内部碎片，但会产生外部碎片。</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件和管理信息资源的程序集合称为文件系统，提供按名存取的手段。<br>文件共享方式：公共目录、连接。<br>分为主部次部：提高查找速度、实现文件连接。<br>分为普通文件、目录文件（文件名，文件号序列）、特殊文件。<br>记录式文件：信息项是记录，记录的序列。文件头保存记录长度和数量等说明信息。物理组织形式：考量空间开销、访问速度、长度变化：顺序、链接、索引、散列、倒排（以键值和记录地址构成的索引结构）。<br>多级目录：便于文件分类、查找速度快、可以实现文件连接（节省空间+通讯）。<br><img src="/pictures/cs_exp/op/img_6.png" alt="img_6.png"><br>Unix内存映射文件：以访问内存的方式访问文件。解决文件IO慢、访问前打开、访问经过表的问题。通过局部映射实现对大文件的访问；将不必再对文件执行I&#x2F;O操作。</p><h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><p>分配去配、设备驱动、缓冲管理。<br>分为存储型设备、IO型设备、网络设备。<br>接口（设备控制器）：识别命令、数据交换、地址识别、数据缓冲。<br>IO端口：接口中的可被CPU访问的寄存器，主要有数据寄存器、状态寄存器、控制寄存器。<br>通道类型：字节多路通道（时间片轮转，低速IO）、数组选择通道、数组多路通道（时间片轮转）。通道包含通道程序、CAW、CCW、CDW、CSW。一个通道能控制多种设备。<br>系统调用处理程序:进行设备保护，禁止用户直接访问设备；将逻辑设备名映射为物理设备名<br>设备驱动程序：实现物理I&#x2F;O操作的启动和执行<br><img src="/pictures/cs_exp/op/img_7.png" alt="img_7.png"><br><img src="/pictures/cs_exp/op/img_8.png" alt="img_8.png"><br>磁头引臂调度：先到先服务、最短时间优先、电梯算法（存在地域差别）、循环扫描（地位相同；磁头粘性）、N-扫描、冻结扫描<br>缓冲：处理数据到达与离开速度不一致所采用的技术。通过增加缓冲区的个数，可使并行程度得到明显提高。<br>缓存：将慢速存储器上活动信息缓冲到快速存储设备上的技术。<br>虚拟设备：在一类物理设备上模拟另一类物理设备的技术。利用共享型设备实现的数量较多、速度较快的独占型设备，将独占型设备转化为共享设备。用户都感到独占了一台设备。<br>在进程与独占型设备之间增加共享设备缓冲。提高了设备的利用率，且能够立即满足进程的需求。</p><h3 id="UNIX"><a href="#UNIX" class="headerlink" title="UNIX"></a>UNIX</h3><p>Unix采用可抢占的动态优先调度算法，优先数越大，优先级越低（系统进程优先级高）。<br>进程互斥使用关中断；<br>采用事件同步；<br>采用双对界管理；<br>分配算法为最先适应算法；<br>采用工作集模型；<br>页面置换算法为二次机会法；<br>普通文件：512B为一块的顺序存取的流式文件，物理结构为链接+索引，分为零级索引和一级、二级、三级索引：即节省空间，又提高速度<br>空闲磁盘空间管理：成组连接，空闲块链+空闲块表<br>管理内存中的空闲页框：伙伴堆算法，针对内存碎片问题而提出的一种稳定高效的分配策略；按前后顺序以2i个页面作为一个块组，与其相邻的2i个页面作为另一个块组，那么这两个块组合为一对Buddy.<br>特殊文件：1.与文件界面统一；2.可以采用相同的保护机制；<br>采用u_file：进程在共享文件时可采用相同的读写指针；<br>B链：指向高速缓存块<br>D链：实际的输入输出队列（同时属于B链）<br>Bfreelist链：指向系统可用缓冲区，整个系统只有一个（一个缓冲区也能同时属于B链：缓冲区可用的前提下提高缓存效果）<br>VFS(Virtual File System)文件系统<br>并不是一个实际文件系统，而是多种实际文件系统的一个统一界面<br>为多种文件系统（Ext2fs, FAT）提供统一接口，也为各种外部设备提供统一接口</p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断控制器：中断控制逻辑线路+中断寄存器（存放中断字）。<br><img src="/pictures/cs_exp/op/img_11.png" alt="img_11.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MP有限状态自动机和AC自动机</title>
      <link href="/posts/2853a062.html"/>
      <url>/posts/2853a062.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="模式匹配自动机"><a href="#模式匹配自动机" class="headerlink" title="模式匹配自动机"></a>模式匹配自动机</h2></div><p>什么是有限状态自动机？<br>定义n个不同状态，记为{1,2…n}，在状态i时输入s，达到状态j，记为goto(i,s)&#x3D;j<br>对于字符串s而言，在一个状态i下输入一个字符ch，也会达到一个<mark class="hl-label blue">指定状态</mark> ：<br>假定新的状态为串s[1,i]+ch的<mark class="hl-label red">最长相等前后缀</mark> ，便能够用这个状态机模拟KMP算法匹配字符串的过程。<br>当字符集仅为a、b时，有：<br><img src="/study/youxian.png" alt="自动机"><br>其中goto(4,a)&#x3D;3，也就是说abab+a的<mark class="hl-label red">最长相等前后缀</mark> 对应的状态是<mark class="hl-label blue">状态3</mark> ，也即表示字符串“aba”的状态。<br>似乎这样就足够了。<br>我们获得了goto函数，定义为：</p><blockquote><p>goto(Si,a)：串s[1,i]a的最长相等前后缀。</p></blockquote><p>为了得到这个goto函数的值，我们需要定义fail函数：</p><blockquote><p>fail(Si):串s[1,i]的最长相等前后缀。</p></blockquote><p>因为得到goto(i,a)的前提是，知道s[1,i]的<mark class="hl-label red">最长相等前后缀s\[1,j]</mark> ：若s[j+1]与a相同，则goto(i,a)&#x3D;j+1，否则求s[1,j]的最长相等前后缀，直到长度为0。<br>为了表示“s[j+1]与a相同”这一条件，定义函数：</p><blockquote><p>follow(Si, a):状态Si输入a后，来到下一个状态。</p></blockquote><p>对于字符串abcde，follow(0,a)&#x3D;1,follow(1,b)&#x3D;2,follow(2,c)&#x3D;3…以此类推，而其他值未定义。<br>到这里，goto函数就可表示为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">state <span class="title">go_to</span><span class="params">(state s,<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">follow</span>(s,ch)未定义)</span><br><span class="line">    &#123;</span><br><span class="line">        s=fail[s];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">follow</span>(s,ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>若s为模式串的状态，ch为s的后继字符，则这一goto值可当做新的fail值。</p><p>未定义状态，比如follow(0,b),计为0可不可行？<br>与之配套地，fail(0),计为0，也就是说空串的<mark class="hl-label red">最长相等前后缀长度</mark> 为0。<br>若fail(0)记为-1，则follow(s&#x3D;&#x3D;-1,ch)将陷入故障状态：没有状态被记为-1。<br>问题出现了！函数不得不进入死循环：因为s一直为0。<br>破环方式也很简单：</p><blockquote><p>引入状态-1，未定义状态记为-1，fail(0)&#x3D;-1，follow(-1,任何字符)&#x3D;0。</p></blockquote><p>这样，当计算ab+c的<mark class="hl-label red">最长相等前后缀</mark> 时，便能够得到go_to(2,c)&#x3D;0。<br>类似地，计算fail的函数为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Compute_fail</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fail</span>(s0) = ⊥;</span><br><span class="line">    s = s0;</span><br><span class="line">    <span class="keyword">for</span>( i =<span class="number">1</span> to |P| )&#123;</span><br><span class="line">        s = <span class="built_in">goto</span>(s, P[i]);</span><br><span class="line">        <span class="built_in">fail</span>(si) = s ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>goto和fail数组的关系：fail反映模式串中的某部分字符串的<mark class="hl-label red">最长相等前后缀</mark> ，goto反映文本串和模式串的匹配情况。诚然，fail数组可以通过goto函数得到，但记录一些中间状态有利于加速算法。<br>匹配函数为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Match</span>(t)</span><br><span class="line">&#123;</span><br><span class="line">    s= s0;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> to |T|)&#123;</span><br><span class="line">        <span class="keyword">if</span>( s 是终止状态 )</span><br><span class="line">           <span class="keyword">return</span> 匹配!</span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            s=<span class="built_in">goto</span>(s,T[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;     </span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note primary flat"><h2 id="MP有限状态自动机"><a href="#MP有限状态自动机" class="headerlink" title="MP有限状态自动机"></a>MP有限状态自动机</h2></div><p><del>我们都知道mp的c++写法。</del><br>基于以上定义，我们<del>艰难地</del>知道mp的有限状态自动机写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> state int</span></span><br><span class="line">string P; <span class="comment">//模式串</span></span><br><span class="line">string T;</span><br><span class="line">state fail[<span class="number">1000005</span>];</span><br><span class="line">state edge[<span class="number">1000005</span>][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">state <span class="title">follow</span><span class="params">(state s,<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(edge[s][ch-<span class="string">&#x27;A&#x27;</span>]==s<span class="number">+1</span>) <span class="keyword">return</span> s<span class="number">+1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">state <span class="title">go_to</span><span class="params">(state s,<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">follow</span>(s,ch)==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=fail[s];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">follow</span>(s,ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fail[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    state s_=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;P.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        s_=<span class="built_in">go_to</span>(s_,P[i]);</span><br><span class="line">        fail[<span class="built_in">state</span>(i)]=s_;</span><br><span class="line">        </span><br><span class="line">           <span class="keyword">if</span>(fail[s_]!=<span class="number">-1</span>&amp;&amp;P[s_<span class="number">+1</span>]-<span class="string">&#x27;A&#x27;</span>==P[i<span class="number">+1</span>]-<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            fail[<span class="built_in">state</span>(i)]=fail[s_];</span><br><span class="line">        &#125;<span class="comment">//！！！K优化！！！</span></span><br><span class="line">        </span><br><span class="line">        edge[i<span class="number">-1</span>][P[i] - <span class="string">&#x27;A&#x27;</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">match</span><span class="params">()</span></span>&#123;</span><br><span class="line">    state s_=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;T.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        s_=<span class="built_in">go_to</span>(s_,T[i]);</span><br><span class="line">        <span class="keyword">if</span>(s_==<span class="built_in">state</span>(P.<span class="built_in">size</span>()<span class="number">-1</span>))&#123;</span><br><span class="line">            cout&lt;&lt;i-P.<span class="built_in">size</span>()<span class="number">+2</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;T&gt;&gt;P;</span><br><span class="line">    P=<span class="string">&quot; &quot;</span>+P;</span><br><span class="line">    T=<span class="string">&quot; &quot;</span>+T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_fail</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">match</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;P.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    cout&lt;&lt;fail[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>洛谷提交情况如下： <a class="btn-beautify " href="https://www.luogu.com.cn/record/182533994"   title="洛谷"><span>洛谷</span></a><br>这是一种没有任何实战意义的写法。<br>需要注意俩点：</p><blockquote><p>if(edge[s][ch-‘A’]&#x3D;&#x3D;s+1) return s+1;</p></blockquote><p>只有计算fail函数时，遍历过某个字符时，才连一条edge边。<br>也就是说，在未遍历时，字符串abc的follow(0,a)&#x3D;-1,follow(1,b)&#x3D;-1,follow(1,c)&#x3D;-1,而当遍历<strong>过</strong>b时，follow(0,a)&#x3D;1,follow(1,b)&#x3D;2,follow(1,c)&#x3D;-1。这样做的原因是，若模式串天然有follow边，则fail数组的值会依次为-1,1,2,3,4…</p><blockquote><p>if(fail[s_]!&#x3D;-1&amp;&amp;P[s_+1]-‘A’&#x3D;&#x3D;P[i+1]-‘A’){<br>fail[state(i)]&#x3D;fail[s_]; }</p></blockquote><p>这是knuth优化。对于字符串aaaa，mp的fail数组是0,1,2,3而kmp的fail数组是0,0,0,3。<br>因为kmp的fail数组不能很好地反映字符串的前后缀的关系，而我们通常需要利用这种关系，故现常用mp，且把mp称为kmp。</p><p>MP算法是一个O(m+n)的算法，证明如下：</p><blockquote><p>1.在check函数中，对文本串扫描一遍，无回头扫描，消耗O(n)<br>2.自动机向右的移动距离 &gt;&#x3D; 向左移动的距离&gt;&#x3D;调用fail的次数，而向右的移动距离&#x3D; 对文本串扫描的距离&#x3D;n，故调用fail的次数&#x3D;O(n)<br>3.构造fail数组时，向右的移动距离&#x3D; 对模式串扫描的距离&#x3D;m，即Fail构造复杂度的复杂度为O(m)</p></blockquote><p>综合为O(m+n)。实际上，除了aaab匹配aaaaaaaa这种极端数据外，mp和暴力算法复杂度接近：随机情况下，暴力的复杂度也接近O(m+n)，在数据随机生成的情况下，暴力匹配也基本很快就会失配。</p><div class="note primary flat"><h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2></div><p>虽然MP有限状态自动机看起来多此一举，但可以很便捷地理解AC自动机。<br>AC自动机要完成以下任务，对于一系列字符串t1，t2，t3，判断他们在文本串s中是否出现。<br>当然，可以跑3次mp算法，但这太过于漫长。<br>AC自动机需要利用字典树 <a class="btn-beautify " href="https://www.luogu.com.cn/problem/P8306"   title="字典树"><span>字典树</span></a>。<br>建树如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> noww)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s[noww].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(AC_[now].a[s[noww][i]-<span class="string">&#x27;a&#x27;</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">            now=AC_[now].a[s[noww][i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            AC_[now].a[s[noww][i] - <span class="string">&#x27;a&#x27;</span>] = ++cnt;</span><br><span class="line">            now=AC_[now].a[s[noww][i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    AC_[now].end.<span class="built_in">push_back</span>(noww);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当我们建立好字典树时，也需要fail数组的值：<br>注意：AC自动机的fail数组，其前缀和后缀未必出现在同一模式串上。如：<br><img src="/study/zidian.png" alt="字典树"><br>fail(7)&#x3D;8,虽然6来自单词iris，4来自单词is。这样做的目的是，当匹配到iris时，也能匹配到可能的模式串is。<br>这就需要我们打一个标记，来记录“is”是不是模式串。<br>和上面同样的问题，计算fail就需要利用之前的fail值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AC_[<span class="number">0</span>].fail=<span class="number">0</span>; <span class="comment">//0的fail是0</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(AC_[<span class="number">0</span>].a[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            AC_[AC_[<span class="number">0</span>].a[i]].fail=<span class="number">0</span>;  <span class="comment">//第一层字母的fail是0，因为不存在最长相等前后缀</span></span><br><span class="line">            q.<span class="built_in">push</span>(AC_[<span class="number">0</span>].a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按层由浅到深递增填写fail函数</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> iq=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(AC_[iq].a[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                AC_[AC_[iq].a[i]].fail=AC_[AC_[iq].fail].a[i]; <span class="comment">//只计算一次，就能得到fail函数</span></span><br><span class="line">                q.<span class="built_in">push</span>(AC_[iq].a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                AC_[iq].a[i]=AC_[AC_[iq].fail].a[i]; <span class="comment">//将AC自动机转化为模式匹配自动机，全部字母都对应跳转边，比AC自动机需要更多的空间</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模式匹配自动机</strong>带来的优化:<br>当文本串是“iris<strong>i</strong>s”时，因为AC_[7].fail&#x3D;8,goto(8,i)&#x3D;0,follow(0,i)&#x3D;4，故新的状态为4。<br>否则，计算goto(8,i)&#x3D;0,再计算goto(0,i)&#x3D;4，就需要经过不止两次goto，而非固定的<strong>一次</strong>goto。<br>时间复杂度分析：</p><blockquote><p>AC自动机构造算法时间复杂为 O(|P|)，|P|模式集合中模式的长度之和</p></blockquote><blockquote><p>模式匹配搜索时间复杂 O(n + occ)，occ为模式出现次数(因为状态需要通过fail函数跳跃)</p></blockquote><p>问题：T&#x3D;aaaaaaaa，P&#x3D;{a,aa,aaa,aaaa,aaaa}时，搜索复杂度是多少？</p><p>check函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ss.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        now=AC_[now].a[ss[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=now;j!=<span class="number">0</span>&amp;&amp;AC_[j].end!=<span class="number">-1</span>;j=AC_[j].fail)&#123;</span><br><span class="line">            ans+=AC_[j].end;</span><br><span class="line">            AC_[j].end=<span class="number">-1</span>;  <span class="comment">//防止重复计数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><a class="btn-beautify " href="https://www.luogu.com.cn/record/182415813"   title="AC自动机简单版"><span>AC自动机简单版</span></a><p>优化：<br>使用拓扑排序，不进行fail跳跃(以下check是统计出现了几次，上面check是统计出现了几种)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">topu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="type">int</span> iq=q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">        jishu[AC_[iq].num]+=AC_[iq].ans;</span><br><span class="line">    AC_[AC_[iq].fail].ans+=AC_[iq].ans;</span><br><span class="line">    in[AC_[iq].fail]--;</span><br><span class="line">    <span class="keyword">if</span>(in[AC_[iq].fail]==<span class="number">0</span>) q.<span class="built_in">push</span>(AC_[iq].fail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ss.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        now=AC_[now].a[ss[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">            AC_[now].ans++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topu</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a class="btn-beautify " href="https://www.luogu.com.cn/record/182422907"   title="AC自动机"><span>AC自动机</span></a><p>设n为文本长度，k是模式数量，则：<br>最好匹配次数为n<br>最坏匹配次数为(1+n)*n&#x2F;2+n²-nk<br>AC自动机</p><div class="note primary flat"><h2 id="比特并行算法"><a href="#比特并行算法" class="headerlink" title="比特并行算法"></a>比特并行算法</h2></div><p>比特并行：一个机器字操作，能对所有比特进行改变。</p><h4 id="非确定自动机NFA"><a href="#非确定自动机NFA" class="headerlink" title="非确定自动机NFA"></a>非确定自动机NFA</h4><p>MP的非确定自动机：<br>同一时刻，不只有最长的前缀被匹配，更短的前缀也同时被匹配。<br>在DFA中，活跃状态只有一个，其他状态通过“后缀链”连接；而NFA中，他们都是活跃状态(空前缀永远是匹配的；每次匹配，都能得到一系列活跃状态的集合(用机器字代表这些集合，机器字的每一个比特代表一个前缀是否匹配))。<br>NFA中没有必要有后缀链存在，而是只存在向前的链接。</p><h4 id="举例：shift-and算法"><a href="#举例：shift-and算法" class="headerlink" title="举例：shift-and算法"></a>举例：shift-and算法</h4><p>文本串为ababb，模式串为abab，则状态变化为：</p><table><thead><tr><th>轮次\前缀</th><th>a</th><th>ab</th><th>aba</th><th>abab</th></tr></thead><tbody><tr><td>初始D表</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>输入a后D表</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>输入b后D表</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>输入a后D表</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>输入b后D表</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>输入b后D表</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>形式化：设B[a]表示a在模式串存在的位置，即{1,0,1,0}，B[b]表示b在模式串存在的位置，即{0,1,0,1}，每次变化计为：<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>D</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mi>D</mi><mo>&gt;&gt;</mo><mn>1</mn><mo stretchy="false">)</mo><mrow><mo stretchy="false">|</mo></mrow><mn>1</mn><mo>按位与</mo><mi>B</mi><mo stretchy="false">[</mo><msub><mi>t</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">]</mo></math><br>第一次移位得到可能活跃的集合，第二次取交得到活跃的集合。<br>shift-or：以0代表匹配，1代表不匹配。B[a]表示a<strong>不在</strong>模式串存在的位置，即{0,1,0,1}，B[b]表示b在模式串存在的位置，即{1,0,1,0}(D向量初始全1)：<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>D</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mi>D</mi><mo>&gt;&gt;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>按位或</mo><mi>B</mi><mo stretchy="false">[</mo><msub><mi>t</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">]</mo></math></p><mark class="hl-label red">注意：字符串是小端顺序，D、B向量是大端顺序：以上移位都应该向左移位</mark> <h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>比特并行算法能很好地处理通配符匹配问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line">string P;</span><br><span class="line">string T;</span><br><span class="line">bitset&lt;1000005&gt; B[<span class="number">256</span>];</span><br><span class="line">bitset&lt;1000005&gt; D=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;P&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;P.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        B[P[i]][i]=<span class="number">1</span>;</span><br><span class="line">        B[(<span class="type">int</span>)<span class="string">&#x27;-&#x27;</span>][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(P[i]==<span class="string">&#x27;a&#x27;</span>||P[i]==<span class="string">&#x27;b&#x27;</span>)&#123;   <span class="comment">//-和任意字符匹配，*和a，b匹配：当然，也可以随意指定</span></span><br><span class="line">            B[(<span class="type">int</span>)<span class="string">&#x27;*&#x27;</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(P[i]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            B[(<span class="type">int</span>)<span class="string">&#x27;a&#x27;</span>][i]=B[(<span class="type">int</span>)<span class="string">&#x27;b&#x27;</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(P[i]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">256</span>;j++)&#123;</span><br><span class="line">                B[j][i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        D=D&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        D[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        D=D&amp;B[T[i]];</span><br><span class="line">        <span class="keyword">if</span>(D[P.<span class="built_in">size</span>()<span class="number">-1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;success at &quot;</span>&lt;&lt;i-P.<span class="built_in">size</span>()<span class="number">+1</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;fail&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a-a*cc</span></span><br><span class="line"><span class="comment">//*a-b--</span></span><br><span class="line"><span class="comment">//匹配成功</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>NFA需要硬件支持并行机制，空间占用小；<br>DFA只需要串行操作，空间占用大。<br>参考资料：<br>1.<a href="https://blog.csdn.net/aoke1952/article/details/101609109" title="" target="">kmp和mp</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BM算法(手算版)</title>
      <link href="/posts/f093fa41.html"/>
      <url>/posts/f093fa41.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h2></div><p>BM算法是一种字符串匹配的算法。<br>与KMP相比，BM算法不扫描全部输入字符，平均匹配时间c·n, 常量 c &lt;1 (随机或真实文本), 但最坏情况是O(n·m).<br>可以将BM算法的最坏情况改进到O(n)：通过记录文本后缀中最长的模式后缀。<br>要使用BM算法，需要知道两个信息：<br><strong>1.用于坏字符规则的bc数组</strong><br><strong>2.用于好后缀规则的gs数组</strong></p><div class="note info flat"><h2 id="坏字符规则"><a href="#坏字符规则" class="headerlink" title="坏字符规则"></a>坏字符规则</h2></div><p>坏字符规则分为两种情况：<br>1.失配位置指向的<mark class="hl-label red">文本串中对应的字符</mark> ，不存在于模式串中。<br><img src="/study/huai2.png" alt="坏字符"><br>如上图所示，在这种情况下，直接将整个模式串移动到<mark class="hl-label red">失配位置</mark> 之后。</p><p>2.失配位置指向的<mark class="hl-label red">文本串中对应的字符</mark> ，存在于模式串中，且在<mark class="hl-label red">失配位置</mark> 的左边。<br><img src="/study/huai1.png" alt="坏字符"><br>如上图所示，在这种情况下，将模式串中的<mark class="hl-label red">文本串中对应的字符</mark> 放在<mark class="hl-label red">失配位置</mark> 上。<br>需要注意两个问题：<br>1.这个“模式串中的<mark class="hl-label red">文本串中对应的字符</mark> ”，是整个模式串从<strong>右往左数</strong>的第一个符合的字符。否则会造成过度左移。<br>2.模式串中最后一个字符，不能和任何的<mark class="hl-label red">失配位置</mark> 匹配。这是因为“失配”的前提是有匹配，而右边第一个字符必然被匹配；否则在右边第一个字符失配，那说明所需要的字符不是这个右边的第一个字符。故最后一个字符对应的位置是从右边数<strong>第二个符合数</strong>的位置。<br>如字符串“GCAGAGAG”的坏字符表为(从0开始计数,<strong>从右往左</strong>数)：</p><table><thead><tr><th>char</th><th>A</th><th>C</th><th>G</th><th>T</th></tr></thead><tbody><tr><td>bc[char]</td><td>1</td><td>6</td><td><mark class="hl-label blue">2</mark> </td><td>8</td></tr></tbody></table><p>坏字符表不是一直有效的。如果坏字符表中记载的位置，在<mark class="hl-label red">失配位置</mark> 的<strong>右边</strong>，那么可能会造成负位移或原地不动。<br>一个解决方法是，记载每次<mark class="hl-label red">失配位置</mark> 的<strong>左边</strong>的第一个符合的字符：但这很麻烦。<br>这并不是说位移就是上表的值。位移&#x3D; <strong>bc[char]-失配位置Z</strong>。(从右往左数，0开始)</p><div class="note info flat"><h2 id="好后缀规则"><a href="#好后缀规则" class="headerlink" title="好后缀规则"></a>好后缀规则</h2></div><p>好后缀规则分为3种情况：<br><img src="/study/hao.png" alt="坏字符"><br>rule3：</p><blockquote><p>如图14.1，目前匹配好的后缀u，在模式串中存在。如果有多个，则取最靠右的且c！&#x3D;a的那个，并将其对齐。</p></blockquote><p>rule2：</p><blockquote><p>如图14.2，目前匹配的好后缀u，在模式串中其他位置<strong>不存在</strong>。但它的后缀，和模式串的前缀相同。如果有多个满足的后缀，则取最长的那个后缀，并将其对齐。</p></blockquote><p>rule1：</p><blockquote><p><del>如图14.？</del>，目前匹配的好后缀u，在模式串中其他位置<strong>不存在</strong>。且它的每一个后缀，和模式串的前缀都<strong>不相同</strong>。这种情况下，直接将整个模式串移动到当前的<strong>最右端</strong>之后。</p></blockquote><p>好后缀规则和坏字符规则是可以同时使用的，我们每次取俩者中<strong>最大</strong>的那个。<br>如坏字符规则一样，好后缀也有自己的表，叫做gs数组。要想得到gs数组，首先要利用suff数组。</p><blockquote><p>suff数组:存储从字符s[i]向左开始计数的，和模式串最右边字符开始的匹配的字符个数。</p></blockquote><p>如字符串“GCAGAGAG”的suff为(从0开始计数)：</p><table><thead><tr><th>G</th><th>C</th><th>A</th><th>G</th><th>A</th><th>G</th><th>A</th><th>G</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>0</td><td>2</td><td>0</td><td>4</td><td>0</td><td>8</td></tr></tbody></table><p>从右往左看：<br>从G开始，GAGAGACG与GAGAAGACG匹配，个数是8，故填8。<br>从A开始，没有字符匹配(因为右边第一个字符是G)，故填0。<br>从G开始，GAGA(下一个是C)与GAGA(下一个是G)匹配，个数是4，故填4。<br>从A开始，没有字符匹配(因为右边第一个字符是G)，故填0。<br>从G开始，GA(下一个是C)与GA(下一个是G)匹配，个数是2，故填2。<br>从A开始，没有字符匹配(因为右边第一个字符是G)，故填0。<br>从C开始，没有字符匹配(因为右边第一个字符是G)，故填0。<br>从G开始，G(下一个是末尾)与G(下一个是A)匹配，个数是1，故填1。</p><p>接下来，我们依次处理rule1，rule2，rule3，来获得gs数组。<br>为什么是这个顺序：因为rule1位移&gt;rule2位移&gt;rule3位移，大的值被小的值取代，才不会造成<strong>过度右移</strong>。<br>具体的理解，可以见<a class="btn-beautify " href="https://www.cnblogs.com/YWT-Real/p/17120732.html"   title="高效字符串匹配算法"><span>高效字符串匹配算法</span></a><br><font color=red>施加rule1：</font><br>所有的项均有最大位移8(字符串长)：</p><table><thead><tr><th>G</th><th>C</th><th>A</th><th>G</th><th>A</th><th>G</th><th>A</th><th>G</th></tr></thead><tbody><tr><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td></tr></tbody></table><p><font color=red>施加rule2：</font><br>step1：从右往左扫描模式串，找到第一个下标(下标<strong>从左往右</strong>数，从0开始计。略过最右边的数)+1&#x3D;suff[i]的位置。对上面的例子来说，这个位置是“i&#x3D;0”，对应的是最左边的字符G。<br>step2：从左往右扫描字符串，将扫描过的位置对应的gs数组改为“当前值-suff[i]”，直到剩下suff[i]个字符。<br>step3：step继续向左，step2继续向右，直到扫描完成。</p><table><thead><tr><th>G</th><th>C</th><th>A</th><th>G</th><th>A</th><th>G</th><th>A</th><th>G</th></tr></thead><tbody><tr><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>8</td></tr></tbody></table><p><font color=red>施加rule3：</font><br>从左往右扫描字符串(略过最右边那个)，将gs[suff[i]]改为i(下标从右往左数，以0开始):</p><p>变化1：</p><table><thead><tr><th><mark class="hl-label blue">G</mark> </th><th>C</th><th>A</th><th>G</th><th>A</th><th>G</th><th>A</th><th>G</th></tr></thead><tbody><tr><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td><mark class="hl-label blue">7</mark> </td><td>8</td></tr></tbody></table><p>变化2：</p><table><thead><tr><th>G</th><th>C</th><th>A</th><th><mark class="hl-label blue">G</mark> </th><th>A</th><th>G</th><th>A</th><th>G</th></tr></thead><tbody><tr><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td><mark class="hl-label blue">4</mark> </td><td>7</td><td><mark class="hl-label red">5</mark> </td></tr></tbody></table><p>变化3：</p><table><thead><tr><th>G</th><th>C</th><th>A</th><th>G</th><th>A</th><th><mark class="hl-label blue">G</mark> </th><th>A</th><th>G</th></tr></thead><tbody><tr><td>7</td><td>7</td><td>7</td><td><mark class="hl-label blue">2</mark> </td><td>7</td><td>4</td><td>7</td><td><mark class="hl-label red">3</mark> </td></tr></tbody></table><p>变化4：</p><table><thead><tr><th>G</th><th>C</th><th>A</th><th>G</th><th>A</th><th>G</th><th><mark class="hl-label blue">A</mark> </th><th>G</th></tr></thead><tbody><tr><td>i&#x3D;0</td><td>i&#x3D;1</td><td>i&#x3D;2</td><td>i&#x3D;3</td><td>i&#x3D;4</td><td>i&#x3D;5</td><td>i&#x3D;6</td><td>i&#x3D;7</td></tr><tr><td>7</td><td>7</td><td>7</td><td>2</td><td>7</td><td>4</td><td>7</td><td><mark class="hl-label blue">1</mark> </td></tr></tbody></table><div class="note primary flat"><h2 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h2></div><p><img src="/study/shili1.png" alt="实例"><br>向右位移&#x3D;max(bc[A]-Z,gs[7])&#x3D;max(1-0,1)&#x3D;1;<br><img src="/study/shili2.png" alt="实例"><br>向右位移&#x3D;max(bc[C]-Z,gs[5])&#x3D;max(6-2,4)&#x3D;4;<br><img src="/study/shili3.png" alt="实例"><br>向右位移&#x3D;max(0,<mark class="hl-label blue">gs[-1---->0]</mark> )&#x3D;max(0,7)&#x3D;7;<br><img src="/study/shili4.png" alt="实例"><br>向右位移&#x3D;max(bc[C]-Z,gs[5])&#x3D;max(6-2,4)&#x3D;4;<br><img src="/study/shili5.png" alt="实例"><br>向右位移&#x3D;max(bc[C]-Z,gs[6])&#x3D;max(6-1,<strong>7</strong>)&#x3D;<strong>7</strong>;<br>附：对于字符串aaaaaa，其gs数组为{6,6,6,6,6，6}—&gt;{1,2,3,4,5,6}—–&gt;{1,2,3,4,5,6}。</p><div class="note primary flat"><h2 id="与kmp比较"><a href="#与kmp比较" class="headerlink" title="与kmp比较"></a>与kmp比较</h2></div><p>1.KMP算法的实际性能不好，一般实际中不用<br>2.BM速度快，但最快的BM类算法不是完整BM算法而是简化的版本(复杂度和效率的折中版本)<br>若模式串长为m，文本串长为n：<br>BM算法最好情况下比较m次，最坏情况下比较(n-m+1)*m次<br>MP算法最好情况下比较m次，最坏情况下比较(n-m+1)*m次<br>平均比较次数：？</p><p>参考内容：<br>1.<a href="https://blog.csdn.net/EQUINOX1/article/details/133256159" title="" target="">BM-c++</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：入侵检测系统</title>
      <link href="/posts/8c8bc191.html"/>
      <url>/posts/8c8bc191.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="入侵检测系统概念"><a href="#入侵检测系统概念" class="headerlink" title="入侵检测系统概念"></a>入侵检测系统概念</h2></div><p>入侵：未经授权的计算机使用者以及不正当使用(misuse)计算机的合法用户(内部威胁)，危害或试图危害资源的完整性、保密性、可用性的行为。<br>入侵检测：通过监测计算机系统的某些信息，加以分析，检测入侵行为，并作出反应。<br>入侵检测系统：实现入侵检测功能的硬件与软件。<br>核心问题：降低误报率<br>结构：<br><img src="/study/ruqin.png" alt="入侵检测"><br>事件产生器（Event generater， E-box）收集入侵检测事件,并提供给IDS其他部件处理。事件可以是网络活动，也可是系统调用序列等系统信息。<br>事件分析器（Analysis engine, A-box）对输入的事件进行分析并检测入侵。<br>事件数据库（Event database, D-box）存储和管理E-boxes 和 A-boxes 产生的大量数据，用于IDS(入侵检测系统)的训练和证据保存。<br>事件响应器（Response unit, C-box）对入侵做出响应，包括向管理员发出警告，切断入侵连接，根除入侵者留下的后门以及数据恢复等。<br>分类：<br>误用检测(基于特征的检测)：判别当前行为是否符合<strong>已知攻击的知识库</strong>中记录的的攻击模式。机制：状态模型、专家系统、正则表达式匹配<br>异常检测(基于行为的检测)：建立用户的正常使用模式知识库，标识出不符合正常模式的行为。机制：统计、机器学习方法<br>混合检测</p><div class="note warning flat"><h2 id="入侵检测系统评价标准"><a href="#入侵检测系统评价标准" class="headerlink" title="入侵检测系统评价标准"></a>入侵检测系统评价标准</h2></div><p>处理高速网络流量的能力<br>自身抗攻击的能力<br>误报率和漏报率<br>协同事件的能力<br>检测新攻击的能力</p><div class="note primary flat"><h2 id="误报率-混淆矩阵"><a href="#误报率-混淆矩阵" class="headerlink" title="误报率-混淆矩阵"></a>误报率-混淆矩阵</h2></div><p><img src="/study/yic.png" alt="入侵检测"><br>误报率：误报的数量(正常情况下报告攻击，攻击情况下报告正常)占所有正常事件的比例。即蓝色部分占据的面积(正确的true，错误的false)。<br>现实中，攻击行为占比很少(TP+FN)。导致正确率很高的检测器可能有较高的误报率。<br>准确率：p&#x3D;(TP+TN)&#x2F;(TP+TN+FP+FN)，预测对的占总样本总数的比率<br>精确率：p&#x3D;TP&#x2F;(TP+FP)，预测为<strong>攻击</strong>，且预测对了占总预测为攻击的比率<br>漏报率：p&#x3D;FN&#x2F;(TP+FN)<br>报警的准确度：p&#x3D;TN&#x2F;(TN+FP)<br><strong>误报率</strong>：p&#x3D;FP&#x2F;(TN+FP)<br>(为什么误报率是最重要的指标？)</p><div class="note primary flat"><h2 id="网络入侵检测系统Snort"><a href="#网络入侵检测系统Snort" class="headerlink" title="网络入侵检测系统Snort"></a>网络入侵检测系统Snort</h2></div><p>开放型系统，采用误用检测，包含：网络包的解析器、检测引擎、日志和报警子系统。利用libpcap库作为捕获数据包的工具。<br>特点：<br>主要数据源：网络数据包<br>设计原则：简单、灵活、高性能<br>对包的处理：1.协议分析；2.模式匹配(单模式匹配、多模式匹配)、正则表达式匹配、非精确模式匹配(什么样的协议，检测什么样的内容。先进行协议分析：分层解析各层包头，从链路层，到传输层，直到应用层，协议分析可以显著地缩小检测模式范围，从而减少内容检查，提高了入侵检测的效率。分析内容(时间占比大)：先匹配出现概率小的，后匹配出现概率大的，先匹配关键字，后匹配变量。)<br>特征描述语言：可描述攻击行为(误用检测)<br>插件子系统：实现系统功能扩展<br>规则:<br>由规则头，规则选项构成。规则头指明协议和源目标IP地址等，对包进行简单处理；规则选项指明包数据中搜索的内容，对包进行细致处理。<br>最重要的两个规则选项：<br>content: 用于匹配固定字符串，适合匹配简单的特征。<br>pcre: 用于匹配复杂的模式，支持正则表达式，适合匹配灵活多变的攻击 payload。<br>结合使用: 将 content 和 pcre 结合使用，可以提高检测的准确性。例如，使用 content 匹配关键字，使用 pcre 匹配变量部分。</p><div class="note warning flat"><h2 id="针对IDS的拒绝服务类攻击"><a href="#针对IDS的拒绝服务类攻击" class="headerlink" title="针对IDS的拒绝服务类攻击"></a>针对IDS的拒绝服务类攻击</h2></div><p>问题：<br>IDS要在高速的网络上工作，使得DPI(深度网络数据包检测,深入到数据包的载荷处理。DPI的中心问题：高效多正则表达式匹配。虽然识别多表达式的DFA只对输入扫描一次 但两个DFA的合并，状态数可能为二者之积。)处理能力显著下降，发生丢包、漏报。且攻击模式更加复杂。<br>攻击：<br>超载攻击：<br>当网络流量超过IDS的处理能力时(如大量的复杂正则匹配)，IDS的处理能力将急剧下降甚至完全瘫痪。攻击者通过某些手段使网络流量达到饱和，迫使IDS大量丢包。这种攻击还可针对目标IDS系统采用的检测算法进行算法攻击。<br>资源耗尽攻击：<br>通过发送大量残缺TCP数据段以及IP分片耗尽IDS的存储资源(IDS需要存储一些中间状态)，使IDS不能正常工作。<br>算法复杂攻击：<br>使DPI算法进入最坏情况，造成拒绝服务。目前除了通过修改算法还没有其他有效的方法。<br>提高性能：<br>提高单机检测性能：<br>采用高效检测算法，如多模式匹配&#x2F;多正则表达式匹配算法<br>采用高性能硬件<br>多机并行：<br>网络流量的分割<br>处理任务的分割</p><div class="note primary flat"><h2 id="加密流量处理"><a href="#加密流量处理" class="headerlink" title="加密流量处理"></a>加密流量处理</h2></div><p>IDS可以检测包头，但无法深入检查。<br>解决方式：<br>SSL&#x2F;TLS解密（中间人方式）</p><blockquote><p>不安全：被加密的数据被解密</p></blockquote><p>元数据分析（Metadata Analysis）</p><blockquote><p>分析HTTPS流量的元数据（例如，SNI、流量模式、连接频率等）</p></blockquote><p>基于行为的异常检测（Anomaly-Based Detection）</p><blockquote><p>对正常流量模式建模，来识别与正常行为偏差较大的活动</p></blockquote><blockquote><p>恶意软件、数据泄露</p></blockquote><p>EDR（Endpoint Detection and Response，端点检测和响应）</p><blockquote><p>EDR部署在客户端设备上，可以直接查看未加密的流量和活动</p></blockquote><div class="note primary flat"><h2 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h2></div><p>模式匹配算法：<br>Brute Force算法，最坏情况 O(nm)<br>KMP算法<br>AC多模式匹配算法<br>Boyer-Moore算法<br>现代技术：<br>后缀树与后缀自动机<br>基于因子识别的算法<br>Bit并行算法与非标准模式匹配<br>应用领域：<br>病毒扫描、入侵检测、搜索引擎、大数据处理</p><p>参考资料：<br>1.<a href="https://catcoder.blog.csdn.net/article/details/95623289?fromshare=blogdetail&sharetype=blogdetail&sharerId=95623289&sharerefer=PC&sharesource=lemonsed&sharefrom=from_link" title="" target="">混淆矩阵</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：buffer overflow attack</title>
      <link href="/posts/1e6d162f.html"/>
      <url>/posts/1e6d162f.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="堆栈构造"><a href="#堆栈构造" class="headerlink" title="堆栈构造"></a>堆栈构造</h2></div><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">静态存储</button><button type="button" class="tab " data-href="1-2">可变存储</button><button type="button" class="tab " data-href="1-3">函数调用</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>text segment存放代码；<br>data segment存放初始化了的静态变量；<br>BSS segment存放未初始化的静态变量。</p></div><div class="tab-item-content" id="1-2"><p>Heap存放需要长期保存的变量；<br>Stack存放临时变量。</p></div><div class="tab-item-content" id="1-3"><p>调用函数时，如f(int a,int b)：<br>则b放在大的正地址如ebp+12，a放在小的正地址如ebp+8，临时变量放在负地址如ebp-4。旧的ebp放在ebp+0，返回地址放在ebp+4。<br>这些数据构成一个<strong>栈帧</strong>。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2></div><p><img src="/study/neicun.png" alt="内存"></p><div class="note primary flat"><h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2></div><p><img src="/study/gj.png" alt="攻击"></p><blockquote><p>攻击原理：栈溢出时，能把以前的数据覆盖。</p></blockquote><blockquote><p>-攻击步骤1：在return address和攻击代码之间可写NOP；如果return address域指向的地址高于其自身的地址，则程序会沿着NOP走到攻击代码。(攻击代码足够短的话，也能放在return address之前)<br>-攻击步骤2：确定return address到栈底的偏移量，在这里将存放新的返回地址。<br>-攻击步骤3：在堆栈空间内找到存放攻击代码(操作寄存器的汇编代码)的地址。</p></blockquote><p>注意：字符串中的0会将字符串截断。解决：寄存器与寄存器自身异或获得数据0。<br>例子：<br><img src="/study/shell.png" alt="shell"><br>execve()的三个参数分别为”&#x2F;bin&#x2F;sh”、”&#x2F;bin&#x2F;sh NULL”、NULL，分别存在ebx,ecx,edx中，execve()函数本身的代码放在eax中。<br>上述代码激活时，栈会随代码运行而发生变化，当寄存器内的值都准备妥当时，通过汇编指令int 0x80启动execve()函数。<br><img src="/study/code.png" alt="code"></p><div class="note warning flat"><h2 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h2></div><h4 id="开放商方法"><a href="#开放商方法" class="headerlink" title="开放商方法"></a>开放商方法</h4><p>使用安全的函数</p><h4 id="OS方法"><a href="#OS方法" class="headerlink" title="OS方法"></a>OS方法</h4><p>ASLR：地址随机化(每次启动程序时，栈和堆的地址不固定。可高度随机化，也可以几种情况轮换)。这时，ebp(定位return address)和malicious code的位置难以确定。<br>应对方法：重复运行攻击代码</p><h4 id="编译器方法"><a href="#编译器方法" class="headerlink" title="编译器方法"></a>编译器方法</h4><p>stack-Guard：编译器使用一些guard值插入栈的内部，自动检测栈数据有没有被溢出数据覆盖<br><img src="/study/stack.png" alt="guard"></p><h4 id="shell方法"><a href="#shell方法" class="headerlink" title="shell方法"></a>shell方法</h4><p>当检测到真实的id(用户id)跳入到有效id时，自动降回更低的id<br>应对方法：运行攻击部分之前，将自己的real id设置为0</p><h4 id="硬件方法"><a href="#硬件方法" class="headerlink" title="硬件方法"></a>硬件方法</h4><p>Non-Executable Stack：禁止在栈内运行代码<br>应对方法：return-to-libc攻击</p><div class="note primary flat"><h2 id="return-to-libc攻击-考试重点"><a href="#return-to-libc攻击-考试重点" class="headerlink" title="return-to-libc攻击 考试重点"></a>return-to-libc攻击 <strong>考试重点</strong></h2></div><p>原理：利用已有的系统函数(比如system)，结合缓冲区的溢出。</p><blockquote><p>-攻击步骤1：找到system()和exit()函数的位置。<br>-攻击步骤2：找到字符串“bin&#x2F;sh”的位置，作为参数(将“bin&#x2F;sh”设置为环境变量：这会导致“bin&#x2F;sh”被压入栈中)。<br>-攻击步骤3：为system()设置好栈结构(准备好参数，返回地址：这里返回地址写的是exit()函数的地址)。<br>详细见<a class="btn-beautify " href="https://blog.csdn.net/sinat_38816924/article/details/106222286"   title="return-to-libc攻击"><span>return-to-libc攻击</span></a>(压栈时，eip等也会压入)</p></blockquote><p>更优的方法：</p><div class="note primary flat"><h2 id="return-oriented-programing攻击"><a href="#return-oriented-programing攻击" class="headerlink" title="return-oriented programing攻击"></a>return-oriented programing攻击</h2></div><p>原理：将系统中的多个片段指令，以一定顺序组织在一起。<br>例子：<br>需执行r1-&gt;r2-&gt;r3三段代码，他们的地址分别为a1、a2、a3，则栈内从下到上为a1、a2、a3、正常返回地址，并且三个程序的最后一句为ret指令。</p><div class="note primary flat"><h2 id="jmp-oriented-programing攻击"><a href="#jmp-oriented-programing攻击" class="headerlink" title="jmp-oriented programing攻击"></a>jmp-oriented programing攻击</h2></div><p>例子：<br>以上个攻击为例，栈内从下到上为a1、a2、a3、正常返回地址，三个程序的最后一句为相对跳转(jmp [dx])指令跳到<strong>调度器</strong>。<br>JOP攻击需要结合调度器，来实现“dx&#x3D;dx+4；jmp[dx]”的控制。<br>如何初始化dx：设置好esp的位置后，执行pop dx</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：门限秘密分享</title>
      <link href="/posts/a91656d0.html"/>
      <url>/posts/a91656d0.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="t-n-门限方案"><a href="#t-n-门限方案" class="headerlink" title="(t-n)门限方案"></a>(t-n)门限方案</h2></div><p>n个人中的t个人能还原秘密。</p><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">用对称密钥实现</button><button type="button" class="tab " data-href="1-2">shamir方案实现</button><button type="button" class="tab " data-href="1-3">使用几何学实现</button><button type="button" class="tab " data-href="1-4">基于中国剩余定理</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>略</p></div><div class="tab-item-content" id="1-2"><p>用拉格朗日插值定理实现。<strong>考试重点</strong><br>t-1阶的多项式P(x)，P(0)&#x3D;s秘密。<br>所有运算都是模p的，且s，n＜p。<br>表达式：<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&#x3D;</mo><munderover><mo data-mjx-texclass="OP">∑</mo><mrow><mi>i</mi><mo>&#x3D;</mo><mn>0</mn></mrow><mrow><mi>n</mi></mrow></munderover><msub><mi>y</mi><mrow><mi>i</mi></mrow></msub><msub><mi>l</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>,</mo><mo>其中</mo><msub><mi>l</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&#x3D;</mo><munderover><mo data-mjx-texclass="OP">∏</mo><mrow><mi>j</mi><mo>&#x3D;</mo><mn>0</mn><mo>,</mo><mi>j</mi><mo>!</mo><mo>&#x3D;</mo><mi>i</mi></mrow><mrow><mi>n</mi></mrow></munderover><mfrac><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><msub><mi>x</mi><mrow><mi>j</mi></mrow></msub><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>i</mi></mrow></msub><mo>−</mo><msub><mi>x</mi><mrow><mi>j</mi></mrow></msub><mo stretchy="false">)</mo></mrow></mfrac></math><br>例子：<br>p&#x3D;7,f(1)&#x3D;2,f(2)&#x3D;1,f(4)&#x3D;5:<br>ff(1)&#x3D;2*(x-2)<em>(x-4)&#x2F;(1-2)(1-4)&#x3D;10</em>(x-2)<em>(x-4);<br>ff(2)&#x3D;1</em>(x-1)<em>(x-4)&#x2F;(2-1)(2-4)&#x3D;3</em>(x-1)<em>(x-4);<br>ff(3)&#x3D;5</em>(x-1)<em>(x-2)&#x2F;(4-1)(4-2)&#x3D;30</em>(x-1)*(x-2);<br>相加得：x²-4x+5(mod 7)</p></div><div class="tab-item-content" id="1-3"><p>略</p></div><div class="tab-item-content" id="1-4"><p>任选n个俩俩互质的数，任意k个数的乘积＞m，s＜m。<br>原理：少于k个时，得到的s‘比真正的s小，不能唯一地确认真正的s。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：安全策略</title>
      <link href="/posts/a5baeaeb.html"/>
      <url>/posts/a5baeaeb.html</url>
      
        <content type="html"><![CDATA[<div class="note warning flat"><h2 id="什么是安全策略"><a href="#什么是安全策略" class="headerlink" title="什么是安全策略"></a>什么是安全策略</h2></div><p>计算机安全的一般定义：你可以依赖计算机，且计算机如你预料的那样行动。<br>不同的计算机对安全有更精确的划分，描述这种安全的方式叫做安全策略。<br>安全机制：实现安全策略的机制。<br>攻击破坏安全机制，使计算机在预料之外行动。</p><div class="note warning flat"><h2 id="计算机安全基本问题"><a href="#计算机安全基本问题" class="headerlink" title="计算机安全基本问题"></a>计算机安全基本问题</h2></div><p>在什么条件下，一个计算机算法可判定一个计算机系统是否安全？<br>结论：安全模型表达能力越强，验证安全性越难。简单模型描述能力有限，但存在有效验证安全性的方法。</p><div class="note primary flat"><h2 id="访问控制模型"><a href="#访问控制模型" class="headerlink" title="访问控制模型"></a>访问控制模型</h2></div><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">访问控制矩阵ACM</button><button type="button" class="tab " data-href="1-2">Haarrion-Ruzzo-Ullman模型</button><button type="button" class="tab " data-href="1-3">Take-Grant模型</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>保护状态：涉及安全保护的状态<br>ACM是描述当前保护状态的最精确的模型，主体与主体之间也存在不同权限。</p><table><thead><tr><th></th><th>文件f</th><th>文件g</th><th>进程p</th><th>进程q</th></tr></thead><tbody><tr><td>进程p</td><td>读写</td><td>读写</td><td>读写添加创建</td><td><strong>写</strong></td></tr><tr><td>进程q</td><td>读写</td><td>读写</td><td><strong>读</strong></td><td>读写添加创建</td></tr></tbody></table><p>ACM的行称为能力表，ACM的列称为访问控制列表(常用)。</p></div><div class="tab-item-content" id="1-2"><p>基本命令：创建主体客体、删除主客体、增加权限，删除权限。<br>单步命令：包含一条基本命令(基本命令不可直接调用)的命令。单步命令系统的可靠性问题可判定。</p><blockquote><p>证明：<br>1.delete操作可忽略：因为状态数固定<br>2.所有create合并成一个：最多增加一个主客体，因为只考虑r权限是否泄漏<br>3.故系统规模是有限的，命令总数k≤命令种类数*(主体+1)*(客体+1)，可用穷举方式判定</p></blockquote><p>条件命令：包含条件控制的命令，实现更合理的安全策略。多条件命令<strong>只能用AND</strong>连接条件。<br>可靠(安全)的：一个权限r不会被加入到原来不存在r的矩阵元素中。<br>在最普通、最抽象的情况下，计算机的安全是不可判定的。对于普通的HRU模型一系列操作，不存在算法判断权限是否泄漏。</p><blockquote><p>证明：<br>将图灵机停机问题归约为可靠性问题，而图灵机停机问题不可判定，故可靠性问题不可判定。</p><blockquote><p>证明：<br>设D(i,x)返回i号图灵机在输入为x时是否停机。构造图灵机y号如下:<br>if D(i,x)&#x3D;停 then 不停 else 停<br>则输入的编号为y时，产生悖论，故不存在这样的图灵机y，即判定图灵机是否停机问题的算法是无限的。</p></blockquote></blockquote><h4 id="图灵机停机问题"><a href="#图灵机停机问题" class="headerlink" title="图灵机停机问题"></a>图灵机停机问题</h4><p>图灵机：能模拟任何确定、可行、有限的算法。如果图灵机不能进入任何预设的接受拒绝状态，则图灵机不停机。<br>图灵机问题指的是，是否存在图灵机能回答,任意图灵机在任意输入下,是否停机的问题?</p><h4 id="用ACM矩阵表示图灵机"><a href="#用ACM矩阵表示图灵机" class="headerlink" title="用ACM矩阵表示图灵机"></a>用ACM矩阵表示图灵机</h4><p><img src="/study/acm.png" alt="ACM"><br>其中，纸袋的左移、右移、写，越过边界，可由一系列ACM命令模拟。<br>own确定了纸带单元的顺序。<br>k的存在保证同一时刻只有一条命令被触发。</p></div><div class="tab-item-content" id="1-3"><p>第一种可判定安全性的访问控制模型，时间是系统规模的线性函数。</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><blockquote><p>take：主体A可获取B的所有权限。<br>主体s若能获得y拥有的所有权限，则s可最终扩展为y。<br>grant：主体A可将自身拥有的任意权限赋给B。<br>主体s若能把其权限赋给r，则s可初始扩展为r。<br>create：主体创造对象。<br>remove：主体移除对象或权限。</p></blockquote><p>只有主体能主动执行一些动作，规则是修改ACM的权限。规则不是对系统的修改，而是对系统描述的修改。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>对称性<br><img src="/study/take.png" alt="对称性"></p><blockquote><p>即z对x有take权限，x也能通过一系列操作获得z的权限。<br>和x对z有take权限的区别：需要双方进行操作，而非一方进行操作。</p></blockquote><h4 id="保护状态图"><a href="#保护状态图" class="headerlink" title="保护状态图"></a>保护状态图</h4><p>岛：最大的，tg相连的，都是主体的子图。如果tg相连的都是主体，那么take和grant权限是对称的。<br>桥：连接众多主体、客体的路径(全是take权限；或take权限夹单个grand权限)，但桥的两端都是主体。(证明见回放)<br>谓词can·share(r,x,y,G)：返回节点x能否获得对y的r权限。</p><blockquote><p>如果x，y是一个岛上的主体，则返回真。</p></blockquote><blockquote><p>为真的充要条件1：如果x有一条边r连向y，则返回真。</p></blockquote><blockquote><p>为真的充要条件2：主体s有对y的r权限边，主体s和<strong>主体x</strong>在一些由桥连接的岛上。</p></blockquote><blockquote><p>为真的充要条件3：主体s有对y的r权限边，存在主体x‘&#x3D;x或x’初始扩展为x，存在主体s‘&#x3D;s或s’最终扩展为s，主体s‘和主体x’在一些由桥连接的岛上。</p></blockquote><p>任何两个点x，y的can·share(r,x,y,G)可用时间复杂度有限的算法判定。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="访问控制策略类型"><a href="#访问控制策略类型" class="headerlink" title="访问控制策略类型"></a>访问控制策略类型</h2></div><p>按照主体对ACM的权限进行的分类：</p><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">自主型访问控制DAC</button><button type="button" class="tab " data-href="2-2">强制访问控制MAC</button><button type="button" class="tab " data-href="2-3">创建者控制访问机制ORCON</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><p>基于身份的访问控制。<br>主体能自主地将访问权授予其他主体。<br>局限：主体不能控制信息的流动。<br>攻击：<br><img src="/study/muma.png" alt="木马"></p></div><div class="tab-item-content" id="2-2"><p>基于规则的访问控制。<br>系统机制控制对客体的访问，一般用户不能改变访问控制矩阵。<br>需要一个中心控制权威。</p></div><div class="tab-item-content" id="2-3"><p>DAC和MAC的结合。<br>没有创建者的许可，客体不会被泄露；<strong>客体的任何副本也遵循同样的限制</strong>。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="访问控制机制"><a href="#访问控制机制" class="headerlink" title="访问控制机制"></a>访问控制机制</h2></div><div class="tabs" id="3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="3-1">访问控制列表ACL</button><button type="button" class="tab " data-href="3-2">能力表</button><button type="button" class="tab " data-href="3-3">基于角色的访问控制RBAC</button><button type="button" class="tab " data-href="3-4">基于属性的访问控制ABAC</button></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><p>ACM的列，去除空表项，表和客体绑定。<br>应用：文件目录，网络防火墙。<br>易于集中管理，管理员可知道哪些主体拥有权限。</p></div><div class="tab-item-content" id="3-2"><p>ACM的行，去除空表项，表和主体绑定。<br>应用：分布式系统，微内核。<br>易于传递权限，无需管理员审批；不易于查找某一权限。<br>问题：<br>撤销权限时，要遍历所有主体。<span class="hide-inline"><button type="button" class="hide-button" style="">Click<br>  </button><span class="hide-content">构造一个全局客体表，主体引用全局客体表的表号代表客体(解决了撤销权限的问题，寻找权限的问题没解决)</span></span></p></div><div class="tab-item-content" id="3-3"><p>RBAC根据用户所拥有的角色进行访问控制和授权。<br>管理员角色管理权限的授予和撤销，用户的访问权限不可以主动转交。(非自主的访问控制)<br>应用：数据库、分布式系统。<br>一个用户可以发起几次会话，在不同会话中承担不同角色。<br>角色间的层次关系：角色A的权限包含角色B的所有权限。<br>约束：角色互斥、角色的实例限制等</p><blockquote><p>静态职责分离SSD：系统设计之初就定义好了的互斥角色<br>动态职责分离DSD：系统运行期间，动态地限制用户拥有的角色 </p></blockquote><p>优点：</p><blockquote><p>提高了管理员的管理能力(简化了授权模型，可方便实现权力分割、互斥)<br>模型与组织机构自然对应(使用起来很自然)</p></blockquote></div><div class="tab-item-content" id="3-4"><p>优点：<br>细粒度的访问控制；<br>灵活，适合动态访问控制；<br>减少用户和角色数量；<br>描述专业系统的防控策略。<br>属性分为主体属性，客体属性，环境属性。<br>ABAC在判断用户能否权限时，组合各类属性，代入规则以计算权限。<br>可实现DAC,RBAC,MAC等。</p><h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><p><img src="/study/abac.png" alt="策略"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="安全策略类型"><a href="#安全策略类型" class="headerlink" title="安全策略类型"></a>安全策略类型</h2></div><div class="tabs" id="3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="3-1">保密性策略</button><button type="button" class="tab " data-href="3-2">完整性策略</button><button type="button" class="tab " data-href="3-3">混合策略</button></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><p>用于军事安全策略。<br>基础：Bell-La Padula模型</p><h4 id="Bell-La-Padula模型"><a href="#Bell-La-Padula模型" class="headerlink" title="Bell-La Padula模型"></a>Bell-La Padula模型</h4><p>访问权限：执行、附加(追加写)、读、写。<br>Bell-La Padula模型约束信息的流动，信息不能由高安全级流向低安全级。<br>主体只能向下读(主体要有客体的DAC读权限)，向上附加(主体要有客体的DAC附加权限)，同级写(主体要有客体的DAC写权限)。<br>问题：有时候并不是所有的向下读等都是有必要的。<br>优化：给主体贴上“安全等级“的标签，安全等级由安全级别、类别构成。如{Too Secret，{Nuc，Eur，Asi}}</p><h4 id="关系优化"><a href="#关系优化" class="headerlink" title="关系优化"></a>关系优化</h4><p><img src="/study/zhipei.png" alt="支配"><br>支配关系dom，是部分序关系。基于需要知道原则，即便是同级的主体，也可能无法互相访问。<br>理解：{Too Secret，{Nuc，Eur，Asi}} dom {Too Secret，{Eur，Asi}}，意思为拥有前一个标签的主体，能访问拥有后一个标签的主体。</p><h4 id="对DAC木马问题的解决"><a href="#对DAC木马问题的解决" class="headerlink" title="对DAC木马问题的解决"></a>对DAC木马问题的解决</h4><p><img src="/study/mumaa.png" alt="木马"></p><h4 id="局限和结论"><a href="#局限和结论" class="headerlink" title="局限和结论"></a>局限和结论</h4><p>局限：没有涉及完整性，级别是静态的，包含隐形道(可能泄露高级对象的名字)。<br>重要结论：基本安全定理-状态迁移是安全的，初始状态是安全的，则其后的每一个状态都是安全的。</p></div><div class="tab-item-content" id="3-2"><p>用于商业安全策略。<br>著名模型：Biba完整性模型。</p><h4 id="Biba完整性模型"><a href="#Biba完整性模型" class="headerlink" title="Biba完整性模型"></a>Biba完整性模型</h4><p>完整性级别越高，数据越可信。<br>Biba完整性模型约束信息的改变，对信息的写会破坏完整性。<br><font color=red>Low-Water-Mark策略</font></p><blockquote><p>主体能向下写(主体的完整性等级高于客体的完整性等级)，向上读。<br>当一个主体读了一个低完整性客体，那么主体的完整性等级下降到该客体。<br>可以invoke(调用)低级别的客体。</p></blockquote><p><font color=red>环策略</font></p><blockquote><p>主体完整性等级都相同。<br>任意主体能read任意客体。<br>主体能向下写(主体的完整性等级高于客体的完整性等级)。<br>可以invoke(调用)低级别的客体。</p></blockquote><p>忽略了间接修改的问题，导致信息可以向上流。<br><font color=red>严格完整性策略</font></p><blockquote><p>主体能向下写(主体的完整性等级高于客体的完整性等级)，向上读。<br>可以invoke(调用)低级别的客体。</p></blockquote></div><div class="tab-item-content" id="3-3"><p>代表：中国墙模型，创建者控制访问机制ORCON，基于角色、属性的访问控制。</p><h4 id="中国墙模型"><a href="#中国墙模型" class="headerlink" title="中国墙模型"></a>中国墙模型</h4><p>解决商业中的利益冲突问题。<br>将信息对象分为“利益冲突”类。<br>CD：与一个公司有关的信息的集合。<br>COI：有利益冲突的公司的CD的集合，每个CD只属于一个COI。<br><img src="/study/coi.png" alt="COI"></p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p>s可以读o，当s读过o所属的CD的客体，或s没有读过其他冲突CD，或o是无毒客体。主体在一个COI中只能访问一个CD。<br>s可以写o，当s能够读的全部未消毒客体(即有毒个体，也即信息需要保密的个体。无毒：信息可以被任何主体读。)，与<strong>可读的</strong>o在一个CD中。</p><h4 id="联系和区别"><a href="#联系和区别" class="headerlink" title="联系和区别"></a>联系和区别</h4><p>与BLP本质区别：BLP用了安全标签，CW用了访问历史。<br>BLP能够模拟CW任意时刻的状态(不能跟踪变化)，而CW能模拟BLP整体。<br><img src="/study/youdu.png" alt="CW模拟"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>参考资料：<br>1.<a href="https://blog.csdn.net/sinat_41135487/article/details/105443141?fromshare=blogdetail&sharetype=blogdetail&sharerId=105443141&sharerefer=PC&sharesource=lemonsed&sharefrom=from_link" title="" target="">信息安全模型</a><br>2.<a href="https://blog.csdn.net/waqqy/article/details/127803086?fromshare=blogdetail&sharetype=blogdetail&sharerId=127803086&sharerefer=PC&sharesource=lemonsed&sharefrom=from_link" title="" target="">Bell-Lapudula模型</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：量子密钥协商</title>
      <link href="/posts/29d1b803.html"/>
      <url>/posts/29d1b803.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2></div><p>在量子理论中，用向量表示0比特和1比特。<br>量子比特qubit的叠加可能性：a<em>0+b</em>1，其中a²+b²&#x3D;1。测量此比特，得到1比特的可能性。(a,b为几率幅，结果为0的可能性为a²，结果为1的可能性为b²。a，b是复数)<br>测量对qubit的影响：使叠加态<strong>不可逆地</strong>坍缩到测出的态。<br>不可克隆：不能精确复制量子态，但能移动。<br>光子通过光栅，是对光子的测量。光子通过光栅后，光子偏振方向与光栅方向相同。<br>如果偏振方向和光栅方向的角度为a，则该光子通过光栅的可能性为cos²a。<br><img src="/study/qiet.png" alt="窃听"></p><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">BB84协议实现密钥分配</button><button type="button" class="tab " data-href="1-2">B92协议(更优)</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p><img src="/study/guangzi.png" alt="BB84"><br>光子的编码方式：以一个方向代表1，与其<strong>垂直</strong>的方向代表0。BB84只采用两种：x或者＋。(垂直的或45°倾斜的)</p><blockquote><p>1.A选择一个比特b。</p></blockquote><blockquote><p>2.A选择一个发送方式：x或者＋。</p></blockquote><blockquote><p>3.B选择一个接收方式：x或者＋。</p></blockquote><blockquote><p>4.A公布发送方式，B公布接收方式。如果两个方式不同，则抛弃接收结果。</p></blockquote><p>重复以上过程4N次，最终，A有2N比特，B有2N比特，随机选择N比特作为秘密(如果两方的N比特完全一致，则大概率认为没有窃听者存在(如果窃听者选择了错误的接收方式，则会破坏信息，使接收方有一定的概率接收到错误结果))。</p></div><div class="tab-item-content" id="1-2"><p>使用非正交基，-表示0，&#x2F;表示1。</p><blockquote><p>1.A选择一个比特b。</p></blockquote><blockquote><p>2.编码后，发给B。</p></blockquote><blockquote><p>3.B随机地使用×或者+来测量b，如果用+测得|，则是1(用＋测量-时，测得0，用+测量&#x2F;时，测得0或者1。故出现|则说明是1)，如果用×测得\，则是0。其他情况即为不确定的测量结果。</p></blockquote><blockquote><p>4.B公布不确定的测量结果，用BB84方法检查窃听者。</p></blockquote><table><thead><tr><th></th><th>-</th><th>&#x2F;</th></tr></thead><tbody><tr><td>+</td><td>-</td><td>+</td></tr><tr><td>×</td><td>×</td><td>&#x2F;</td></tr></tbody></table></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：算法优化</title>
      <link href="/posts/5f4e56a6.html"/>
      <url>/posts/5f4e56a6.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="公钥算法的优化"><a href="#公钥算法的优化" class="headerlink" title="公钥算法的优化"></a>公钥算法的优化</h2></div><p>加密算法的两个重要指标是加密强度和速度。在实现上，可以用各种技术来提高算法速度。<br>加密算法分为密钥生成和加解密，主要优化加解密部分。<br>Amdahl定律：优化一段代码的效果，取决于其执行时间占全部执行时间的比例。</p><h4 id="优化工作的方向"><a href="#优化工作的方向" class="headerlink" title="优化工作的方向"></a>优化工作的方向</h4><blockquote><p>充分利用CPU特性，如流水线和指令并行</p></blockquote><blockquote><p>针对加密算法本身做一些优化</p></blockquote><blockquote><p>编译器也会做一些优化：编译器的优化很保守(保证正确性)，且一些优化对于程序员来说简单，对编译器来说很难</p></blockquote><h4 id="软件优化一般方法"><a href="#软件优化一般方法" class="headerlink" title="软件优化一般方法"></a>软件优化一般方法</h4><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">代码移动</button><button type="button" class="tab " data-href="1-2">预计算</button><button type="button" class="tab " data-href="1-3">指令替换</button><button type="button" class="tab " data-href="1-4">共享子表达式</button><button type="button" class="tab " data-href="1-5">减少多余过程调用</button><button type="button" class="tab " data-href="1-6">限制变量</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>利用指令并行：调整代码顺序，使相近的两条指令的数据不相关<br>将条件分支指令按照概率和计算量排列次序</p></div><div class="tab-item-content" id="1-2"><p>如先计算一个定值，先计算一个字符串的长度</p></div><div class="tab-item-content" id="1-3"><p>避免使用耗时的指令：如左右移指令不能与任何其他指令配对形成流水，阻断了流水线<br>在循环中避免使用条件跳转指令：条件跳转指令会产生不可预见的指令流，容易分支预测失败</p></div><div class="tab-item-content" id="1-4"></div><div class="tab-item-content" id="1-5"><p>展开加密循环和函数：减少了条件指令和计算指令，将变量转化为常量，减少流水线的阻断和指令预取的作废</p></div><div class="tab-item-content" id="1-6"><p>限制变量的数量：寄存器有限<br>变量长度与CPU内部寄存器长度相同:否则，需要用别的指令来辅助存取，增加了指令周期数</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h4 id="优化举例"><a href="#优化举例" class="headerlink" title="优化举例"></a>优化举例</h4><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">IDEA算法优化</button><button type="button" class="tab " data-href="2-2">AES算法优化</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><p>问题<br>乘法时，若输入是0，该怎么办？ <span class="hide-inline"><button type="button" class="hide-button" style="">Click<br>  </button><span class="hide-content">乘法输入为0，则将其替换为2的16次方(<strong>17</strong>位数)，如果乘法输出是2的16次方，则将其替换为0。 正确性：0和2的16次方，在进行异或和加法时，结果一致；但是0没有乘法逆元，2的16次方为17位，故可以定义一个数，以2的16次方的性质(存在逆元)存在，但又能以16位的大小(数0)传递。</span></span><br>乘法的取模操作太耗时！<br>解决：高低算法：设p的高16是a，低16是b，则<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>p</mi><mo>&#x3D;</mo><mi>a</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">⟹</mo><mi>p</mi><mo>≡</mo><mi>b</mi><mo>−</mo><mi>a</mi><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>,</mo><mo>即计算</mo><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mo>&gt;&gt;</mo><mn>16</mn><mo stretchy="false">]</mo></math> </p><h4 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h4><p>查表法(指令周期大大减少)：预计算和存储一个生成元e的指数对数表，则a*b可表示为:<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mi>e</mi></mrow></msub><mi>a</mi><mo>+</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mi>e</mi></mrow></msub><mi>b</mi><mo>&#x3D;</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mi>e</mi></mrow></msub><mi>a</mi><mi>b</mi><mo>,</mo><mo>查表得</mo><mi>a</mi><mi>b</mi></math></p></div><div class="tab-item-content" id="2-2"><p>提供128比特寄存器，直接操作128比特块</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="字节顺序控制"><a href="#字节顺序控制" class="headerlink" title="字节顺序控制"></a>字节顺序控制</h2></div><p>类型：大端寻址，小段寻址</p><h4 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h4><p>问题：不规定哪种顺序，会导致错误<br>解决：网络字节顺序按大端地址，主机字节顺序任意<br>问题：字节反转时，如果一个比特一个比特重排，则需n(n为比特数目)次操作<br>解决：利用指令并行来加速；或用特定快速比特算法。</p><p>注意：对于大端寻址而言，高位放在低地址，但单个字节内部的顺序不变</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：安全协议</title>
      <link href="/posts/24329b97.html"/>
      <url>/posts/24329b97.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="身份证明协议"><a href="#身份证明协议" class="headerlink" title="身份证明协议"></a>身份证明协议</h2></div><blockquote><p>两个参与者：证明者，验证者。</p></blockquote><blockquote><p>采用方式：挑战-响应协议-证明者向验证者通过展示与身份相关的秘密知识，证明自己的身份。</p></blockquote><blockquote><p>关键：不泄露秘密，且能够抵抗攻击。</p></blockquote><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">双向认证(基于共享密钥)</button><button type="button" class="tab " data-href="1-2">基于整数模p的阶为q的乘法循环群</button><button type="button" class="tab " data-href="1-3">基于公钥的认证</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><blockquote><p>挑战：一方传送给对方一个随机数</p></blockquote><blockquote><p>响应：对方对这个数进行特定处理再返回</p></blockquote><p><font color=red>双向认证协议(1)</font><br><img src="/study/xieyi0.png" alt="协议1"></p><blockquote><p>假设A也是可接受多个会话的通用计算机</p></blockquote><blockquote><p>考虑当攻击者伪装B的身份</p></blockquote><p>受到反射攻击：<br><img src="/study/gonji0.png" alt="反射攻击"></p><blockquote><p>关键：1.攻击者伪装B，建立一个同A的会话；2.攻击者拦截一个A向B的会话；3.攻击者利用A的自动加密，分别套出两个随机数的加密值。</p></blockquote><p><font color=red>双向认证协议(2)</font><br><img src="/study/xieyi1.png" alt="协议2"></p><p>受到反射攻击：<br><img src="/study/fanshe.png" alt="反射攻击"></p><blockquote><p>改进方式：在每个加密消息里加入发送者、接收者在协议中的角色(这样攻击者就无法利用消息2)。</p></blockquote><p><font color=red>双向认证协议(3)</font><br>基于HMAC，对HMAC的 攻击难于对<strong>对称密钥算法</strong>的攻击。<br><img src="/study/hmac.png" alt="协议3"></p><p><font color=red>双向认证协议(4)</font><br>Andrew安全RPC协议。<br><img src="/study/RPC.png" alt="协议4"></p><p>攻击：</p><blockquote><p>重放攻击：重放4给A；4中没有注明这个会话密钥和此次通信的关联。</p></blockquote><blockquote><p>类型缺陷攻击：攻击者在第四步重放2给A：虽然攻击者不一定知道RA+1，但猜测nonce比猜测密钥简单。</p></blockquote><p>解决类型缺陷攻击：</p><blockquote><p>Nonce只被要求每次不同即可，不包含随机性。</p></blockquote></div><div class="tab-item-content" id="1-2"><p><font color=red>Schnorr协议</font></p><blockquote><p>挑战：一方传送给对方一个随机数e</p></blockquote><blockquote><p>响应：对方对这个数进行特定处理再返回</p></blockquote><p>全局变量：p(大素数)、q(素数，p-1的因数)、g(生成元，0&lt;g&lt;p)、v(公钥，v&#x3D;g^(-a) mod p)<br>私钥：a(0&lt;a&lt;q)</p><p>过程：</p><blockquote><p>A 生成随机 r(0&lt;r&lt;q)，将 g^{r} mod p 发给B(防止暴露a)</p></blockquote><blockquote><p>B 向 A 发送随机数 e(防止A伪造a,e&lt;2^{t}&lt;q)[挑战]</p></blockquote><blockquote><p>A 计算 y &#x3D; r + ae mod <strong>q</strong>，将 y发给B，(B无法求离散对数得到r，进而得到e)(为什么mod q：q是阶)[响应]</p></blockquote><blockquote><p>B 计算 g^{y} (g^{-a})^{e} mod p 是否等于g^{r} mod p, 判定A的身份(如果A没有a，很难伪造私钥以通过验证)</p></blockquote><p>问题:<br>将Schnorr协议的过程1，2反序。协议是否安全？<span class="hide-inline"><button type="button" class="hide-button" style="">Click<br>  </button><span class="hide-content">不安全，A可第三步构造t，第一步发送g^{t}g^{-a}^e来欺骗B</span></span><br>若A使用相同的r进行两次验证，监听者能否获得a？ <span class="hide-inline"><button type="button" class="hide-button" style="">Click<br>  </button><span class="hide-content">能，B将e设为r，即可获得a</span></span></p></div><div class="tab-item-content" id="1-3"><p>对于公钥算法来说，身份认证非常简洁。</p><blockquote><p>基于加密的认证：用X的公钥加密消息M</p></blockquote><blockquote><p>基于签名的认证：用X的私钥加密消息M</p></blockquote><p>注意：不要将密钥用于多个目的，比如使用不同的密钥对进行签名和加密</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note warning flat"><h2 id="认证协议设计一般原则"><a href="#认证协议设计一般原则" class="headerlink" title="认证协议设计一般原则"></a>认证协议设计一般原则</h2></div><blockquote><p>安全协议设计是困难的,需要不断设计，分析，改进。</p></blockquote><blockquote><p>协议中报文不能被重复使用。</p></blockquote><blockquote><p>通信的发起者先提供自己的身份的证明，然后才是响应者。</p></blockquote><blockquote><p>发起者和响应者使用不同的共享密钥。</p></blockquote><blockquote><p>发起者和响应者的挑战数来源于不同的集合。如发起者用偶数，响应者用奇数。</p></blockquote><blockquote><p>并行会话无法被利用。</p></blockquote><div class="note primary flat"><h2 id="密钥建立协议"><a href="#密钥建立协议" class="headerlink" title="密钥建立协议"></a>密钥建立协议</h2></div><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">密钥传输</button><button type="button" class="tab " data-href="1-2">密钥协商</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>一方建立，安全地传给另一方。</p><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">无预先共享密钥的密钥传输</button><button type="button" class="tab " data-href="2-2">使用密钥分发中心的密钥传输</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><p>目的：密钥 K 保密地（但无身份验证）从 A 传输到 B。<br>系统参数: 素数 p；A和B分别选择秘密随机数 a、b(1 ≤ a、b ≤ p − 2),均与p − 1互素(保证a逆 mod p-1存在)。</p><p>过程：</p><blockquote><p>A → B ： K^{a} mod p</p></blockquote><blockquote><p>A ← B ： (K^{a})^{b} mod p</p></blockquote><blockquote><p>A → B ： (K^{ab})^{a^(-1)} mod p</p></blockquote></div><div class="tab-item-content" id="2-2"><p>每个用户与KDC共享一个秘密密钥，KDC存储并管理所有密钥。</p><div class="tabs" id="3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="3-1">宽蛙嘴协议</button><button type="button" class="tab " data-href="3-2">简单票协议</button><button type="button" class="tab " data-href="3-3">Needham-Schroeder 协议</button><button type="button" class="tab " data-href="3-4">Kerberos协议</button></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><blockquote><p><img src="/study/kuanwa.png" alt="宽蛙嘴"></p></blockquote><p>攻击：</p><blockquote><p>重放2。</p></blockquote><p>解决：</p><blockquote><p>加入时间戳或nonce</p></blockquote></div><div class="tab-item-content" id="3-2"><blockquote><p><img src="/study/jiandan.png" alt="简单票"></p></blockquote><p>攻击：</p><blockquote><p>重放攻击：如果一个旧密钥 Ks及其KB(KS)泄露，则攻击者可假冒任何人的身份与Bob对话</p></blockquote><blockquote><p>中间人攻击1：Alice可在最后一步假冒任何人的身份与Bob对话</p></blockquote><blockquote><p>中间人攻击2：攻击方C申请和A、B对话，拿到KC(KS)，KA(KS),KC(KS‘),KB(KS’)，进而监听和篡改A、B之间的通信</p></blockquote><p>解决：<br>解决重放攻击：<br><img src="/study/chongf.png" alt="重放"></p><blockquote><p>Alice能保证得到的Ks是新鲜的</p></blockquote><p>解决中间人攻击：<br><img src="/study/jiejue.png" alt="简单票2"></p><blockquote><p>Alice无法假冒别的身份与Bob对话</p></blockquote><blockquote><p>Eva可以得到 KA(Ks，B)和 KB(Ks，A)， 但无法解密Ks，也无法伪造身份(因为身份信息受到KDC的加密)</p></blockquote></div><div class="tab-item-content" id="3-3"><p><img src="/study/Need.png" alt="协议"><br>4,5是B向A证明身份，确认收到密钥，同时确认A的身份。注意：消息2对KB(A,KS)的加密是没有必要的。</p><p>攻击：</p><blockquote><p>Trudy得到了一个旧的 ks，则可以重放消息3。而B必须记住所有旧ks才能抵抗这种攻击。</p></blockquote><p>解决：</p><blockquote><p>在2、3中加入时间戳，或者在3之前加入认证。</p></blockquote><p><font color=red>改进：Otway-Rees 协议</font><br><img src="/study/Ot.png" alt="协议"></p><blockquote><p>不需要复杂的同步机制</p></blockquote><blockquote><p>通信双方都与KDC进行了一次挑战-应答</p></blockquote><blockquote><p>RA加入到4，保证了KS的新鲜性</p></blockquote><blockquote><p>接收方B不在线时，不能使用</p></blockquote></div><div class="tab-item-content" id="3-4"><p>对Needham-Schroeder 协议的改进。</p><p><img src="/study/K5.png" alt="协议"></p><blockquote><p>TGS票重用，一次登录可访问多个服务</p></blockquote><blockquote><p>可视为两部分：第一部分，AS充当KDC，TGS充当另一用户；第二部分TGS充当KDC，Bob为另一用户</p></blockquote><p>过程：</p><blockquote><p>1.用户向AS提供用户名和密码，获取ticket(一个登录期间一次)</p></blockquote><blockquote><p>2.用户将此ticket发往TGS，获取另一个ticket(一种类型的服务一次)</p></blockquote><blockquote><p>3.用户将此ticket发往服务器，获取服务</p></blockquote><p>优点：</p><blockquote><p>身份验证只需一次，降低了风险</p></blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tab-item-content" id="1-2"><p>共同参与计算一个共享密钥，任何一方不能预先确定结果。</p><div class="tabs" id="4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="4-1">DH密钥协商</button><button type="button" class="tab " data-href="4-2">完美前向保密PFS</button></ul><div class="tab-contents"><div class="tab-item-content active" id="4-1"><blockquote><p>A 选择随机数 a，发送给B：g^{a} mod p</p></blockquote><blockquote><p>B 选择随机数  b，发送给A：g^{b} mod p</p></blockquote><blockquote><p>会话密钥 Ks &#x3D; g^{ab} mod p</p></blockquote></div><div class="tab-item-content" id="4-2"><blockquote><p>长期共享密钥K,当K被截获，不会造成Ks被破译:</p></blockquote><blockquote><p>A公开：EK(g^{a} mod p)</p></blockquote><blockquote><p>B公开：EK(g^{b} mod p)</p></blockquote><blockquote><p>会话密钥:Ks &#x3D; g^{ab} mod p</p></blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note warning flat"><h2 id="解决重放攻击的一般方式"><a href="#解决重放攻击的一般方式" class="headerlink" title="解决重放攻击的一般方式"></a>解决重放攻击的一般方式</h2></div><p>消息重放的实质是消息的新鲜性（Freshness）不能得到保证。</p><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">时间戳</button><button type="button" class="tab " data-href="1-2">挑战－应答机制</button><button type="button" class="tab " data-href="1-3">序列号</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>对消息盖上本地时戳，只有当消息上的时戳与当前本地时间的差值在意定范围之内，才接受该消息。<br>要求有一个全局同步时钟，但是如果双方时钟偏差过大或者允许的范围过大，则可以被攻击者利用。</p></div><div class="tab-item-content" id="1-2"><p>通过发送挑战值（Nonce）来确保消息的新鲜性。</p></div><div class="tab-item-content" id="1-3"><p>通信双方通过消息中的序列号来判断消息的新鲜性。要求通信双方必须事先协商一个初始序列号，并协商递增方法。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="传输层的安全协议SSL-TLS"><a href="#传输层的安全协议SSL-TLS" class="headerlink" title="传输层的安全协议SSL&#x2F;TLS"></a>传输层的安全协议SSL&#x2F;TLS</h2></div><p><img src="/study/woshou.png" alt="协议"><br>分为记录层(编码协议、报文顺序等)、握手层。</p><p>重要概念：</p><blockquote><p>会话：会话是指客户机和服务器之间的关联。一个会话包含多个连接。SSL 会话使用了公钥算法，开销大。</p></blockquote><blockquote><p>连接：连接是客户和服务器之间的逻辑链路，用于提供合适的传输服务和操作环境。SSL连接使用SSL会话生成的<strong>pre-master secret</strong>生成密钥，不再使用公钥算法。</p></blockquote><blockquote><p>SSL&#x2F;TLS握手协议负责协调客户机和服务器之间的<strong>会话</strong>的状态：当前操作状态和未决状态（在握手协议期间）。</p></blockquote><p>服务：</p><blockquote><p>身份认证。认证用户和服务器，确保数据发送到正确的客户机和服务器；</p></blockquote><blockquote><p>保密性。加密数据以防止数据中途被窃取；</p></blockquote><blockquote><p>完整性。维护数据的完整性，确保数据在传输过程中不被改变。</p></blockquote><div class="tabs" id="6"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="6-1">简化的SSL会话建立</button><button type="button" class="tab " data-href="6-2">有共享秘密pre-master secret后的SSL连接建立</button></ul><div class="tab-contents"><div class="tab-item-content active" id="6-1"><p><img src="/study/ssl.png" alt="协议"><br>使用了<strong>公钥算法</strong>，大大降低了效率。</p><blockquote><p>S ：<strong>pre-master secret</strong>，A生成的随机值。</p></blockquote><blockquote><p>K &#x3D; h(S||RA||RB)</p></blockquote><blockquote><p>“msgs”是前边全部消息，用来证明前边消息已经正确接收。</p></blockquote><blockquote><p>CLNT，SRVR 是固定字符串。</p></blockquote><blockquote><p>Ek(h(msgs||CLNT||K))用于向Bob证明Alice的身份，可以不需要。</p></blockquote><blockquote><p>第四步，Bob向Alice证明自己的身份。</p></blockquote><p>问题<br>并没有认证A的身份。<span class="hide-inline"><button type="button" class="hide-button" style="">Click<br>  </button><span class="hide-content">服务员在此后用其他手段认证A的身份。</span></span></p></div><div class="tab-item-content" id="6-2"><p>不需要公钥算法。<br><img src="/study/lianjie.png" alt="协议"></p><blockquote><p>SSL会话已建立，用session-ID表示</p></blockquote><blockquote><p>K &#x3D; h(S||RA||RB)</p></blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>参考资料：<br>1.<a href="http://t.csdnimg.cn/QDNGJ" title="" target="">Schnorr身份识别方案</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：快速比特操纵算法</title>
      <link href="/posts/7511bdb5.html"/>
      <url>/posts/7511bdb5.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><h2 id="快速比特操纵算法含义"><a href="#快速比特操纵算法含义" class="headerlink" title="快速比特操纵算法含义"></a>快速比特操纵算法含义</h2></div><p>使用机器字操作(算术、逻辑运算)实现机器字中的比特的计算和变换，是一种时间复杂度与机器字长无关的算法。</p><div class="note primary flat"><h2 id="计算1的个数"><a href="#计算1的个数" class="headerlink" title="计算1的个数"></a>计算1的个数</h2></div><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">朴素方法</button><button type="button" class="tab " data-href="1-2">移位加法方法</button><button type="button" class="tab " data-href="1-3">乘法方法</button><button type="button" class="tab " data-href="1-4">乘法和加法的综合使用</button><button type="button" class="tab " data-href="1-5">更快的方法</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v; <span class="comment">//c的值即1的个数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> c; </span><br><span class="line"><span class="keyword">for</span> (c = <span class="number">0</span>; v; c++)</span><br><span class="line">    v &amp;= v - <span class="number">1</span>; </span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="1-2"><h4 id="分块和"><a href="#分块和" class="headerlink" title="分块和"></a>分块和</h4><blockquote><p>对于一个二进制数x（总位数为w），将其划分为多段相同长度u的区间，将每个区间内的<strong>1的个数</strong>转化为二进制，首尾相接得到y：y称为x的u分块和。</p></blockquote><blockquote><p>例如：101010的1分块和是1,0,1,0,1,0,101010的2分块和是01,01,01，101010的6分块和是000011。</p></blockquote><blockquote><p>因为u位能表示的最大个数，大于等于u的长度，故该方式能正确表达出分块和而不发生溢出。</p></blockquote><h4 id="递推表达式"><a href="#递推表达式" class="headerlink" title="递推表达式"></a>递推表达式</h4><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>x</mi><mrow><mo stretchy="false">[</mo><mn>2</mn><mi>u</mi><mo stretchy="false">]</mo></mrow></msup><mo>&#x3D;</mo><mi>y</mi><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi></mrow></msup><msup><mn>1</mn><mrow><mi>u</mi></mrow></msup><msup><mo stretchy="false">)</mo><mrow><mi>w</mi><mrow><mo>&#x2F;</mo></mrow><mn>2</mn><mi>u</mi></mrow></msup><mo>+</mo><mo stretchy="false">(</mo><msup><mi>x</mi><mrow><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo></mrow></msup><mo>&gt;&gt;</mo><mi>u</mi><mo stretchy="false">)</mo><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi></mrow></msup><msup><mn>1</mn><mrow><mi>u</mi></mrow></msup><msup><mo stretchy="false">)</mo><mrow><mi>w</mi><mrow><mo>&#x2F;</mo></mrow><mn>2</mn><mi>u</mi></mrow></msup></math><br>说明</p><blockquote><p>简单来说，便是将奇数个u区间和偶数个u区间相加。</p></blockquote><blockquote><p>例如上面01010101的例子：<br>先将01010101和00110011按位与，只保留奇数位u区间得到00010001；<br>再将01010101右移u位，得到00010101，与00110011按位与，只保留偶数个u区间得到00010001。</p></blockquote><blockquote><p>再将两数相加，完成合并。</p></blockquote><p>这种方法参照了递归方式，计算1的个数的时间复杂度是O(log w)，小于上一方法的O(w)。</p></div><div class="tab-item-content" id="1-3"><h4 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h4><blockquote><p>若一个数，每个区间除了最后一位为0&#x2F;1，其他位都为0：换而言之，最低位的数表示这个u区间有多少个1：</p></blockquote><blockquote><p>形如001001001001、000000001001，将其与001001001001相乘，结果的从右往左数的第m-1&#x3D;w&#x2F;u-1（从0开始计数）个u区间的值为此二进制数的1的个数。</p></blockquote><blockquote><p>对于这个例子，001001001001与001001001001相乘，结果为1010011<strong>100</strong>011010001，得到001001001001中1的个数是4。</p></blockquote><h4 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h4><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>所有</mo><mi>u</mi><mo>区间的第</mo><mi>i</mi><mo>个比特中</mo><mn>1</mn><mo>的数量</mo><msub><mi>C</mi><mrow><mi>i</mi></mrow></msub><mo>&#x3D;</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&gt;&gt;</mo><mi>i</mi><mo stretchy="false">)</mo><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>m</mi></mrow></msup><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>m</mi></mrow></msup></math><br>即：通过移位和按位与，强制将每一部分的数变成“每个区间除了最后一位为0&#x2F;1，其他位都为0”的形式。</p><blockquote><p>如110110，分块为110，110，求第0,1,2位的1的个数的操作分别为000000*001001，001001*001001，001001*001001。</p></blockquote><blockquote><p>将上面的结果相加，取从右往左数的第w&#x2F;u-1（从0开始计数）个u区间的值，便是110110中1的个数，得到4。注意：分块长度至少为<strong>lgw</strong>，否则相加时会产生进位(即需满足w&lt;2^{u})。</p></blockquote><p>总结：如果设区间长度为lgw，则需要做[0,lgw）次乘法，并将乘法得到的结果<strong>相加</strong>，最后取第m-1(从0开始计数)个u区间的值。</p></div><div class="tab-item-content" id="1-4"><blockquote><p>加法方法进行到区间长度 u &#x3D; lgw 时；</p></blockquote><blockquote><p>用一次乘法，<strong>结果的第 m - 1 个 u 区间的值等于 x 中 1 的个数</strong>。</p></blockquote><blockquote><p>时间复杂 O(loglog w)</p></blockquote><p>此时虽然<strong>y</strong>的每个分块不满足“每个区间除了最后一位为0&#x2F;1，其他位都为0”,但满足“表示的数的大小为x的对应分块的1的个数”。即结果的第 m - 1 个 u 区间的值并非为y中1的个数，<strong>而是x的1的个数</strong>。</p><p>额外的：</p><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>x</mi><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>g</mi><mi>w</mi><mo stretchy="false">]</mo></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mrow><mi>l</mi><mi>g</mi><mi>w</mi></mrow></msup><mo>–</mo><mn>1</mn><mo stretchy="false">)</mo><mo>等于所有</mo><mi>u</mi><mo>区间的和</mo></math></p></blockquote><p>例子：</p><blockquote><p>0001001010001111，分块为4，则x[lgw]为0001,0001,0001,0100(十进制为4372)。</p></blockquote><blockquote><p>其乘以0001000100010001的结果的第3个数为0111，值为7。同时，4372模15的值也为7。</p></blockquote></div><div class="tab-item-content" id="1-5"><h4 id="前导知识"><a href="#前导知识" class="headerlink" title="前导知识"></a>前导知识</h4><blockquote><p>log*(n)的定义：满足log( log( ··· log(n) ··· ) ) ＜1 的最小log个数。</p></blockquote><blockquote><p>lg*(32) &#x3D; lg*(64) &#x3D; lg*(128) &#x3D; ··· &#x3D; lg*(2^16) &#x3D; 4</p></blockquote><blockquote><p>u个比特能表示2的u次方-1大小，也即(2的u次方-1)&#x2F;u个u区间的1的个数之和。</p></blockquote><blockquote><p>思想：让每次乘法尽最大可能扩张区间长度。</p></blockquote><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>设</mo><msup><mi>u</mi><mo>′</mo></msup><mo>是用一次乘法能得到的最大区间长度，则</mo><msup><mi>u</mi><mrow><mo>′</mo></mrow></msup><mo>&#x3D;</mo><mi>u</mi><mo stretchy="false">⌊</mo><mfrac><mrow><msup><mn>2</mn><mi>u</mi></msup><mo>−</mo><mn>1</mn></mrow><mi>u</mi></mfrac><mo stretchy="false">⌋</mo></math></p></blockquote><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>定义</mo><mi>L</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&#x3D;</mo><mi>l</mi><mi>g</mi><mi>w</mi><mo>,</mo><mi>L</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>&#x3D;</mo><mi>l</mi><mi>g</mi><mi>l</mi><mi>g</mi><mi>w</mi><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>&#x3D;</mo><mi>l</mi><mi>g</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mi>w</mi><mo>.</mo><mo>则:</mo><msup><mi>x</mi><mrow><mo stretchy="false">[</mo><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow></msup><mo>&#x3D;</mo><mo stretchy="false">(</mo><msup><mi>x</mi><mrow><mo stretchy="false">[</mo><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow></msup><mo>∗</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mfrac><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow></msup><mo stretchy="false">)</mo><mo>&gt;&gt;</mo><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></math></p></blockquote><blockquote><p>说明：从L(i)区间开始，每次将区间放大为原来的2次幂倍，直到区间长度为lgw。此时运用一次分块乘法，便能得到结果。</p></blockquote><blockquote><p>原理：存在y，x[u] * y &#x3D; z，对于 z 的每个u’区间，其最高 u 比特的值是x[ u’]对应区间的值。通过移位等处理，可得到x [u’]</p></blockquote><p><strong>具体公式课堂略过</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="LSB计算"><a href="#LSB计算" class="headerlink" title="LSB计算"></a>LSB计算</h2></div><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">Leiserson方法</button><button type="button" class="tab " data-href="2-2">Fich方法 O(1)</button><button type="button" class="tab " data-href="2-3">求最高位的置1比特（MSB）(O(1))</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><h4 id="前导知识"><a href="#前导知识" class="headerlink" title="前导知识"></a>前导知识</h4><blockquote><p>二元de Bruijn序列是一种特殊的周期为2的n次方的序列，满足任意一个二元n长向量都在de Brujn序列的一个周期中恰出现一次。</p></blockquote><blockquote><p>如n取3时，序列为00010111<strong>00</strong>，也即00010111的循环：其中000,001,010,011,100,101,110,111只出现了一次。</p></blockquote><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><blockquote><p>构造哈希函数h(x)：其中x是2的幂次方，最大值<strong>小于</strong>2的w次方，h(x)为0到w-1的任意一个数。<br>h(x) &#x3D;B * x &gt;&gt; (w – lg w)，lgw整除w(why?)。</p></blockquote><p>这个操作相当于对B进行移位后取高lgw(即上文中的n)位，因为B的特殊性，所以h(x)和x是一一对应的。</p><blockquote><p>构造表D：对于长度为lgw的数(或者说0&lt;&#x3D;x&lt;w)x，找到lgw维de Bruijn的第x位，取lgw个，得到的数记为y，D[y]&#x3D;x。(y互不相同；O(w)时间，O(wlgw)空间)</p></blockquote><p>这一步实际上就是由x确定h(x),<strong>不同的是，这里的x是LSB的值，而上文的的x是2的幂次方。h(x)的作用是，作为枢纽，连接这两个值</strong>。</p><blockquote><p>将word的除了最低置位bit之外的bit置 0(一个方式：(~word+1) AND word,~即按位取反)</p></blockquote><blockquote><p>结果与De Bruijn序列相乘，取乘积的前lgw bit得到数x’(这一步实际上就是进行h(x))</p></blockquote><blockquote><p>用结果查表D，得到D[x’]，即为LSB的位置</p></blockquote><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><blockquote><p>LSB的值根据de Bruijn序列，映射成了唯一的长度为lgw的值，而这长度为lgw的值又通过de Bruijn序列映射成了唯一的2的幂次方。当de Bruijn序列确定时，这两个映射关系是唯一确定的。</p></blockquote></div><div class="tab-item-content" id="2-2"><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><blockquote><p>将 x分为 u bit区间。</p></blockquote><blockquote><p>将LSB隔离出来，其他bit都是0。(一个方式：(~word+1) AND word,~即按位取反)</p></blockquote><p>注意：其中 u 应该大于根号w,否则做乘法时，00..1串无法覆盖所有的u区间。<br>计算LSB所在的区间号i</p><blockquote><p>生成一个机器字<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>F</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>将第</mo><mi>i</mi><mo>位之后的</mo><mi>u</mi><mo>区间的最低位比特置</mo><mn>1</mn><mo>：</mo><mi>y</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&lt;&lt;</mo><mn>1</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>A</mi><mi>N</mi><mi>D</mi><mi>F</mi></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>通过如下操作将所有</mo><mi>i</mi><mo>之后</mo><mi>u</mi><mo>区间的最后的比特相加到一个区间里:</mo><mi>y</mi><mo>&#x3D;</mo><mi>y</mi><mo>∗</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>在机器字</mo><mi>Y</mi><mo>的最高</mo><mi>u</mi><mo>比特中存放的数值就是</mo><mi>L</mi><mi>S</mi><mi>B</mi><mo>所在的</mo><mi>u</mi><mo>区间的编号:(截断为w位)</mo><mi>i</mi><mo>&#x3D;</mo><mi>y</mi><mo>&gt;&gt;</mo><mo stretchy="false">(</mo><mi>w</mi><mo>−</mo><mi>u</mi><mo stretchy="false">)</mo></math></p></blockquote><p>原理</p><blockquote><p>LSB后面的所有u区间的最低位为1，故在LSB及其后面有多少个u区间，便有多少个1被加。<strong>注意：这里的01串的重复次数是u，而非w&#x2F;u</strong></p></blockquote><p>计算LSB在区间中的位置j</p><blockquote><p>将x的i区间复制成u份：<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>y</mi><mo>&#x3D;</mo><mi>x</mi><mo>&gt;&gt;</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>i</mi><mo>–</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>u</mi><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup></math><br>只将第j个u区间保留下来：<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>y</mi><mo>&#x3D;</mo><mi>y</mi><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup></math><br>采用计算区间号i的方法，得到j</p></blockquote><p>则y &#x3D; u*(i-1)+j。</p><p>例子：</p><blockquote><p>100(u为3):</p></blockquote><blockquote><p>计算i：(0111&amp;(001001001))*(001001001)&#x3D;001001001,取高u位，即i&#x3D;1。</p></blockquote><blockquote><p>计算j：100复制三次：100100100，再与上000100010001得100000000,利用计算i的方法，得到j&#x3D;3。</p></blockquote><blockquote><p>最终：(1-1)*3+3&#x3D;3。</p></blockquote><p>反例：</p><blockquote><p>100 000 000 000…(u为3)：</p></blockquote><blockquote><p>此时不管后面有多少个000，最后都会得到LSB在第三个区间，而这是错误的。那为什么不动态改变机器字F来使得其正确:耗时。</p></blockquote></div><div class="tab-item-content" id="2-3"><h4 id="前导知识"><a href="#前导知识" class="headerlink" title="前导知识"></a>前导知识</h4><p>SetR(x,u)</p><blockquote><p>此操作根据机器字x中u区间是否为0对u区间进行设置，如果为0，则u区间不变，否则最低位置为1。</p></blockquote><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>1</mn><mo>）将每个</mo><mi>u</mi><mo>区间最高位置为</mo><mn>1</mn><mo>。</mo><mi>x</mi><mo>&#x3D;</mo><mi>x</mi><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>10</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup><mo>。</mo></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>2</mn><mo>）</mo><mi>y</mi><mo>&#x3D;</mo><mi>x</mi><mo>−</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>3</mn><mo>）将等于</mo><msup><mn>10</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>的</mo><mi>u</mi><mo>区间的最高为置为</mo><mn>1</mn><mo>。</mo><mi>x</mi><mo>&#x3D;</mo><mi>y</mi><mrow><mo stretchy="false">|</mo></mrow><mo stretchy="false">(</mo><mi>x</mi><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>10</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup><mo stretchy="false">)</mo><mo>.</mo></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>4</mn><mo>）</mo><mi>x</mi><mo>&#x3D;</mo><mi>x</mi><mo>&gt;&gt;</mo><mi>u</mi></math></p></blockquote><p>反向聚合操作compr(x,u)</p><blockquote><p>此操作将每个区间的最后一个比特聚合在一个u区间中，但顺序相反。</p></blockquote><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>1</mn><mo>）</mo><mi>y</mi><mo>&#x3D;</mo><mi>S</mi><mi>e</mi><mi>t</mi><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>u</mi><mo stretchy="false">)</mo></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>2</mn><mo>）将每个</mo><mi>u</mi><mo>区间的最低位比特反向聚集在</mo><mi>y</mi><mo>的最高</mo><mi>u</mi><mo>区间。</mo><mi>y</mi><mo>&#x3D;</mo><mi>y</mi><mo>∗</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>3</mn><mo>）</mo><mi>x</mi><mo>&#x3D;</mo><mi>y</mi><mo>&gt;&gt;</mo><mo stretchy="false">(</mo><mi>w</mi><mo>−</mo><mi>u</mi><mo stretchy="false">)</mo></math></p></blockquote><p>扩散操作diffu(x,u)</p><blockquote><p>此操作将一个u区间的每个比特放置到每个u区间的最低比特上，顺序不变。</p></blockquote><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>1</mn><mo>）将</mo><mn>0</mn><mo>区间复制</mo><mi>u</mi><mo>份</mo><mi>y</mi><mo>&#x3D;</mo><mi>x</mi><mo>∗</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><mo stretchy="false">)</mo><mi>u</mi></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>2</mn><mo>）保留第</mo><mi>i</mi><mo>区间的第</mo><mi>i</mi><mo>个比特</mo><mi>y</mi><mo>&#x3D;</mo><mi>y</mi><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi></mrow></msup><mn>1</mn><mo stretchy="false">)</mo><mi>u</mi></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>3</mn><mo>）</mo><mi>S</mi><mi>e</mi><mi>t</mi><mi>R</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mi>u</mi><mo stretchy="false">)</mo></math></p></blockquote><h4 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h4><p>首先计算MSB所在的u区间的号</p><blockquote><p>（1）y &#x3D; SetR(x)</p></blockquote><blockquote><p>（2）y &#x3D; Compr(y,u)</p></blockquote><blockquote><p>（3）y &#x3D; diffu(y,u)</p></blockquote><blockquote><p>（4）计算y中的MSB的位置 i，因此MSB在x中所在区间为 i’&#x3D; u-i</p></blockquote><p>计算i’区间中MSB位置</p><blockquote><p>（5）y &#x3D; x&gt;&gt;(i’u)</p></blockquote><blockquote><p>（6）y &#x3D; diffu(y,u)</p></blockquote><blockquote><p>（7）计算y中的MSB的位置 j，因此MSB所在区间为 j’&#x3D; u-j</p></blockquote><p>最终可得到MSB的位置为 i’u+j’<br><strong>此部分在课堂略过</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="比特置换"><a href="#比特置换" class="headerlink" title="比特置换"></a>比特置换</h2></div><h4 id="递归方法实现完全比特反转O-lgw"><a href="#递归方法实现完全比特反转O-lgw" class="headerlink" title="递归方法实现完全比特反转O(lgw)"></a>递归方法实现完全比特反转O(lgw)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = (((x &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((x &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    x = (((x &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((x &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>));</span><br><span class="line">    x = (((x &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((x &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>));</span><br><span class="line">    x = (((x &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((x &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>((x &gt;&gt; <span class="number">16</span>) | (x &lt;&lt; <span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Benes置换网络"><a href="#Benes置换网络" class="headerlink" title="Benes置换网络"></a>Benes置换网络</h4><blockquote><p>可实现任意置换，只需在方块中填写交叉或直连(X或&#x3D;)。</p></blockquote><p> <img src="/study/zhihuan.png" alt="置换网络"></p><blockquote><p>输入个数是2的幂次方，该置换网络使用多个 2*2 <strong>基本交换单元</strong>实现置换，输出也为2的幂次方个元素的序列。</p></blockquote><blockquote><p>BN网络运用了<strong>递归</strong>的思想，即相邻(奇偶性不同)的输入，分别前往两组，而在某一组中，又再进行分组；而在输出时，每两个输出合并到一个输出，直到两个输出合并成最终输出，完成置换过程。</p></blockquote><blockquote><p>所需层数：2lgw-1。时间复杂度：O(lgw)，空间复杂度：O(lgw)(记录直连还是交换)</p></blockquote><h4 id="断点图"><a href="#断点图" class="headerlink" title="断点图"></a>断点图</h4><blockquote><p>输入中的相邻用实线连接，输出中的相邻用虚线连接。（作图为俩列）</p></blockquote><blockquote><p>调整断点图：交换相邻点的位置，使得虚线相连的两个数不在同一列。</p></blockquote><blockquote><p>获得输入符号：如果一组相邻点换序，则为“×”，否则为“&#x3D;”。</p></blockquote><blockquote><p>获得输出符号：在输出中如果一组相邻点为上下关系，在断点图中不为左右关系，则为“×”，否则为“&#x3D;”。</p></blockquote><blockquote><p>重复以上过程，直到所有空填上。</p></blockquote><p>例子：<br>输入从上到下是01234567，输出从上到下是64203571，(初始输入分组是01&#x2F;23&#x2F;45&#x2F;67，初始输出分组是64&#x2F;20&#x2F;35&#x2F;71。)则作图如下：<br><img src="/study/duandian.png" alt="断点"></p><blockquote><p>输入符号从上到下为“x&#x3D;x&#x3D;”，输出符号从上到下为“&#x3D;&#x3D;xx”。进一步地，获得新的分组。</p></blockquote><p>对输出符号的解释：64是一组且在输出分组中6在上4在下，在输入的调整后的断点图中6在左4在右，故不交换；71是一组且在输出分组中7在上1在下，在输入的调整后的断点图中7在右而1在左，故交换。</p><h4 id="断点图实例"><a href="#断点图实例" class="headerlink" title="断点图实例"></a>断点图实例</h4><blockquote><p><img src="/study/zhih.png" alt="置换网络"><br>注意：线条在方块“背面”经过，意为不进入这一置换单元。</p></blockquote><p>试着将以上例子对应的符号填入方块中。得到：</p><blockquote><p><img src="/study/zhih1.png" alt="断点"></p></blockquote><h4 id="一般情况m置换单元"><a href="#一般情况m置换单元" class="headerlink" title="一般情况m置换单元"></a>一般情况m置换单元</h4><blockquote><p>输入、输出按顺序分为m个块，每块k个元素。</p></blockquote><blockquote><p>将每块中的元素分到k个不同组中，使得每组中元素属于输入的不同块。</p></blockquote><blockquote><p>归结为K正规图着色问题。(why?)<br><strong>此部分课堂略过</strong></p></blockquote><p>参考资料：</p><a href="https://blog.csdn.net/u012028275/article/details/108895271?fromshare=blogdetail&sharetype=blogdetail&sharerId=108895271&sharerefer=PC&sharesource=lemonsed&sharefrom=from_link" title="" target="">【位操作笔记】详解一种高效位反转算法</a>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：安全计算</title>
      <link href="/posts/bc7c7b.html"/>
      <url>/posts/bc7c7b.html</url>
      
        <content type="html"><![CDATA[<div class="note warning flat"><h2 id="协议双方互不信任，都有可能欺骗"><a href="#协议双方互不信任，都有可能欺骗" class="headerlink" title="协议双方互不信任，都有可能欺骗"></a>协议双方互不信任，都有可能欺骗</h2></div><p>Semi-honest 半诚实，遵守协议流程，在过程中获得尽可能的信息</p><div class="note primary flat"><h2 id="承诺方案"><a href="#承诺方案" class="headerlink" title="承诺方案"></a>承诺方案</h2></div><p>即在一次信息交换中，A和B需要“同时”获得对方的一个信息。假设A先给出信息a，B后给出信息b。则B需要先给出b的证明c，A再给出信息a，B再给出信息b。这样，A能够核验信息证明c，来确保B没有在接收信息a后更改信息b【绑定】；同时，A也无法从信息证明c中获取b，来改变信息a【隐藏】。</p><h4 id="基于Hash函数的实现"><a href="#基于Hash函数的实现" class="headerlink" title="基于Hash函数的实现"></a>基于Hash函数的实现</h4><blockquote><p>A 计算承诺 c &#x3D; H (随机数,a)，将 c 发送给 B</p></blockquote><blockquote><p>隐藏性：存在 H ( R’, a’ ) &#x3D;  H ( R, a )，B找不到真实的R，a</p></blockquote><blockquote><p>绑定性： A 找不到 R’, a’，满足：H ( R’, a’ ) &#x3D; H ( R, a )</p></blockquote><p>不存在对有无限计算能力的敌手同时具有隐藏性和绑定性的承诺方案。</p><div class="note primary flat"><h2 id="百万富翁问题"><a href="#百万富翁问题" class="headerlink" title="百万富翁问题"></a>百万富翁问题</h2></div><p>A有一个0-9的数a，B有一个0-9的数b，A和B不想让对方知道自己的数字，但想知道a和b的大小。</p><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">基于DH实现</button><button type="button" class="tab " data-href="2-2">茫然传输方案</button><button type="button" class="tab " data-href="2-3">混淆电路方案</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><blockquote><p>A和B生成 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>α</mi><mo>,</mo><msup><mi>g</mi><mrow><mi>α</mi></mrow></msup><mo>,</mo><mi>β</mi><mo>,</mo><msup><mi>g</mi><mrow><mi>β</mi></mrow></msup></math></p></blockquote><blockquote><p>A进行操作后发给B：<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>若</mo><mi>α</mi><mo>&#x3D;</mo><mi>i</mi><mo>，则</mo><mi>H</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&#x3D;</mo><msup><mi>g</mi><mrow><mi>α</mi></mrow></msup><mo>∗</mo><mn>3.</mn><mo>.</mo><mo>.</mo><mo>,</mo><mo>若</mo><mi>α</mi><mo>&lt;</mo><mi>i</mi><mo>，则</mo><mi>H</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&#x3D;</mo><msup><mi>g</mi><mrow><mi>α</mi></mrow></msup><mo>∗</mo><mn>2.</mn><mo>.</mo><mo>.</mo><mo>,</mo><mo>若</mo><mi>α</mi><mo>&gt;</mo><mi>i</mi><mo>，则</mo><mi>H</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&#x3D;</mo><msup><mi>g</mi><mrow><mi>α</mi></mrow></msup><mo>∗</mo><mn>1.</mn><mo>.</mo><mo>.</mo><mo>,</mo><mo>,</mo><msup><mi>g</mi><mrow><mi>α</mi></mrow></msup><mo>.</mo></math>(“…”互不相同是为了防止B通过判断相同元素个数，50%概率猜出a)</p></blockquote><blockquote><p>B对H[b]进行加密，并抹除下标，将其发送给A。</p></blockquote><blockquote><p>A对H[?]进行解密，并将其发送给B。(防止A知道下标b，而猜出具体数字)</p></blockquote><blockquote><p>B解密，获得结果。</p></blockquote><blockquote><p>B发送密钥给A，A解密，获得结果。</p></blockquote></div><div class="tab-item-content" id="2-2"><blockquote><p>B 生成大数字 x，用 A 的公钥加密 x 得到 [x]A，将 [x]A – b 发送给A</p></blockquote><blockquote><p>A收到后：</p><blockquote><p>计算九个数字：[x]A – b + 1,  [x]A – b + 2 ,  …  ,  [x]A – b + 9.<br>并用自己的私有密钥解密这个些数字： { [x]A – b + 1 }A ,  { [x]A - b + 2 }A ,  …  ,  { [x]A - b + 9 }A<br>并将第 1 到第 a 结果 +1，其余不变</p></blockquote></blockquote><blockquote><p>A将 9 个结果按序发送给 Ｂ</p></blockquote><blockquote><p>Ｂ检测第 b 个数字，如果是 x，则 a &lt; b，否则 a &gt;&#x3D; b.(原理：若成功解密，说明第b项没有+1，即a＜b)</p></blockquote></div><div class="tab-item-content" id="2-3"><p>即将函数f(a,b)(比较a和b大小的函数)电路化，再对每个门电路进行加密。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="茫然传输协议"><a href="#茫然传输协议" class="headerlink" title="茫然传输协议"></a>茫然传输协议</h2></div><p>A 拥有 m1、m2，B需要知道指定的一个，而不知道另一个；A不知道B指定了哪个。</p><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">EGL协议</button><button type="button" class="tab " data-href="2-2">Naor-Pinkis协议</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><p>采用了姚期智解决百万富翁问题的方案。</p><blockquote><p>A，B 共享 y0，y1</p></blockquote><blockquote><p>B 选择 x，用 A 的公钥加密，得到 [x]A, 将 [x]A - yb 发送给 A</p></blockquote><blockquote><p>A计算 [x]A – yb + y0, [x]A – yb + y1，并用A的私钥解密这两个结果，得到 { [x]A – yb + y0 }A，{ [x]A – yb + y1 }A。因为b是确定的，故其中一个等于x，但A并不知道哪个是x。</p></blockquote><blockquote><p>A将 { [x]A - yb + y0 }A + m0，{ [x]A – yb + y1 }A + m1 发送给 B</p></blockquote><blockquote><p>B 计算 { [x]A - yb+ yb }A + mb - x 得到 mb。因为另一个数不等于x，B无从知道另一个m是什么，除非B知道A的私钥。</p></blockquote></div><div class="tab-item-content" id="2-2"><p>基于Elgamal加密算法实现。<br><img src="/study/mangran.png" alt="茫然传输"><br>若B知道C的离散对数，设其为t，则有<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo stretchy="false">(</mo><mi>C</mi><mrow><mo>&#x2F;</mo></mrow><msup><mi>g</mi><mrow><mrow><mo>β</mo></mrow></mrow></msup><msup><mo stretchy="false">)</mo><mrow><mi>a</mi></mrow></msup><mo>&#x3D;</mo><mfrac><msup><mi>g</mi><mrow><mi>a</mi><mi>t</mi></mrow></msup><msup><mi>g</mi><mrow><mi>a</mi><mrow><mo>β</mo></mrow></mrow></msup></mfrac><mo>&#x3D;</mo><mfrac><msup><mi>g</mi><mrow><mo stretchy="false">(</mo><mi>a</mi><mrow><mo>β</mo></mrow><msup><mo stretchy="false">)</mo><mrow><mfrac><mi>t</mi><mrow><mo>β</mo></mrow></mfrac></mrow></msup></mrow></msup><msup><mi>g</mi><mrow><mi>a</mi><mrow><mo>β</mo></mrow></mrow></msup></mfrac><mo>&#x3D;</mo><msubsup><mi>P</mi><mrow><mn>1</mn><mo>−</mo><mi>b</mi></mrow><mrow><mi>a</mi></mrow></msubsup><mo>。</mo></math></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="多方安全计算协议"><a href="#多方安全计算协议" class="headerlink" title="多方安全计算协议"></a>多方安全计算协议</h2></div><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">两方安全计算</button><button type="button" class="tab " data-href="2-2">混淆电路</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><blockquote><p>问题：A，B各自拥有秘密 a，b。A，B 希望计算函数 f ( a, b )，同时不泄漏 a，b。值域定义域均为 [n]。</p></blockquote><blockquote><p>解决1：A 生成函数表 f ( a, * )，B 和 A 运行 1 &#x2F; n 茫然传输，B 输入 b(表在A方，B查询输入b时候的输出值，且不让A知道查询的值，得到f(a,b))，B 得到 f ( a, b )。</p></blockquote><blockquote><p>解决2：混淆电路，更便于实现多方安全计算，开销更小。</p></blockquote></div><div class="tab-item-content" id="2-2"><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>多个</strong>参与方提供输入，计算一个函数值，同时不泄露各自的输入。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><blockquote><p>设现有电路模块M，两个0&#x2F;1输入，一个0&#x2F;1输出。A将0&#x2F;1输入映射为B0，B1，将0&#x2F;1输出映射为T0，T1，并在对应的真值表中，用输入的映射值对输出的映射值进行加密。A选取a的映射值作为输入。</p></blockquote><blockquote><p>B选取一个输入b(0&#x2F;1),并通过<strong>茫然传输</strong>从A那里获得输入的映射值。</p></blockquote><blockquote><p>A将a的映射发给B，因为B<strong>不知道对应关系</strong>，故不知道A的输入原本是什么；B用两个映射值对四个被加密的输出值进行解密，得到正确的输出映射值。(解密函数 D 具有可分辨性质，即能通过解密结果判定解密是否正确。)因为A给B的四个盒子被<strong>混淆</strong>，故B不能通过顺序关系找到A的输入是0还是1。</p></blockquote><blockquote><p>B将输出的映射值发给A，A查表后得到输出的原本值，再发给B。</p></blockquote><blockquote><p>现有多个M，通过逻辑线路相连（但B不应该知道是与门还是或门)，B应当通过对多个M的解密获得多个输出，再把这些输出当做其他M的输入，进而得到最终输出。(最终输出无需加密和映射)</p></blockquote><p>一个电路的所有门的混淆表集合称为电路的混淆电路。<br>混淆电路实现了安全计算的目标。<br><strong>这部分运用比理论简单，建议看回放</strong></p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><blockquote><p>A 拥有AES密钥 k</p></blockquote><blockquote><p>B 希望得到用 k 加密的 m, 即 AES ( k, m )</p></blockquote><blockquote><p>此过程结束后 B 得到 AES ( k, m )，但不知道 k。A 不知道 m。(实现方式：将AES加密逻辑转化为电路，并将输入值转换为0&#x2F;1比特)</p></blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note warning flat"><h2 id="安全计算目标"><a href="#安全计算目标" class="headerlink" title="安全计算目标"></a>安全计算目标</h2></div><h4 id="隐私保护"><a href="#隐私保护" class="headerlink" title="隐私保护"></a>隐私保护</h4><blockquote><p>计算无法通过协议得知对方的参数</p></blockquote><h4 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h4><blockquote><p>能正确地传递信息</p></blockquote><h4 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h4><blockquote><p>双方都可以得到结果</p></blockquote><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><blockquote><p>混淆电路协议对诚实但好奇(观察分析)的攻击者是安全的</p></blockquote><p>参考：<br>1.<a href="http://t.csdnimg.cn/mfXre" title="" target="">CSDN：【隐私计算篇】混淆电路深入浅出</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：俄国农民指数算法</title>
      <link href="/posts/db01f830.html"/>
      <url>/posts/db01f830.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="俄国农民指数算法"><a href="#俄国农民指数算法" class="headerlink" title="俄国农民指数算法"></a>俄国农民指数算法</h2></div><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">正向快速幂(R-L算法)</button><button type="button" class="tab " data-href="1-2">逆向快速幂(L-R算法)</button><button type="button" class="tab " data-href="1-3">比较</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">FastPow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> g,<span class="type">long</span> <span class="type">long</span> e,<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> m)</span> <span class="comment">//求g的e次方模m的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(e)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span>(e&amp;<span class="number">1</span>)</span><br><span class="line">        ans=(ans*g)%m;</span><br><span class="line">        g=(g*g)%m;</span><br><span class="line">        e&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="1-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">FastPow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> g,<span class="type">long</span> <span class="type">long</span> e,<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> m)</span> <span class="comment">//求g的e次方模m的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(e)  <span class="comment">//e采用反向存储</span></span><br><span class="line">        &#123;</span><br><span class="line">        ans=(ans*ans)%m;</span><br><span class="line">        <span class="keyword">if</span>(e&amp;<span class="number">1</span>)</span><br><span class="line">        ans=(ans*g)%m;</span><br><span class="line">        e&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>a</mi><mi>n</mi><mi>s</mi><mo>∗</mo><mi>a</mi><mi>n</mi><mi>s</mi><mo>&#x3D;</mo><msup><mi>g</mi><mrow><msub><mi>e</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>e</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><msub><mi>e</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>e</mi><mrow><mn>2</mn></mrow></msub><msub><mi>e</mi><mrow><mn>1</mn></mrow></msub><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mn>0</mn><mo data-mjx-texclass="CLOSE">]</mo></mrow></mrow></msup><mo>,</mo><mo>如果</mo><msub><mi>e</mi><mrow><mn>0</mn></mrow></msub><mo>&#x3D;</mo><mn>1</mn><mo>,</mo><mo>则再乘以</mo><mi>g</mi><mo>，否则不变。</mo></math></p></div><div class="tab-item-content" id="1-3"><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><blockquote><p>两种算法都需要平均1.5∗(n −1) 次乘法。</p></blockquote><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><blockquote><p>第二种是用固定的g值作乘法，第一种的g值是变化的，因此在硬件实现时，需要增加一个寄存器。</p></blockquote><blockquote><p>第一种算法中，平方和模乘是独立的，可以并行运算。但在第二种算法中不能。</p></blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="俄国农民乘法算法"><a href="#俄国农民乘法算法" class="headerlink" title="俄国农民乘法算法"></a>俄国农民乘法算法</h2><p>图片见下：<br><img src="/study/nongm.png" alt="俄国农民"></p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;  <span class="comment">//当a是2的倍数时，加上b的2次幂；否则不加</span></span><br><span class="line">    <span class="type">int</span> ans=b&amp;(a%<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span>(a!=<span class="number">0</span>)&#123;</span><br><span class="line">        b=b*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        ans+=b;</span><br><span class="line">    &#125;</span><br><span class="line">    a=a/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><h2 id="笔纸算法"><a href="#笔纸算法" class="headerlink" title="笔纸算法"></a>笔纸算法</h2></div><p>简单来说，就是用程序模拟手算乘法时的<strong>竖式</strong>计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[], <span class="type">int</span> c[])</span> </span>&#123; <span class="comment">//OI WIKI</span></span><br><span class="line">  <span class="built_in">clear</span>(c);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 这里直接计算结果中的从低到高第 i 位，且一并处理了进位</span></span><br><span class="line">    <span class="comment">// 第 i 次循环为 c[i] 加上了所有满足 p + q = i 的 a[p] 与 b[q] 的乘积之和</span></span><br><span class="line">    <span class="comment">// 这样做的效果和直接进行上图的运算最后求和是一样的，只是更加简短的一种实现方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) c[i] += a[j] * b[i - j];</span><br><span class="line">    <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">      c[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><h2 id="比笔纸算法更快的算法"><a href="#比笔纸算法更快的算法" class="headerlink" title="比笔纸算法更快的算法"></a>比笔纸算法更快的算法</h2></div><p>用递归的方式优化乘法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multiply</span>(u, v) <span class="comment">//快速计算uv；</span></span><br><span class="line">Input: 正整数 u、 v, in binary</span><br><span class="line">Output: uv</span><br><span class="line">n = <span class="built_in">max</span>(size of u, size of v)</span><br><span class="line"><span class="keyword">if</span> n = <span class="number">1</span>  <span class="keyword">return</span> xy</span><br><span class="line">U1=u的高n/<span class="number">2</span>位， U0 =  u的低 n/<span class="number">2</span> 位</span><br><span class="line">V1 =v的高n/<span class="number">2</span>位, V0= v的低 n/<span class="number">2</span> 位</span><br><span class="line">P1 = <span class="built_in">multiply</span>(U1, V1)</span><br><span class="line">P2 = <span class="built_in">multiply</span>(U0 , V0)</span><br><span class="line">P3 = <span class="built_in">multiply</span>(U1-U0, V0-V1)</span><br><span class="line"><span class="keyword">return</span> =(<span class="number">2</span>^n<span class="number">+2</span>^n/<span class="number">2</span>)P1<span class="number">+2</span>^n/<span class="number">2</span>*P2+(<span class="number">2</span>^n/<span class="number">2</span><span class="number">+1</span>)P3</span><br></pre></td></tr></table></figure><p>递归表达式：<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>T</mi><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo><mo>≤</mo><mn>3</mn><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>c</mi><mi>n</mi></math><br>最终，算法复杂度约为n的1.5次方。</p><div class="note primary flat"><h2 id="复数乘法"><a href="#复数乘法" class="headerlink" title="复数乘法"></a>复数乘法</h2></div><p>两个复数相乘时，减少乘法的次数为3次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">复数乘法(a+bi)*(c+di): <span class="comment">//四次乘法改三次乘法</span></span><br><span class="line">A=a*d</span><br><span class="line">B=b*c</span><br><span class="line">C=(a+b)*(c-d)</span><br><span class="line">(a+bi)*(c+di)=(C-A+B)+(A+B)i</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：蒙哥马利约减</title>
      <link href="/posts/11252e67.html"/>
      <url>/posts/11252e67.html</url>
      
        <content type="html"><![CDATA[<div class="note primary flat"><h2 id="蒙哥马利约减"><a href="#蒙哥马利约减" class="headerlink" title="蒙哥马利约减"></a>蒙哥马利约减</h2></div><p>目前使用最广泛的模指数运算方法</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote><p>求y mod N，N为质数。y称为x模N关于R的Montgomery约减,即y&#x3D;xR’ mod N</p></blockquote><blockquote><p>附加条件：不使用除法（除法速度慢）</p><blockquote><p>尽量避免使用取模运算<br>用移位、减法运算替代取模运算</p></blockquote></blockquote><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><blockquote><p>1.取R为2的n次方(如果 N表示为n个b进制数，则 R取b的幂次方)，这样&#x2F; R即右移，*R即左移，mod R即与（R-1）按位与，大大提高了速度。</p></blockquote><blockquote><p>2.N&lt;R,R和N互质，即存在R’和N’，使得RR’ + NN’＝1(保证对任意的x＜R，有k＜R，使得kN&#x3D;x＜R。这保证<strong>表达式</strong>(见下文)的后半部分有解，且大小不超过R&#x2F;R&#x3D;1)。同时，加上y&#x2F;R＜N，故<strong>表达式</strong>的前半部分大小不超过N。综上可得，表达式整体大小不超过2N(故取模可以用减法做)。</p></blockquote><h4 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h4><p>设T&#x3D;Qm+r，欲求T mod m<br>将T分为n的两部分，高n位为T’，低n位为T’’<br>则：<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mfrac><mi>T</mi><mi>R</mi></mfrac><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi><mo>&#x3D;</mo><msup><mi>T</mi><mo>′</mo></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi><mo>+</mo><mn>0.</mn><msup><mi>T</mi><mo>″</mo></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math><br>前半部分只需要移位和最多一次减法。<br>对于后半部分，需要找到0.km，使其与表达式后半部分相加，能将小数部分变成0。即T’’+km&#x3D;cR(R的低位全为0)。加之m和R互素，故这样的k一定存在。实际上，k&#x3D;-1&#x2F;m*T’’ mod R<br>综合可得，T+km是R的倍数。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∗</mo><mi>N</mi><mrow><mo>′</mo></mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>R</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>N</mi><mo stretchy="false">)</mo><mrow><mo>&#x2F;</mo></mrow><mi>R</mi><mo>≡</mo><mi>x</mi><mo>∗</mo><msup><mi>R</mi><mo>′</mo></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>N</mi></math></p></blockquote><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∗</mo><mi>N</mi><mrow><mo>′</mo></mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>R</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>N</mi><mo stretchy="false">)</mo><mrow><mo>&#x2F;</mo></mrow><mi>R</mi><mo>&lt;</mo><mn>2</mn><mi>R</mi></math></p></blockquote><p>x模 N 关于 R 的Montgomery 约减用2次乘法、1次加法(把-k换成k)、2次移位、1次减法(最后取模时使用)。<br><strong>注意：xmod R和x’’ modR结果一致，因为x’mod R结果为0。同时，结论的x*N‘ modR等于推导式中的-k</strong></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><blockquote><p>取N &#x3D; 3457，R &#x3D; 2^16，得到N’＝12929，R’＝682。求y mod N：</p></blockquote><blockquote><blockquote><p>计算得<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>3310</mn><mo>≡</mo><mi>R</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>N</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>由结论得，<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>y</mi><mo>≡</mo><mo stretchy="false">(</mo><mi>y</mi><mo>∗</mo><mi>R</mi><mo>−</mo><mo stretchy="false">(</mo><mi>y</mi><mo>∗</mo><mi>R</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>N</mi><mrow><mo>′</mo></mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>R</mi><mo>∗</mo><mi>N</mi><mo stretchy="false">)</mo><mrow><mo>&#x2F;</mo></mrow><mi>R</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>代入计算得，<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>y</mi><mo>≡</mo><mo stretchy="false">(</mo><mi>y</mi><mo>∗</mo><mn>3310</mn><mo>−</mo><mi>y</mi><mo>∗</mo><mn>3310</mn><mo>∗</mo><mn>12929</mn><mi>m</mi><mi>o</mi><mi>d</mi><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup><mo>∗</mo><mn>3457</mn><mo stretchy="false">)</mo><mrow><mo>&#x2F;</mo></mrow><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup></math></p></blockquote></blockquote><blockquote><blockquote><p>这种方法的另一个优势在于，<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>R</mi><mo>∗</mo><mi>N</mi><mrow><mo>′</mo></mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>R</mi><mo>∗</mo><mi>N</mi></math>也即<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>12929</mn><mi>m</mi><mi>o</mi><mi>d</mi><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup><mo>∗</mo><mn>3457</mn></math> 可提前计算。</p></blockquote></blockquote><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> u;</span><br><span class="line">    u = a * QINV;  <span class="comment">//QINV固定</span></span><br><span class="line">    t = u * CTRU_Q;<span class="comment">//CTRU_Q固定</span></span><br><span class="line">    t = a - t;</span><br><span class="line">    t &gt;&gt;= <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用：模指数"><a href="#应用：模指数" class="headerlink" title="应用：模指数"></a>应用：模指数</h4><blockquote><p>计算 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>x</mi><mrow><mn>5</mn></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote><blockquote><blockquote><p>计算x*R²的M约减  <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>x</mi><mrow><mo stretchy="false">̃</mo></mrow><mo>&#x3D;</mo><mi>x</mi><mi>R</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>计算x̃²的M约减A： <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>x</mi><msup><mrow><mo stretchy="false">̃</mo></mrow><mrow><mn>2</mn></mrow></msup><mrow><mo>&#x2F;</mo></mrow><mi>R</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>计算A平方的M约减 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>A</mi><mrow><mn>2</mn></mrow></msup><mrow><mo>&#x2F;</mo></mrow><mi>R</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi><mo>&#x3D;</mo><mi>x</mi><msup><mrow><mo stretchy="false">̃</mo></mrow><mrow><mn>4</mn></mrow></msup><mrow><mo>&#x2F;</mo></mrow><msup><mi>R</mi><mrow><mn>3</mn></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>A平方的M约减 乘 x̃的M约减，再进行约减，即得。</p></blockquote></blockquote><p>乘方写成函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x̃ = <span class="built_in">MR</span>(x * (R方 mod m)), ã = <span class="built_in">MR</span>(<span class="number">1</span>*(R方 mod m) ) <span class="comment">//逆向快速幂，输出：x^&#123;e&#125; mod m.</span></span><br><span class="line">For i = t downto <span class="number">0</span></span><br><span class="line">ã = <span class="built_in">MR</span>(ã* ã)</span><br><span class="line">If ei = <span class="number">1</span> then ã = <span class="built_in">MR</span>(ã* x̃)</span><br><span class="line">a = <span class="built_in">MR</span>(ã)</span><br><span class="line"><span class="built_in">Return</span>(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="应用：取模乘法"><a href="#应用：取模乘法" class="headerlink" title="应用：取模乘法"></a>应用：取模乘法</h4><blockquote><p>计算 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>c</mi><mo>&#x3D;</mo><mi>x</mi><mo>∗</mo><mi>y</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote><blockquote><blockquote><p>计算x的M变换 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>x</mi><mo>′</mo></msup><mo>&#x3D;</mo><mi>x</mi><mo>∗</mo><msup><mn>2</mn><mrow><mi>n</mi></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>计算y的M变换 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>y</mi><mo>′</mo></msup><mo>&#x3D;</mo><mi>y</mi><mo>∗</mo><msup><mn>2</mn><mrow><mi>n</mi></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>计算x’和y’的积，再进行M约减 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>c</mi><mo>′</mo></msup><mo>&#x3D;</mo><msup><mi>x</mi><mo>′</mo></msup><mo>∗</mo><msup><mi>y</mi><mo>′</mo></msup><mrow><mo>&#x2F;</mo></mrow><msup><mn>2</mn><mrow><mi>n</mi></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>进行约减，即得。</p></blockquote></blockquote><h4 id="优化：用M约减实现M变换"><a href="#优化：用M约减实现M变换" class="headerlink" title="优化：用M约减实现M变换"></a>优化：用M约减实现M变换</h4><blockquote><p>即计算<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>x</mi><mo>′</mo></msup><mo>&#x3D;</mo><mi>x</mi><mo>∗</mo><msup><mn>2</mn><mrow><mn>2</mn><mi>n</mi></mrow></msup><mrow><mo>&#x2F;</mo></mrow><msup><mn>2</mn><mrow><mi>n</mi></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote><h4 id="优化：多精度M约减"><a href="#优化：多精度M约减" class="headerlink" title="优化：多精度M约减"></a>优化：多精度M约减</h4><p>当T比较大时。<br>T为2n位，N为n位，R为b的n次方。<br>理论：<br><img src="/study/gaojj.png" alt="多精度"><br>实例：<br><img src="/study/gaoj.png" alt="多精度"></p><h4 id="优化：多精度M乘法"><a href="#优化：多精度M乘法" class="headerlink" title="优化：多精度M乘法"></a>优化：多精度M乘法</h4><p>x为n位，y为n位，N为n位，R为b的n次方。<br>理论：<br><img src="/study/gaoj2j.png" alt="多精度"><br>实例：<br><img src="/study/gaoj2.png" alt="多精度"><br><strong>证明方式见回放</strong></p><div class="note primary flat"><h2 id="barrett约减"><a href="#barrett约减" class="headerlink" title="barrett约减"></a>barrett约减</h2></div><p><img src="/study/barrett.png" alt="barrett"><br>其中r1-r2可能为负数，只需要加一次模。(因为−b^{k+1} &lt; r1 − r2 &lt; b^{k+1})<br>其中第四步最多执行2次。(因为Q-q3≤2)<br>设x&#x3D;Qm+r，则x 的高 k+1位与 1&#x2F;m 的高 2k 比特中的低 k+1 位相乘，取整数部分(高k+1位)得到Q的近似值q3(Q-2≤q3≤Q)。Qm+r-q3m对m取模得到r。<br>问题<br>为什么是模b的k+1次方，为什么要求b&gt;3？ <span class="hide-inline"><button type="button" class="hide-button" style="">Click  </button><span class="hide-content">因为r1-r2＜3m，而m占据k位，如果需要r1-r2少于k+1位(极致地压低模的大小有利于计算速度)，则b>3。若b≤3，则r1-r2为负数时，不只需要加一次模。b的k+1次方，是能保证正确性下的，最方便计算的模数。</span></span><br>为什么r1和r2对非m取模，不影响正确性？ <span class="hide-inline"><button type="button" class="hide-button" style="">Click  </button><span class="hide-content">若m＝1，则结果为1；若m=2，则判断奇偶性；m≥3时，因为Q-q3≤2，且b的k+1次方大于2，故r1、r2对b的k+1次方取模后相减，不会影响正确的Q和q3的差值。加之r＜m＜b的k+1次方，故不会影响正确的r的大小。 实际上，我们并不需要关心Q和q3相差了多少和变没变。这个结果无非是m的系数，多减几次m便可以去除。但是，将Q-q3的结果控制在固定大小内，可以优化减m的速度。</span></span><br>为什么要求b&gt;k？ <span class="hide-inline"><button type="button" class="hide-button" style="">Click  </button><span class="hide-content">使q2的 k − 1位的进位最多是1，若 b 远大于 k，则只需包括 k 和 k+1位的计算。 q2 的低 k-1 位不用参与计算。**详细证明见回放**</span></span></p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>b</mi><mo>&#x3D;</mo><mn>4</mn><mo>,</mo><mi>k</mi><mo>&#x3D;</mo><mn>3</mn><mo>,</mo><mi>x</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>313221</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo>,</mo><mi>m</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>233</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo>&#x3D;</mo><msub><mn>3561</mn><mrow><mn>10</mn></mrow></msub><mo>，</mo><mi>m</mi><mo>&#x3D;</mo><msub><mn>47</mn><mrow><mn>10</mn></mrow></msub><mo stretchy="false">)</mo><mo>.</mo></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mfrac><mn>1</mn><mi>m</mi></mfrac><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>0.00111302</mn><mo>·</mo><mo>·</mo><mo>·</mo><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">⟹</mo><mrow><mo>µ</mo></mrow><mo>&#x3D;</mo><mo stretchy="false">⌊</mo><mfrac><msup><mn>4</mn><mrow><mn>6</mn></mrow></msup><mi>m</mi></mfrac><mo stretchy="false">⌋</mo><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>1113</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo>,</mo></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>x</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>313221</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">⟹</mo><mi>q</mi><mn>1</mn><mo>&#x3D;</mo><mo stretchy="false">⌊</mo><mfrac><mi>x</mi><msup><mn>4</mn><mrow><mn>2</mn></mrow></msup></mfrac><mo stretchy="false">⌋</mo><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>3132</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo>,</mo></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>q</mi><mn>2</mn><mo>&#x3D;</mo><mrow><mo>µ</mo></mrow><mo>·</mo><mi>q</mi><mn>1</mn><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>10231302</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">⟹</mo><mi>q</mi><mn>3</mn><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>1023</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>x</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>313221</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">⟹</mo><mi>r</mi><mn>1</mn><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>3221</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>q</mi><mn>3</mn><mo>·</mo><mi>m</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>313011</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">⟹</mo><mi>r</mi><mn>2</mn><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>3011</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo>,</mo></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>r</mi><mo>&#x3D;</mo><mi>r</mi><mn>1</mn><mo>−</mo><mi>r</mi><mn>2</mn><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>210</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub></math></p><p>故 x mod m &#x3D; 36。</p><p>参考：<br>1.<a href="http://t.csdnimg.cn/prAaS" title="" target="">CSDN：蒙哥马利约减</a><br>2.<a href="https://blog.csdn.net/mutourend/article/details/95613967?fromshare=blogdetail&sharetype=blogdetail&sharerId=95613967&sharerefer=PC&sharesource=lemonsed&sharefrom=from_link" title="" target="">CSDN：Montgomery reduction——多精度模乘法运算算法</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到第九边缘</title>
      <link href="/posts/6b6b7c33.html"/>
      <url>/posts/6b6b7c33.html</url>
      
        <content type="html"><![CDATA[<script>    (function(d, w, c) {        w.ChatraID = 'D5JbrYK4vHavdTNTf';        var s = d.createElement('script');        w[c] = w[c] || function() {            (w[c].q = w[c].q || []).push(arguments);        };        s.async = true;        s.src = 'https://call.chatra.io/chatra.js';        if (d.head) d.head.appendChild(s);    })(document, window, 'Chatra');</script><h2 id="一、什么是第九边缘文化体系"><a href="#一、什么是第九边缘文化体系" class="headerlink" title="一、什么是第九边缘文化体系"></a>一、什么是第九边缘文化体系</h2><p>“第九边缘是什么？相信并不是所有人都能够意识到。包括我们的代理者，也不能轻易做出一个明确的定义。或许，第九边缘并不符合他们的文化倾向。但在我们的世界里，第九边缘意味着“理性的文化”。它作为一个哲学符号，又或者是文明的动态象征，第九边缘的创造物意味着我们整个世界的智慧与现实。创造意味着新生，意味着第九边缘带来与现实截然不同的选择，记录意味着同步，意味着第九边缘的描述符合我们世界的基本认知，感知意味着神觉，意味着第九边缘存在超出我们世界的看法。在我们的世界里，虚构的文化太多，越来越多的人不重视实际存在的文明。随处可见的新文化，正在抹除文明本身的重量，使人们轻薄于学习既有的事物，去了解既有的历史。我们急需一种代表，能够保存我们的实际文明的同时，吸引绝大多数人们接纳我们的现实世界。这就是第九边缘，一个虚拟的科研组织，一个文明的汇聚之核。”（来自第九边缘：创世档案）<br>这是来自《创世档案》中的描述。可见，我们一直在回避这个问题。究其原因，是我们未曾拥有真实的历史。具体而言，第九边缘诞生于初中的一次灵感，又或者发源自一个初中生对虚构式未来的幻想。<br>我们在幻想世界的途中，融入了太多太多的元素。从自然、世界、人生，到风格、测试、涵养，我们融合了我们所认可的人类文化，也在尽我们所能塑造人类文化的一角。<br>但万事万物，如果一旦将其落在纸笔之上，就会拥有一个独属于它的定义。否则，我们无法认识到自己在做什么。<br>简单来说，<strong>第九边缘文化体系是一种理性的、规范的世界哲学体系，是立足于内在自我的，看待世界的一种立场、观点、方法。</strong><br>我们正式地在其后加上“体系”两字，是因为我们已经准备好向大众展示我们的世界。“体系”不仅意味着第九边缘从虚构世界的“科研团体”走出，而且意味着我们打算以一种成体系的方式展示我们的构造之物。<br>下面，我们将介绍第九边缘文化体系的构成。（在不引起争议时，我们将第九边缘文化体系简称为第九边缘）</p><h3 id="（一）-第九边缘理论研究及文章创造（SCHNIE）"><a href="#（一）-第九边缘理论研究及文章创造（SCHNIE）" class="headerlink" title="（一）.第九边缘理论研究及文章创造（SCHNIE）"></a>（一）.第九边缘理论研究及文章创造（SCHNIE）</h3><p>第九边缘的理论包含世界宇宙观，人生价值观，五维能力测试等部分，文章包含灵耀体系，九虹重启，三大规划等部分。<br>SCHNIE既从生活中提炼一些理性规则，也从一些典籍中寻找构建神话体系的力量。我们有批判，有引导，但同时也有激进，有妥协。我们需要不断面对自己的不足，也希望读者能够成为我们不断前行的后备力量。</p><h3 id="（二）-第九边缘内容椽笔及平台建设（SCHNIEBOW）"><a href="#（二）-第九边缘内容椽笔及平台建设（SCHNIEBOW）" class="headerlink" title="（二）.第九边缘内容椽笔及平台建设（SCHNIEBOW）"></a>（二）.第九边缘内容椽笔及平台建设（SCHNIEBOW）</h3><p>理论需要从实践中得到证实。<br>世界也需从运作中不断获取新的活力。第九边缘的平台包含QQ群，QQ频道，QQ发布号，官方网站，官方bilibili账号，微信公众号等。即便我们没有专业的力量协助，也能够构建出一个模糊但缺失专业性的框架。<br>我们迫切地需要外界的帮助，因为我们不擅长宣传自己。即便为了个数而扩展影响与我们的理性理念背道相驰，但我们的体系经过长期的理论积压，很难能够找出其中不断放大的缺陷。<br>世界总是完整的，而我们的体系注定如彩虹一般，只有部分流露在外。这是一种自我保护，也是一种保守底牌的策略。但我们由衷地希望，我们呈现出的那些光彩，能够照亮每一个需要的角落。<br>而这些角落，依赖大家的视线，依赖大家共同撑起的网络。</p><h3 id="（三）-第九边缘体系内核（schrodingerXI）"><a href="#（三）-第九边缘体系内核（schrodingerXI）" class="headerlink" title="（三）.第九边缘体系内核（schrodingerXI）"></a>（三）.第九边缘体系内核（schrodingerXI）</h3><p>极简，精确，相和，理性。<br>不添加多余之物，以最直接的方式逼近事物的内核；不被表象和偏见迷惑，以最关键的力量冲击事物的本质；与世界共生，与同伴共进，保持理性，不断前行。<br>感知，记录，创造。<br>感知是万物存在的标志，记录是万物运行的轨迹，创造是万物变化的结果。三生万物，竞逐方舟。<br>第九边缘，是人与世界共同的体系。</p><h3 id="（四）-第九边缘模组使用协议（DLXII）"><a href="#（四）-第九边缘模组使用协议（DLXII）" class="headerlink" title="（四）.第九边缘模组使用协议（DLXII）"></a>（四）.第九边缘模组使用协议（DLXII）</h3><p>与一般的“小说”不同的是，第九边缘的世界构造并不是由我们独立编辑，而是由探索者共同编辑的。我们共享我们的世界，也需要大家的共同维护。<br>读者们可以在原作的基础上进行修改，并著以第九边缘的标识进行传播。但不得添加其他的限制条件，不得以此谋利，不得申请版权及发布在小说网站，也不得转嫁责任给其他维护者。<br>我们尊重你从中获取灵感的权益，也尊重你作为一个独立创作者的权益。<br>在这种方式下，有一个显著的好处：第九边缘的世界构造，更能够接近我们所追求的“理性”—从最大程度上避免因偏见，知识面不全而造成世界构造的疏漏。这也符合我们追求效率这一原则。<br>我们诚恳地邀请您协助我们构建那个世界。在这里，我们将共享所有的与世界构造有关的内容，您可以查阅后以自己的理解来补充或创造新的内容。</p><hr><h2 id="二、第九边缘的起源和发展"><a href="#二、第九边缘的起源和发展" class="headerlink" title="二、第九边缘的起源和发展"></a>二、第九边缘的起源和发展</h2><p>正如上文所言，第九边缘来自于一个灵感。虽然我们不能够从我们的发展历史中获得自信—我们的实践来自于对内在世界的不断探索，而非体现在对外部世界的探究和改造。我们也缺乏专业的素养，甚至，第九边缘的整个世界，都来自于一份稚嫩的猜想。<br>不过，我们希望保持这种落后性。第九边缘不是某些哲学思想的复制品，也不是一类哲学思想的整合。我们希望这些显有稚嫩的个人偏见，能够成为读者世界观，人生观，价值观参照或批判的一部分。<br>第九边缘在2021年推出了《设定合集》，其主体内容是我们认为的值得分享的美好事物；并在2022年推出了《以神之名》：它的出现意味着我们的哲学内核，即世界观，人生观，自然观趋于成熟。<br>在2023年，大学生活打开了我们走向世界的大门，我们推出了《梦境疗法》，我们第一次以一种伪互动的文体向读者展示我们的构造世界。<br>而2024年所著的《第九边缘文化体系：概论》则采用了思政类“教科书”的特点：分条分点，逐步递进，全文关联。<br>在创作这本书的念头诞生前，我们也曾建立过QQ群，以诸多文件为载体，分享我们的世界。但结果不尽乐观：读者们似乎对这种“莫名其妙”的分类不具有兴趣，而且难以理解高度凝练到过于抽象的思想逻辑。<br>即便第九边缘一直试图在具体的事情中探索抽象，而非在抽象的逻辑中强求具体，但我们选取的被当做“具体”的对象，对于第一次接触我们的人而言，还是过于晦涩抽象。<br>故我们需要一个引导者，一个忠实的、不厌其详的引导者，将我们的创造物分散到各个篇章，以一种更加科学合理的方式，引导读者认识并认知我们的世界。</p><hr><h2 id="三、九大课题"><a href="#三、九大课题" class="headerlink" title="三、九大课题"></a>三、九大课题</h2><p>提出诸多概念，指出多种模型，归根结底是为了回答一些问题。第九边缘认为我们需要回答九个课题。<br>1.开端也是结局：世界，无比真实，回答对世界本质的整体把握的课题。第九边缘认为世界无所谓真实与虚幻，我们希望能够活在属于自己的理念世界里。读者们可以思考：万物客观存在，还是受限于观测者？事物性质是可知的，还是不可明确？事物根本上是统一的，还是各自划分区域？<br>2.稳定但是多变：思维，融于物质，回答对事物逻辑的规范划分的课题。第九边缘认为世界由物质构成，可物质以思维为形式，投递到我们的意识之中。读者们可以思考：事物有哪些存在方式，他们之间的联系是什么？我们能获得哪些信息，他们之间的联系是什么？事物间有哪些关系，这些关系的联系是什么？<br>3.世界起源：能量与时间差，回答发展与起源的课题。第九边缘认为能量不均导致时间流动，而时间流动激化思维，进一步演变成物质。读者们可以思考：发展和更替是无限的，还是存在端点？起源和覆灭是明确的，还是混沌一体？<br>4.矛盾产生：这成必要决断，回答选择与取向的课题。第九边缘认为矛盾的出现，使万物万事凝聚成该有的形状。读者们可以思考：真理和价值是客观规定的，还是个性化选择？理论和认知是逐步完善的，还是虚构的逻辑？<br>5.故事开端：我们为何生活，回答生存与生活的课题。第九边缘认为生活是社会赋予的职责，同时也能填补不平衡的内心。读者们可以思考：在你的世界观里，维持生存有哪些必然因素？在你的世界观里，追求生活有哪些不同方式？<br>6.恪守本分：臣服乃是前提，回答社会与自我的课题。第九边缘认为在有能力质疑或改变一件事之前，必经臣服。读者们可以思考：外界秩序和更优策略发生冲突时，如何处理？社会道德和个人判断发生冲突时，如何评判？<br>7.维系深井：认知存在局限，回答实力和认知的课题。第九边缘认为智慧徒增伤感，没有实力之前，请甘于维护愚昧。读者们可以思考：实力不足以支撑认知时，认知是什么地位？所处环境不认可实力时，实力是什么地位？<br>8.遗忘但是存在：意识，还是事实，回答对自我存在的空泛认知的课题。第九边缘认为承载已发生之事的记忆，决定着“我”是谁。读者们可以思考：自我和他我的界限是什么？不同阶段自我界限是什么？“自我”的概念依赖什么而产生？<br>9.终端也是启程：世界，本成一线，回答对一切概率的均衡判决的课题。第九边缘认为所有可能都在实际发生，我们做出的选择，是一场场自己与自己的争斗。读者们可以思考：万事皆可存在，还是依赖逻辑？事物早已决定，还是无限可能？追求注定随生命而消逝的未来，究竟是为了什么？</p><hr><h2 id="四、如何看待第九边缘世界"><a href="#四、如何看待第九边缘世界" class="headerlink" title="四、如何看待第九边缘世界"></a>四、如何看待第九边缘世界</h2><p>现实存在着混沌、泥泞、内卷、腐败。不如向内看，广泛而自由地肯定自己的精神价值，从认可自我开始，从改变认知方式开始，重新观察世界，探索世界，改变世界。<br>第九边缘文化体系绝不是是什么严肃的文化依托，也不是什么专业的产物。它更像是一种建议，建议我们的读者以某种被建议的方式认识世界，改造世界，从而在探索世界中获得乐趣，在研究世界中获得感触。<br>没有人的偏见是理所当然的，但当我们质疑一种不合理时，自身的理性直觉从未是一种理由。我们希望读者们能够有原因地指出我们的缺点，我们乐于在不断改正中前行。<br>向后看是为了把握外壳，向前看是为了赋予生命。那么，就让我们从这里开始：<br>追溯，启航！</p><hr><h2 id="参考书下载"><a href="#参考书下载" class="headerlink" title="参考书下载"></a>参考书下载</h2><a href="https://www.sch-nie.com/core/" title="" target="">第九边缘文化体系概论</a>]]></content>
      
      
      <categories>
          
          <category> 世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SCHNIE </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
