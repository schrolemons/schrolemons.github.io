<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MP有限状态自动机和AC自动机</title>
      <link href="/posts/2853a062.html"/>
      <url>/posts/2853a062.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note primary flat"><h2 id="模式匹配自动机"><a href="#模式匹配自动机" class="headerlink" title="模式匹配自动机"></a>模式匹配自动机</h2></div><p>什么是有限状态自动机？<br>定义n个不同状态，记为{1,2…n}，在状态i时输入s，达到状态j，记为goto(i,s)&#x3D;j<br>对于字符串s而言，在一个状态i下输入一个字符ch，也会达到一个<mark class="hl-label blue">指定状态</mark> ：<br>假定新的状态为串s[1,i]+ch的<mark class="hl-label red">最长相等前后缀</mark> ，便能够用这个状态机模拟KMP算法匹配字符串的过程。<br>当字符集仅为a、b时，有：<br><img src="/study/youxian.png" alt="自动机"><br>其中goto(4,a)&#x3D;3，也就是说abab+a的<mark class="hl-label red">最长相等前后缀</mark> 对应的状态是<mark class="hl-label blue">状态3</mark> ，也即表示字符串“aba”的状态。<br>似乎这样就足够了。<br>我们获得了goto函数，定义为：</p><blockquote><p>goto(Si,a)：串s[1,i]a的最长相等前后缀。</p></blockquote><p>为了得到这个goto函数的值，我们需要定义fail函数：</p><blockquote><p>fail(Si):串s[1,i]的最长相等前后缀。</p></blockquote><p>因为得到goto(i,a)的前提是，知道s[1,i]的<mark class="hl-label red">最长相等前后缀s\[1,j]</mark> ：若s[j+1]与a相同，则goto(i,a)&#x3D;j+1，否则求s[1,j]的最长相等前后缀，直到长度为0。<br>为了表示“s[j+1]与a相同”这一条件，定义函数：</p><blockquote><p>follow(Si, a):状态Si输入a后，来到下一个状态。</p></blockquote><p>对于字符串abcde，follow(0,a)&#x3D;1,follow(1,b)&#x3D;2,follow(2,c)&#x3D;3…以此类推，而其他值未定义。<br>到这里，goto函数就可表示为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">state <span class="title">go_to</span><span class="params">(state s,<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">follow</span>(s,ch)未定义)</span><br><span class="line">    &#123;</span><br><span class="line">        s=fail[s];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">follow</span>(s,ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>若s为模式串的状态，ch为s的后继字符，则这一goto值可当做新的fail值。</p><p>未定义状态，比如follow(0,b),计为0可不可行？<br>与之配套地，fail(0),计为0，也就是说空串的<mark class="hl-label red">最长相等前后缀长度</mark> 为0。<br>若fail(0)记为-1，则follow(s&#x3D;&#x3D;-1,ch)将陷入故障状态：没有状态被记为-1。<br>问题出现了！函数不得不进入死循环：因为s一直为0。<br>破环方式也很简单：</p><blockquote><p>引入状态-1，未定义状态记为-1，fail(0)&#x3D;-1，follow(-1,任何字符)&#x3D;0。</p></blockquote><p>这样，当计算ab+c的<mark class="hl-label red">最长相等前后缀</mark> 时，便能够得到go_to(2,c)&#x3D;0。<br>类似地，计算fail的函数为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Compute_fail</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fail</span>(s0) = ⊥;</span><br><span class="line">    s = s0;</span><br><span class="line">    <span class="keyword">for</span>( i =<span class="number">1</span> to |P| )&#123;</span><br><span class="line">        s = <span class="built_in">goto</span>(s, P[i]);</span><br><span class="line">        <span class="built_in">fail</span>(si) = s ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>goto和fail数组的关系：fail反映模式串中的某部分字符串的<mark class="hl-label red">最长相等前后缀</mark> ，goto反映文本串和模式串的匹配情况。诚然，fail数组可以通过goto函数得到，但记录一些中间状态有利于加速算法。<br>匹配函数为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Match</span>(t)</span><br><span class="line">&#123;</span><br><span class="line">    s= s0;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> to |T|)&#123;</span><br><span class="line">        <span class="keyword">if</span>( s 是终止状态 )</span><br><span class="line">           <span class="keyword">return</span> 匹配!</span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            s=<span class="built_in">goto</span>(s,T[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;     </span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note primary flat"><h2 id="MP有限状态自动机"><a href="#MP有限状态自动机" class="headerlink" title="MP有限状态自动机"></a>MP有限状态自动机</h2></div><p><del>我们都知道mp的c++写法。</del><br>基于以上定义，我们<del>艰难地</del>知道mp的有限状态自动机写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> state int</span></span><br><span class="line">string P; <span class="comment">//模式串</span></span><br><span class="line">string T;</span><br><span class="line">state fail[<span class="number">1000005</span>];</span><br><span class="line">state edge[<span class="number">1000005</span>][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">state <span class="title">follow</span><span class="params">(state s,<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(edge[s][ch-<span class="string">&#x27;A&#x27;</span>]==s<span class="number">+1</span>) <span class="keyword">return</span> s<span class="number">+1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">state <span class="title">go_to</span><span class="params">(state s,<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">follow</span>(s,ch)==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=fail[s];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">follow</span>(s,ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fail[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    state s_=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;P.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        s_=<span class="built_in">go_to</span>(s_,P[i]);</span><br><span class="line">        fail[<span class="built_in">state</span>(i)]=s_;</span><br><span class="line">        </span><br><span class="line">           <span class="keyword">if</span>(fail[s_]!=<span class="number">-1</span>&amp;&amp;P[s_<span class="number">+1</span>]-<span class="string">&#x27;A&#x27;</span>==P[i<span class="number">+1</span>]-<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            fail[<span class="built_in">state</span>(i)]=fail[s_];</span><br><span class="line">        &#125;<span class="comment">//！！！K优化！！！</span></span><br><span class="line">        </span><br><span class="line">        edge[i<span class="number">-1</span>][P[i] - <span class="string">&#x27;A&#x27;</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">match</span><span class="params">()</span></span>&#123;</span><br><span class="line">    state s_=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;T.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        s_=<span class="built_in">go_to</span>(s_,T[i]);</span><br><span class="line">        <span class="keyword">if</span>(s_==<span class="built_in">state</span>(P.<span class="built_in">size</span>()<span class="number">-1</span>))&#123;</span><br><span class="line">            cout&lt;&lt;i-P.<span class="built_in">size</span>()<span class="number">+2</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;T&gt;&gt;P;</span><br><span class="line">    P=<span class="string">&quot; &quot;</span>+P;</span><br><span class="line">    T=<span class="string">&quot; &quot;</span>+T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_fail</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">match</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;P.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    cout&lt;&lt;fail[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>洛谷提交情况如下： <a class="btn-beautify " href="https://www.luogu.com.cn/record/182533994"   title="洛谷"><span>洛谷</span></a><br>这是一种没有任何实战意义的写法。<br>需要注意俩点：</p><blockquote><p>if(edge[s][ch-‘A’]&#x3D;&#x3D;s+1) return s+1;</p></blockquote><p>只有计算fail函数时，遍历过某个字符时，才连一条edge边。<br>也就是说，在未遍历时，字符串abc的follow(0,a)&#x3D;-1,follow(1,b)&#x3D;-1,follow(1,c)&#x3D;-1,而当遍历<strong>过</strong>b时，follow(0,a)&#x3D;1,follow(1,b)&#x3D;2,follow(1,c)&#x3D;-1。这样做的原因是，若模式串天然有follow边，则fail数组的值会依次为-1,1,2,3,4…</p><blockquote><p>if(fail[s_]!&#x3D;-1&amp;&amp;P[s_+1]-‘A’&#x3D;&#x3D;P[i+1]-‘A’){<br>fail[state(i)]&#x3D;fail[s_]; }</p></blockquote><p>这是knuth优化。对于字符串aaaa，mp的fail数组是0,1,2,3而kmp的fail数组是0,0,0,3。<br>因为kmp的fail数组不能很好地反映字符串的前后缀的关系，而我们通常需要利用这种关系，故现常用mp，且把mp称为kmp。</p><p>MP算法是一个O(m+n)的算法，证明如下：</p><blockquote><p>1.在check函数中，对文本串扫描一遍，无回头扫描，消耗O(n)<br>2.自动机向右的移动距离 &gt;&#x3D; 向左移动的距离&gt;&#x3D;调用fail的次数，而向右的移动距离&#x3D; 对文本串扫描的距离&#x3D;n，故调用fail的次数&#x3D;O(n)<br>3.构造fail数组时，向右的移动距离&#x3D; 对模式串扫描的距离&#x3D;m，即Fail构造复杂度的复杂度为O(m)</p></blockquote><p>综合为O(m+n)。实际上，除了aaab匹配aaaaaaaa这种极端数据外，mp和暴力算法复杂度接近：随机情况下，暴力的复杂度也接近O(m+n)，在数据随机生成的情况下，暴力匹配也基本很快就会失配。</p><div class="note primary flat"><h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2></div><p>虽然MP有限状态自动机看起来多此一举，但可以很便捷地理解AC自动机。<br>AC自动机要完成以下任务，对于一系列字符串t1，t2，t3，判断他们在文本串s中是否出现。<br>当然，可以跑3次mp算法，但这太过于漫长。<br>AC自动机需要利用字典树 <a class="btn-beautify " href="https://www.luogu.com.cn/problem/P8306"   title="字典树"><span>字典树</span></a>。<br>建树如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> noww)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s[noww].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(AC_[now].a[s[noww][i]-<span class="string">&#x27;a&#x27;</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">            now=AC_[now].a[s[noww][i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            AC_[now].a[s[noww][i] - <span class="string">&#x27;a&#x27;</span>] = ++cnt;</span><br><span class="line">            now=AC_[now].a[s[noww][i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    AC_[now].end.<span class="built_in">push_back</span>(noww);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当我们建立好字典树时，也需要fail数组的值：<br>注意：AC自动机的fail数组，其前缀和后缀未必出现在同一模式串上。如：<br><img src="/study/zidian.png" alt="字典树"><br>fail(7)&#x3D;8,虽然6来自单词iris，4来自单词is。这样做的目的是，当匹配到iris时，也能匹配到可能的模式串is。<br>这就需要我们打一个标记，来记录“is”是不是模式串。<br>和上面同样的问题，计算fail就需要利用之前的fail值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AC_[<span class="number">0</span>].fail=<span class="number">0</span>; <span class="comment">//0的fail是0</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(AC_[<span class="number">0</span>].a[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            AC_[AC_[<span class="number">0</span>].a[i]].fail=<span class="number">0</span>;  <span class="comment">//第一层字母的fail是0，因为不存在最长相等前后缀</span></span><br><span class="line">            q.<span class="built_in">push</span>(AC_[<span class="number">0</span>].a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按层由浅到深递增填写fail函数</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> iq=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(AC_[iq].a[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                AC_[AC_[iq].a[i]].fail=AC_[AC_[iq].fail].a[i]; <span class="comment">//只计算一次，就能得到fail函数</span></span><br><span class="line">                q.<span class="built_in">push</span>(AC_[iq].a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                AC_[iq].a[i]=AC_[AC_[iq].fail].a[i]; <span class="comment">//将AC自动机转化为模式匹配自动机，全部字母都对应跳转边，比AC自动机需要更多的空间</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模式匹配自动机</strong>带来的优化:<br>当文本串是“iris<strong>i</strong>s”时，因为AC_[7].fail&#x3D;8,goto(8,i)&#x3D;0,follow(0,i)&#x3D;4，故新的状态为4。<br>否则，计算goto(8,i)&#x3D;0,再计算goto(0,i)&#x3D;4，就需要经过不止两次goto，而非固定的<strong>一次</strong>goto。<br>时间复杂度分析：</p><blockquote><p>AC自动机构造算法时间复杂为 O(|P|)，|P|模式集合中模式的长度之和</p></blockquote><blockquote><p>模式匹配搜索时间复杂 O(n + occ)，occ为模式出现次数(因为状态需要通过fail函数跳跃)</p></blockquote><p>问题：T&#x3D;aaaaaaaa，P&#x3D;{a,aa,aaa,aaaa,aaaa}时，搜索复杂度是多少？</p><p>check函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ss.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        now=AC_[now].a[ss[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=now;j!=<span class="number">0</span>&amp;&amp;AC_[j].end!=<span class="number">-1</span>;j=AC_[j].fail)&#123;</span><br><span class="line">            ans+=AC_[j].end;</span><br><span class="line">            AC_[j].end=<span class="number">-1</span>;  <span class="comment">//防止重复计数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><a class="btn-beautify " href="https://www.luogu.com.cn/record/182415813"   title="AC自动机简单版"><span>AC自动机简单版</span></a><p>优化：<br>使用拓扑排序，不进行fail跳跃(以下check是统计出现了几次，上面check是统计出现了几种)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">topu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="type">int</span> iq=q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">        jishu[AC_[iq].num]+=AC_[iq].ans;</span><br><span class="line">    AC_[AC_[iq].fail].ans+=AC_[iq].ans;</span><br><span class="line">    in[AC_[iq].fail]--;</span><br><span class="line">    <span class="keyword">if</span>(in[AC_[iq].fail]==<span class="number">0</span>) q.<span class="built_in">push</span>(AC_[iq].fail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ss.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        now=AC_[now].a[ss[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">            AC_[now].ans++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topu</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a class="btn-beautify " href="https://www.luogu.com.cn/record/182422907"   title="AC自动机"><span>AC自动机</span></a><p>设n为文本长度，k是模式数量，则：<br>最好匹配次数为n<br>最坏匹配次数为(1+n)*n&#x2F;2+n²-nk<br>AC自动机</p><div class="note primary flat"><h2 id="比特并行算法"><a href="#比特并行算法" class="headerlink" title="比特并行算法"></a>比特并行算法</h2></div><p>比特并行：一个机器字操作，能对所有比特进行改变。</p><h4 id="非确定自动机NFA"><a href="#非确定自动机NFA" class="headerlink" title="非确定自动机NFA"></a>非确定自动机NFA</h4><p>MP的非确定自动机：<br>同一时刻，不只有最长的前缀被匹配，更短的前缀也同时被匹配。<br>在DFA中，活跃状态只有一个，其他状态通过“后缀链”连接；而NFA中，他们都是活跃状态(空前缀永远是匹配的；每次匹配，都能得到一系列活跃状态的集合(用机器字代表这些集合，机器字的每一个比特代表一个前缀是否匹配))。<br>NFA中没有必要有后缀链存在，而是只存在向前的链接。</p><h4 id="举例：shift-and算法"><a href="#举例：shift-and算法" class="headerlink" title="举例：shift-and算法"></a>举例：shift-and算法</h4><p>文本串为ababb，模式串为abab，则状态变化为：</p><table><thead><tr><th>轮次\前缀</th><th>a</th><th>ab</th><th>aba</th><th>abab</th></tr></thead><tbody><tr><td>初始D表</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>输入a后D表</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>输入b后D表</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>输入a后D表</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>输入b后D表</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>输入b后D表</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>形式化：设B[a]表示a在模式串存在的位置，即{1,0,1,0}，B[b]表示b在模式串存在的位置，即{0,1,0,1}，每次变化计为：<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>D</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mi>D</mi><mo>&gt;&gt;</mo><mn>1</mn><mo stretchy="false">)</mo><mrow><mo stretchy="false">|</mo></mrow><mn>1</mn><mo>按位与</mo><mi>B</mi><mo stretchy="false">[</mo><msub><mi>t</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">]</mo></math><br>第一次移位得到可能活跃的集合，第二次取交得到活跃的集合。<br>shift-or：以0代表匹配，1代表不匹配。B[a]表示a<strong>不在</strong>模式串存在的位置，即{0,1,0,1}，B[b]表示b在模式串存在的位置，即{1,0,1,0}(D向量初始全1)：<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>D</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mi>D</mi><mo>&gt;&gt;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>按位或</mo><mi>B</mi><mo stretchy="false">[</mo><msub><mi>t</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">]</mo></math></p><mark class="hl-label red">注意：字符串是小端顺序，D、B向量是大端顺序：以上移位都应该向左移位</mark> <h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>比特并行算法能很好地处理通配符匹配问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line">string P;</span><br><span class="line">string T;</span><br><span class="line">bitset&lt;1000005&gt; B[<span class="number">256</span>];</span><br><span class="line">bitset&lt;1000005&gt; D=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;P&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;P.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        B[P[i]][i]=<span class="number">1</span>;</span><br><span class="line">        B[(<span class="type">int</span>)<span class="string">&#x27;-&#x27;</span>][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(P[i]==<span class="string">&#x27;a&#x27;</span>||P[i]==<span class="string">&#x27;b&#x27;</span>)&#123;   <span class="comment">//-和任意字符匹配，*和a，b匹配：当然，也可以随意指定</span></span><br><span class="line">            B[(<span class="type">int</span>)<span class="string">&#x27;*&#x27;</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(P[i]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            B[(<span class="type">int</span>)<span class="string">&#x27;a&#x27;</span>][i]=B[(<span class="type">int</span>)<span class="string">&#x27;b&#x27;</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(P[i]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">256</span>;j++)&#123;</span><br><span class="line">                B[j][i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        D=D&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        D[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        D=D&amp;B[T[i]];</span><br><span class="line">        <span class="keyword">if</span>(D[P.<span class="built_in">size</span>()<span class="number">-1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;success at &quot;</span>&lt;&lt;i-P.<span class="built_in">size</span>()<span class="number">+1</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;fail&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a-a*cc</span></span><br><span class="line"><span class="comment">//*a-b--</span></span><br><span class="line"><span class="comment">//匹配成功</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>NFA需要硬件支持并行机制，空间占用小；<br>DFA只需要串行操作，空间占用大。<br>参考资料：<br>1.<a href="https://blog.csdn.net/aoke1952/article/details/101609109" title="" target="">kmp和mp</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BM算法(手算版)</title>
      <link href="/posts/f093fa41.html"/>
      <url>/posts/f093fa41.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note primary flat"><h2 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h2></div><p>BM算法是一种字符串匹配的算法。<br>与KMP相比，BM算法不扫描全部输入字符，平均匹配时间c·n, 常量 c &lt;1 (随机或真实文本), 但最坏情况是O(n·m).<br>可以将BM算法的最坏情况改进到O(n)：通过记录文本后缀中最长的模式后缀。<br>要使用BM算法，需要知道两个信息：<br><strong>1.用于坏字符规则的bc数组</strong><br><strong>2.用于好后缀规则的gs数组</strong></p><div class="note info flat"><h2 id="坏字符规则"><a href="#坏字符规则" class="headerlink" title="坏字符规则"></a>坏字符规则</h2></div><p>坏字符规则分为两种情况：<br>1.失配位置指向的<mark class="hl-label red">文本串中对应的字符</mark> ，不存在于模式串中。<br><img src="/study/huai2.png" alt="坏字符"><br>如上图所示，在这种情况下，直接将整个模式串移动到<mark class="hl-label red">失配位置</mark> 之后。</p><p>2.失配位置指向的<mark class="hl-label red">文本串中对应的字符</mark> ，存在于模式串中，且在<mark class="hl-label red">失配位置</mark> 的左边。<br><img src="/study/huai1.png" alt="坏字符"><br>如上图所示，在这种情况下，将模式串中的<mark class="hl-label red">文本串中对应的字符</mark> 放在<mark class="hl-label red">失配位置</mark> 上。<br>需要注意两个问题：<br>1.这个“模式串中的<mark class="hl-label red">文本串中对应的字符</mark> ”，是整个模式串从<strong>右往左数</strong>的第一个符合的字符。否则会造成过度左移。<br>2.模式串中最后一个字符，不能和任何的<mark class="hl-label red">失配位置</mark> 匹配。这是因为“失配”的前提是有匹配，而右边第一个字符必然被匹配；否则在右边第一个字符失配，那说明所需要的字符不是这个右边的第一个字符。故最后一个字符对应的位置是从右边数<strong>第二个符合数</strong>的位置。<br>如字符串“GCAGAGAG”的坏字符表为(从0开始计数,<strong>从右往左</strong>数)：</p><table><thead><tr><th>char</th><th>A</th><th>C</th><th>G</th><th>T</th></tr></thead><tbody><tr><td>bc[char]</td><td>1</td><td>6</td><td><mark class="hl-label blue">2</mark> </td><td>8</td></tr></tbody></table><p>坏字符表不是一直有效的。如果坏字符表中记载的位置，在<mark class="hl-label red">失配位置</mark> 的<strong>右边</strong>，那么可能会造成负位移或原地不动。<br>一个解决方法是，记载每次<mark class="hl-label red">失配位置</mark> 的<strong>左边</strong>的第一个符合的字符：但这很麻烦。<br>这并不是说位移就是上表的值。位移&#x3D; <strong>bc[char]-失配位置Z</strong>。(从右往左数，0开始)</p><div class="note info flat"><h2 id="好后缀规则"><a href="#好后缀规则" class="headerlink" title="好后缀规则"></a>好后缀规则</h2></div><p>好后缀规则分为3种情况：<br><img src="/study/hao.png" alt="坏字符"><br>rule3：</p><blockquote><p>如图14.1，目前匹配好的后缀u，在模式串中存在。如果有多个，则取最靠右的且c！&#x3D;a的那个，并将其对齐。</p></blockquote><p>rule2：</p><blockquote><p>如图14.2，目前匹配的好后缀u，在模式串中其他位置<strong>不存在</strong>。但它的后缀，和模式串的前缀相同。如果有多个满足的后缀，则取最长的那个后缀，并将其对齐。</p></blockquote><p>rule1：</p><blockquote><p><del>如图14.？</del>，目前匹配的好后缀u，在模式串中其他位置<strong>不存在</strong>。且它的每一个后缀，和模式串的前缀都<strong>不相同</strong>。这种情况下，直接将整个模式串移动到当前的<strong>最右端</strong>之后。</p></blockquote><p>好后缀规则和坏字符规则是可以同时使用的，我们每次取俩者中<strong>最大</strong>的那个。<br>如坏字符规则一样，好后缀也有自己的表，叫做gs数组。要想得到gs数组，首先要利用suff数组。</p><blockquote><p>suff数组:存储从字符s[i]向左开始计数的，和模式串最右边字符开始的匹配的字符个数。</p></blockquote><p>如字符串“GCAGAGAG”的suff为(从0开始计数)：</p><table><thead><tr><th>G</th><th>C</th><th>A</th><th>G</th><th>A</th><th>G</th><th>A</th><th>G</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>0</td><td>2</td><td>0</td><td>4</td><td>0</td><td>8</td></tr></tbody></table><p>从右往左看：<br>从G开始，GAGAGACG与GAGAAGACG匹配，个数是8，故填8。<br>从A开始，没有字符匹配(因为右边第一个字符是G)，故填0。<br>从G开始，GAGA(下一个是C)与GAGA(下一个是G)匹配，个数是4，故填4。<br>从A开始，没有字符匹配(因为右边第一个字符是G)，故填0。<br>从G开始，GA(下一个是C)与GA(下一个是G)匹配，个数是2，故填2。<br>从A开始，没有字符匹配(因为右边第一个字符是G)，故填0。<br>从C开始，没有字符匹配(因为右边第一个字符是G)，故填0。<br>从G开始，G(下一个是末尾)与G(下一个是A)匹配，个数是1，故填1。</p><p>接下来，我们依次处理rule1，rule2，rule3，来获得gs数组。<br>为什么是这个顺序：因为rule1位移&gt;rule2位移&gt;rule3位移，大的值被小的值取代，才不会造成<strong>过度右移</strong>。<br>具体的理解，可以见<a class="btn-beautify " href="https://www.cnblogs.com/YWT-Real/p/17120732.html"   title="高效字符串匹配算法"><span>高效字符串匹配算法</span></a><br><font color=red>施加rule1：</font><br>所有的项均有最大位移8(字符串长)：</p><table><thead><tr><th>G</th><th>C</th><th>A</th><th>G</th><th>A</th><th>G</th><th>A</th><th>G</th></tr></thead><tbody><tr><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td></tr></tbody></table><p><font color=red>施加rule2：</font><br>step1：从右往左扫描模式串，找到第一个下标(下标<strong>从左往右</strong>数，从0开始计。略过最右边的数)+1&#x3D;suff[i]的位置。对上面的例子来说，这个位置是“i&#x3D;0”，对应的是最左边的字符G。<br>step2：从左往右扫描字符串，将扫描过的位置对应的gs数组改为“当前值-suff[i]”，直到剩下suff[i]个字符。<br>step3：step继续向左，step2继续向右，直到扫描完成。</p><table><thead><tr><th>G</th><th>C</th><th>A</th><th>G</th><th>A</th><th>G</th><th>A</th><th>G</th></tr></thead><tbody><tr><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>8</td></tr></tbody></table><p><font color=red>施加rule3：</font><br>从左往右扫描字符串(略过最右边那个)，将gs[suff[i]]改为i(下标从右往左数，以0开始):</p><p>变化1：</p><table><thead><tr><th><mark class="hl-label blue">G</mark> </th><th>C</th><th>A</th><th>G</th><th>A</th><th>G</th><th>A</th><th>G</th></tr></thead><tbody><tr><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td><mark class="hl-label blue">7</mark> </td><td>8</td></tr></tbody></table><p>变化2：</p><table><thead><tr><th>G</th><th>C</th><th>A</th><th><mark class="hl-label blue">G</mark> </th><th>A</th><th>G</th><th>A</th><th>G</th></tr></thead><tbody><tr><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td><mark class="hl-label blue">4</mark> </td><td>7</td><td><mark class="hl-label red">5</mark> </td></tr></tbody></table><p>变化3：</p><table><thead><tr><th>G</th><th>C</th><th>A</th><th>G</th><th>A</th><th><mark class="hl-label blue">G</mark> </th><th>A</th><th>G</th></tr></thead><tbody><tr><td>7</td><td>7</td><td>7</td><td><mark class="hl-label blue">2</mark> </td><td>7</td><td>4</td><td>7</td><td><mark class="hl-label red">3</mark> </td></tr></tbody></table><p>变化4：</p><table><thead><tr><th>G</th><th>C</th><th>A</th><th>G</th><th>A</th><th>G</th><th><mark class="hl-label blue">A</mark> </th><th>G</th></tr></thead><tbody><tr><td>i&#x3D;0</td><td>i&#x3D;1</td><td>i&#x3D;2</td><td>i&#x3D;3</td><td>i&#x3D;4</td><td>i&#x3D;5</td><td>i&#x3D;6</td><td>i&#x3D;7</td></tr><tr><td>7</td><td>7</td><td>7</td><td>2</td><td>7</td><td>4</td><td>7</td><td><mark class="hl-label blue">1</mark> </td></tr></tbody></table><div class="note primary flat"><h2 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h2></div><p><img src="/study/shili1.png" alt="实例"><br>向右位移&#x3D;max(bc[A]-Z,gs[7])&#x3D;max(1-0,1)&#x3D;1;<br><img src="/study/shili2.png" alt="实例"><br>向右位移&#x3D;max(bc[C]-Z,gs[5])&#x3D;max(6-2,4)&#x3D;4;<br><img src="/study/shili3.png" alt="实例"><br>向右位移&#x3D;max(0,<mark class="hl-label blue">gs[-1---->0]</mark> )&#x3D;max(0,7)&#x3D;7;<br><img src="/study/shili4.png" alt="实例"><br>向右位移&#x3D;max(bc[C]-Z,gs[5])&#x3D;max(6-2,4)&#x3D;4;<br><img src="/study/shili5.png" alt="实例"><br>向右位移&#x3D;max(bc[C]-Z,gs[6])&#x3D;max(6-1,<strong>7</strong>)&#x3D;<strong>7</strong>;<br>附：对于字符串aaaaaa，其gs数组为{6,6,6,6,6，6}—&gt;{1,2,3,4,5,6}—–&gt;{1,2,3,4,5,6}。</p><div class="note primary flat"><h2 id="与kmp比较"><a href="#与kmp比较" class="headerlink" title="与kmp比较"></a>与kmp比较</h2></div><p>1.KMP算法的实际性能不好，一般实际中不用<br>2.BM速度快，但最快的BM类算法不是完整BM算法而是简化的版本(复杂度和效率的折中版本)<br>若模式串长为m，文本串长为n：<br>BM算法最好情况下比较m次，最坏情况下比较(n-m+1)*m次<br>MP算法最好情况下比较m次，最坏情况下比较(n-m+1)*m次<br>平均比较次数：？</p><p>参考内容：<br>1.<a href="https://blog.csdn.net/EQUINOX1/article/details/133256159" title="" target="">BM-c++</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：入侵检测系统</title>
      <link href="/posts/8c8bc191.html"/>
      <url>/posts/8c8bc191.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note primary flat"><h2 id="入侵检测系统概念"><a href="#入侵检测系统概念" class="headerlink" title="入侵检测系统概念"></a>入侵检测系统概念</h2></div><p>入侵：未经授权的计算机使用者以及不正当使用(misuse)计算机的合法用户(内部威胁)，危害或试图危害资源的完整性、保密性、可用性的行为。<br>入侵检测：通过监测计算机系统的某些信息，加以分析，检测入侵行为，并作出反应。<br>入侵检测系统：实现入侵检测功能的硬件与软件。<br>核心问题：降低误报率<br>结构：<br><img src="/study/ruqin.png" alt="入侵检测"><br>事件产生器（Event generater， E-box）收集入侵检测事件,并提供给IDS其他部件处理。事件可以是网络活动，也可是系统调用序列等系统信息。<br>事件分析器（Analysis engine, A-box）对输入的事件进行分析并检测入侵。<br>事件数据库（Event database, D-box）存储和管理E-boxes 和 A-boxes 产生的大量数据，用于IDS(入侵检测系统)的训练和证据保存。<br>事件响应器（Response unit, C-box）对入侵做出响应，包括向管理员发出警告，切断入侵连接，根除入侵者留下的后门以及数据恢复等。<br>分类：<br>误用检测(基于特征的检测)：判别当前行为是否符合<strong>已知攻击的知识库</strong>中记录的的攻击模式。机制：状态模型、专家系统、正则表达式匹配<br>异常检测(基于行为的检测)：建立用户的正常使用模式知识库，标识出不符合正常模式的行为。机制：统计、机器学习方法<br>混合检测</p><div class="note warning flat"><h2 id="入侵检测系统评价标准"><a href="#入侵检测系统评价标准" class="headerlink" title="入侵检测系统评价标准"></a>入侵检测系统评价标准</h2></div><p>处理高速网络流量的能力<br>自身抗攻击的能力<br>误报率和漏报率<br>协同事件的能力<br>检测新攻击的能力</p><div class="note primary flat"><h2 id="误报率-混淆矩阵"><a href="#误报率-混淆矩阵" class="headerlink" title="误报率-混淆矩阵"></a>误报率-混淆矩阵</h2></div><p><img src="/study/yic.png" alt="入侵检测"><br>误报率：误报的数量(正常情况下报告攻击，攻击情况下报告正常)占所有正常事件的比例。即蓝色部分占据的面积(正确的true，错误的false)。<br>现实中，攻击行为占比很少(TP+FN)。导致正确率很高的检测器可能有较高的误报率。<br>准确率：p&#x3D;(TP+TN)&#x2F;(TP+TN+FP+FN)，预测对的占总样本总数的比率<br>精确率：p&#x3D;TP&#x2F;(TP+FP)，预测为<strong>攻击</strong>，且预测对了占总预测为攻击的比率<br>漏报率：p&#x3D;FN&#x2F;(TP+FN)<br>报警的准确度：p&#x3D;TN&#x2F;(TN+FP)<br><strong>误报率</strong>：p&#x3D;FP&#x2F;(TN+FP)<br>(为什么误报率是最重要的指标？)</p><div class="note primary flat"><h2 id="网络入侵检测系统Snort"><a href="#网络入侵检测系统Snort" class="headerlink" title="网络入侵检测系统Snort"></a>网络入侵检测系统Snort</h2></div><p>开放型系统，采用误用检测，包含：网络包的解析器、检测引擎、日志和报警子系统。利用libpcap库作为捕获数据包的工具。<br>特点：<br>主要数据源：网络数据包<br>设计原则：简单、灵活、高性能<br>对包的处理：1.协议分析；2.模式匹配(单模式匹配、多模式匹配)、正则表达式匹配、非精确模式匹配(什么样的协议，检测什么样的内容。先进行协议分析：分层解析各层包头，从链路层，到传输层，直到应用层，协议分析可以显著地缩小检测模式范围，从而减少内容检查，提高了入侵检测的效率。分析内容(时间占比大)：先匹配出现概率小的，后匹配出现概率大的，先匹配关键字，后匹配变量。)<br>特征描述语言：可描述攻击行为(误用检测)<br>插件子系统：实现系统功能扩展<br>规则:<br>由规则头，规则选项构成。规则头指明协议和源目标IP地址等，对包进行简单处理；规则选项指明包数据中搜索的内容，对包进行细致处理。<br>最重要的两个规则选项：<br>content: 用于匹配固定字符串，适合匹配简单的特征。<br>pcre: 用于匹配复杂的模式，支持正则表达式，适合匹配灵活多变的攻击 payload。<br>结合使用: 将 content 和 pcre 结合使用，可以提高检测的准确性。例如，使用 content 匹配关键字，使用 pcre 匹配变量部分。</p><div class="note warning flat"><h2 id="针对IDS的拒绝服务类攻击"><a href="#针对IDS的拒绝服务类攻击" class="headerlink" title="针对IDS的拒绝服务类攻击"></a>针对IDS的拒绝服务类攻击</h2></div><p>问题：<br>IDS要在高速的网络上工作，使得DPI(深度网络数据包检测,深入到数据包的载荷处理。DPI的中心问题：高效多正则表达式匹配。虽然识别多表达式的DFA只对输入扫描一次 但两个DFA的合并，状态数可能为二者之积。)处理能力显著下降，发生丢包、漏报。且攻击模式更加复杂。<br>攻击：<br>超载攻击：<br>当网络流量超过IDS的处理能力时(如大量的复杂正则匹配)，IDS的处理能力将急剧下降甚至完全瘫痪。攻击者通过某些手段使网络流量达到饱和，迫使IDS大量丢包。这种攻击还可针对目标IDS系统采用的检测算法进行算法攻击。<br>资源耗尽攻击：<br>通过发送大量残缺TCP数据段以及IP分片耗尽IDS的存储资源(IDS需要存储一些中间状态)，使IDS不能正常工作。<br>算法复杂攻击：<br>使DPI算法进入最坏情况，造成拒绝服务。目前除了通过修改算法还没有其他有效的方法。<br>提高性能：<br>提高单机检测性能：<br>采用高效检测算法，如多模式匹配&#x2F;多正则表达式匹配算法<br>采用高性能硬件<br>多机并行：<br>网络流量的分割<br>处理任务的分割</p><div class="note primary flat"><h2 id="加密流量处理"><a href="#加密流量处理" class="headerlink" title="加密流量处理"></a>加密流量处理</h2></div><p>IDS可以检测包头，但无法深入检查。<br>解决方式：<br>SSL&#x2F;TLS解密（中间人方式）</p><blockquote><p>不安全：被加密的数据被解密</p></blockquote><p>元数据分析（Metadata Analysis）</p><blockquote><p>分析HTTPS流量的元数据（例如，SNI、流量模式、连接频率等）</p></blockquote><p>基于行为的异常检测（Anomaly-Based Detection）</p><blockquote><p>对正常流量模式建模，来识别与正常行为偏差较大的活动</p></blockquote><blockquote><p>恶意软件、数据泄露</p></blockquote><p>EDR（Endpoint Detection and Response，端点检测和响应）</p><blockquote><p>EDR部署在客户端设备上，可以直接查看未加密的流量和活动</p></blockquote><div class="note primary flat"><h2 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h2></div><p>模式匹配算法：<br>Brute Force算法，最坏情况 O(nm)<br>KMP算法<br>AC多模式匹配算法<br>Boyer-Moore算法<br>现代技术：<br>后缀树与后缀自动机<br>基于因子识别的算法<br>Bit并行算法与非标准模式匹配<br>应用领域：<br>病毒扫描、入侵检测、搜索引擎、大数据处理</p><p>参考资料：<br>1.<a href="https://catcoder.blog.csdn.net/article/details/95623289?fromshare=blogdetail&sharetype=blogdetail&sharerId=95623289&sharerefer=PC&sharesource=lemonsed&sharefrom=from_link" title="" target="">混淆矩阵</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：buffer overflow attack</title>
      <link href="/posts/1e6d162f.html"/>
      <url>/posts/1e6d162f.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note primary flat"><h2 id="堆栈构造"><a href="#堆栈构造" class="headerlink" title="堆栈构造"></a>堆栈构造</h2></div><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">静态存储</button><button type="button" class="tab " data-href="1-2">可变存储</button><button type="button" class="tab " data-href="1-3">函数调用</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>text segment存放代码；<br>data segment存放初始化了的静态变量；<br>BSS segment存放未初始化的静态变量。</p></div><div class="tab-item-content" id="1-2"><p>Heap存放需要长期保存的变量；<br>Stack存放临时变量。</p></div><div class="tab-item-content" id="1-3"><p>调用函数时，如f(int a,int b)：<br>则b放在大的正地址如ebp+12，a放在小的正地址如ebp+8，临时变量放在负地址如ebp-4。旧的ebp放在ebp+0，返回地址放在ebp+4。<br>这些数据构成一个<strong>栈帧</strong>。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2></div><p><img src="/study/neicun.png" alt="内存"></p><div class="note primary flat"><h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2></div><p><img src="/study/gj.png" alt="攻击"></p><blockquote><p>攻击原理：栈溢出时，能把以前的数据覆盖。</p></blockquote><blockquote><p>-攻击步骤1：在return address和攻击代码之间可写NOP；如果return address域指向的地址高于其自身的地址，则程序会沿着NOP走到攻击代码。(攻击代码足够短的话，也能放在return address之前)<br>-攻击步骤2：确定return address到栈底的偏移量，在这里将存放新的返回地址。<br>-攻击步骤3：在堆栈空间内找到存放攻击代码(操作寄存器的汇编代码)的地址。</p></blockquote><p>注意：字符串中的0会将字符串截断。解决：寄存器与寄存器自身异或获得数据0。<br>例子：<br><img src="/study/shell.png" alt="shell"><br>execve()的三个参数分别为”&#x2F;bin&#x2F;sh”、”&#x2F;bin&#x2F;sh NULL”、NULL，分别存在ebx,ecx,edx中，execve()函数本身的代码放在eax中。<br>上述代码激活时，栈会随代码运行而发生变化，当寄存器内的值都准备妥当时，通过汇编指令int 0x80启动execve()函数。<br><img src="/study/code.png" alt="code"></p><div class="note warning flat"><h2 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h2></div><h4 id="开放商方法"><a href="#开放商方法" class="headerlink" title="开放商方法"></a>开放商方法</h4><p>使用安全的函数</p><h4 id="OS方法"><a href="#OS方法" class="headerlink" title="OS方法"></a>OS方法</h4><p>ASLR：地址随机化(每次启动程序时，栈和堆的地址不固定。可高度随机化，也可以几种情况轮换)。这时，ebp(定位return address)和malicious code的位置难以确定。<br>应对方法：重复运行攻击代码</p><h4 id="编译器方法"><a href="#编译器方法" class="headerlink" title="编译器方法"></a>编译器方法</h4><p>stack-Guard：编译器使用一些guard值插入栈的内部，自动检测栈数据有没有被溢出数据覆盖<br><img src="/study/stack.png" alt="guard"></p><h4 id="shell方法"><a href="#shell方法" class="headerlink" title="shell方法"></a>shell方法</h4><p>当检测到真实的id(用户id)跳入到有效id时，自动降回更低的id<br>应对方法：运行攻击部分之前，将自己的real id设置为0</p><h4 id="硬件方法"><a href="#硬件方法" class="headerlink" title="硬件方法"></a>硬件方法</h4><p>Non-Executable Stack：禁止在栈内运行代码<br>应对方法：return-to-libc攻击</p><div class="note primary flat"><h2 id="return-to-libc攻击-考试重点"><a href="#return-to-libc攻击-考试重点" class="headerlink" title="return-to-libc攻击 考试重点"></a>return-to-libc攻击 <strong>考试重点</strong></h2></div><p>原理：利用已有的系统函数(比如system)，结合缓冲区的溢出。</p><blockquote><p>-攻击步骤1：找到system()和exit()函数的位置。<br>-攻击步骤2：找到字符串“bin&#x2F;sh”的位置，作为参数(将“bin&#x2F;sh”设置为环境变量：这会导致“bin&#x2F;sh”被压入栈中)。<br>-攻击步骤3：为system()设置好栈结构(准备好参数，返回地址：这里返回地址写的是exit()函数的地址)。<br>详细见<a class="btn-beautify " href="https://blog.csdn.net/sinat_38816924/article/details/106222286"   title="return-to-libc攻击"><span>return-to-libc攻击</span></a>(压栈时，eip等也会压入)</p></blockquote><p>更优的方法：</p><div class="note primary flat"><h2 id="return-oriented-programing攻击"><a href="#return-oriented-programing攻击" class="headerlink" title="return-oriented programing攻击"></a>return-oriented programing攻击</h2></div><p>原理：将系统中的多个片段指令，以一定顺序组织在一起。<br>例子：<br>需执行r1-&gt;r2-&gt;r3三段代码，他们的地址分别为a1、a2、a3，则栈内从下到上为a1、a2、a3、正常返回地址，并且三个程序的最后一句为ret指令。</p><div class="note primary flat"><h2 id="jmp-oriented-programing攻击"><a href="#jmp-oriented-programing攻击" class="headerlink" title="jmp-oriented programing攻击"></a>jmp-oriented programing攻击</h2></div><p>例子：<br>以上个攻击为例，栈内从下到上为a1、a2、a3、正常返回地址，三个程序的最后一句为相对跳转(jmp [dx])指令跳到<strong>调度器</strong>。<br>JOP攻击需要结合调度器，来实现“dx&#x3D;dx+4；jmp[dx]”的控制。<br>如何初始化dx：设置好esp的位置后，执行pop dx</p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：门限秘密分享</title>
      <link href="/posts/a91656d0.html"/>
      <url>/posts/a91656d0.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note primary flat"><h2 id="t-n-门限方案"><a href="#t-n-门限方案" class="headerlink" title="(t-n)门限方案"></a>(t-n)门限方案</h2></div><p>n个人中的t个人能还原秘密。</p><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">用对称密钥实现</button><button type="button" class="tab " data-href="1-2">shamir方案实现</button><button type="button" class="tab " data-href="1-3">使用几何学实现</button><button type="button" class="tab " data-href="1-4">基于中国剩余定理</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>略</p></div><div class="tab-item-content" id="1-2"><p>用拉格朗日插值定理实现。<strong>考试重点</strong><br>t-1阶的多项式P(x)，P(0)&#x3D;s秘密。<br>所有运算都是模p的，且s，n＜p。<br>表达式：<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&#x3D;</mo><munderover><mo data-mjx-texclass="OP">∑</mo><mrow><mi>i</mi><mo>&#x3D;</mo><mn>0</mn></mrow><mrow><mi>n</mi></mrow></munderover><msub><mi>y</mi><mrow><mi>i</mi></mrow></msub><msub><mi>l</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>,</mo><mo>其中</mo><msub><mi>l</mi><mrow><mi>i</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&#x3D;</mo><munderover><mo data-mjx-texclass="OP">∏</mo><mrow><mi>j</mi><mo>&#x3D;</mo><mn>0</mn><mo>,</mo><mi>j</mi><mo>!</mo><mo>&#x3D;</mo><mi>i</mi></mrow><mrow><mi>n</mi></mrow></munderover><mfrac><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><msub><mi>x</mi><mrow><mi>j</mi></mrow></msub><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>i</mi></mrow></msub><mo>−</mo><msub><mi>x</mi><mrow><mi>j</mi></mrow></msub><mo stretchy="false">)</mo></mrow></mfrac></math><br>例子：<br>p&#x3D;7,f(1)&#x3D;2,f(2)&#x3D;1,f(4)&#x3D;5:<br>ff(1)&#x3D;2*(x-2)<em>(x-4)&#x2F;(1-2)(1-4)&#x3D;10</em>(x-2)<em>(x-4);<br>ff(2)&#x3D;1</em>(x-1)<em>(x-4)&#x2F;(2-1)(2-4)&#x3D;3</em>(x-1)<em>(x-4);<br>ff(3)&#x3D;5</em>(x-1)<em>(x-2)&#x2F;(4-1)(4-2)&#x3D;30</em>(x-1)*(x-2);<br>相加得：x²-4x+5(mod 7)</p></div><div class="tab-item-content" id="1-3"><p>略</p></div><div class="tab-item-content" id="1-4"><p>任选n个俩俩互质的数，任意k个数的乘积＞m，s＜m。<br>原理：少于k个时，得到的s‘比真正的s小，不能唯一地确认真正的s。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：安全策略</title>
      <link href="/posts/a5baeaeb.html"/>
      <url>/posts/a5baeaeb.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note warning flat"><h2 id="什么是安全策略"><a href="#什么是安全策略" class="headerlink" title="什么是安全策略"></a>什么是安全策略</h2></div><p>计算机安全的一般定义：你可以依赖计算机，且计算机如你预料的那样行动。<br>不同的计算机对安全有更精确的划分，描述这种安全的方式叫做安全策略。<br>安全机制：实现安全策略的机制。<br>攻击破坏安全机制，使计算机在预料之外行动。</p><div class="note warning flat"><h2 id="计算机安全基本问题"><a href="#计算机安全基本问题" class="headerlink" title="计算机安全基本问题"></a>计算机安全基本问题</h2></div><p>在什么条件下，一个计算机算法可判定一个计算机系统是否安全？<br>结论：安全模型表达能力越强，验证安全性越难。简单模型描述能力有限，但存在有效验证安全性的方法。</p><div class="note primary flat"><h2 id="访问控制模型"><a href="#访问控制模型" class="headerlink" title="访问控制模型"></a>访问控制模型</h2></div><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">访问控制矩阵ACM</button><button type="button" class="tab " data-href="1-2">Haarrion-Ruzzo-Ullman模型</button><button type="button" class="tab " data-href="1-3">Take-Grant模型</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>保护状态：涉及安全保护的状态<br>ACM是描述当前保护状态的最精确的模型，主体与主体之间也存在不同权限。</p><table><thead><tr><th></th><th>文件f</th><th>文件g</th><th>进程p</th><th>进程q</th></tr></thead><tbody><tr><td>进程p</td><td>读写</td><td>读写</td><td>读写添加创建</td><td><strong>写</strong></td></tr><tr><td>进程q</td><td>读写</td><td>读写</td><td><strong>读</strong></td><td>读写添加创建</td></tr></tbody></table><p>ACM的行称为能力表，ACM的列称为访问控制列表(常用)。</p></div><div class="tab-item-content" id="1-2"><p>基本命令：创建主体客体、删除主客体、增加权限，删除权限。<br>单步命令：包含一条基本命令(基本命令不可直接调用)的命令。单步命令系统的可靠性问题可判定。</p><blockquote><p>证明：<br>1.delete操作可忽略：因为状态数固定<br>2.所有create合并成一个：最多增加一个主客体，因为只考虑r权限是否泄漏<br>3.故系统规模是有限的，命令总数k≤命令种类数*(主体+1)*(客体+1)，可用穷举方式判定</p></blockquote><p>条件命令：包含条件控制的命令，实现更合理的安全策略。多条件命令<strong>只能用AND</strong>连接条件。<br>可靠(安全)的：一个权限r不会被加入到原来不存在r的矩阵元素中。<br>在最普通、最抽象的情况下，计算机的安全是不可判定的。对于普通的HRU模型一系列操作，不存在算法判断权限是否泄漏。</p><blockquote><p>证明：<br>将图灵机停机问题归约为可靠性问题，而图灵机停机问题不可判定，故可靠性问题不可判定。</p><blockquote><p>证明：<br>设D(i,x)返回i号图灵机在输入为x时是否停机。构造图灵机y号如下:<br>if D(i,x)&#x3D;停 then 不停 else 停<br>则输入的编号为y时，产生悖论，故不存在这样的图灵机y，即判定图灵机是否停机问题的算法是无限的。</p></blockquote></blockquote><h4 id="图灵机停机问题"><a href="#图灵机停机问题" class="headerlink" title="图灵机停机问题"></a>图灵机停机问题</h4><p>图灵机：能模拟任何确定、可行、有限的算法。如果图灵机不能进入任何预设的接受拒绝状态，则图灵机不停机。<br>图灵机问题指的是，是否存在图灵机能回答,任意图灵机在任意输入下,是否停机的问题?</p><h4 id="用ACM矩阵表示图灵机"><a href="#用ACM矩阵表示图灵机" class="headerlink" title="用ACM矩阵表示图灵机"></a>用ACM矩阵表示图灵机</h4><p><img src="/study/acm.png" alt="ACM"><br>其中，纸袋的左移、右移、写，越过边界，可由一系列ACM命令模拟。<br>own确定了纸带单元的顺序。<br>k的存在保证同一时刻只有一条命令被触发。</p></div><div class="tab-item-content" id="1-3"><p>第一种可判定安全性的访问控制模型，时间是系统规模的线性函数。</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><blockquote><p>take：主体A可获取B的所有权限。<br>主体s若能获得y拥有的所有权限，则s可最终扩展为y。<br>grant：主体A可将自身拥有的任意权限赋给B。<br>主体s若能把其权限赋给r，则s可初始扩展为r。<br>create：主体创造对象。<br>remove：主体移除对象或权限。</p></blockquote><p>只有主体能主动执行一些动作，规则是修改ACM的权限。规则不是对系统的修改，而是对系统描述的修改。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>对称性<br><img src="/study/take.png" alt="对称性"></p><blockquote><p>即z对x有take权限，x也能通过一系列操作获得z的权限。<br>和x对z有take权限的区别：需要双方进行操作，而非一方进行操作。</p></blockquote><h4 id="保护状态图"><a href="#保护状态图" class="headerlink" title="保护状态图"></a>保护状态图</h4><p>岛：最大的，tg相连的，都是主体的子图。如果tg相连的都是主体，那么take和grant权限是对称的。<br>桥：连接众多主体、客体的路径(全是take权限；或take权限夹单个grand权限)，但桥的两端都是主体。(证明见回放)<br>谓词can·share(r,x,y,G)：返回节点x能否获得对y的r权限。</p><blockquote><p>如果x，y是一个岛上的主体，则返回真。</p></blockquote><blockquote><p>为真的充要条件1：如果x有一条边r连向y，则返回真。</p></blockquote><blockquote><p>为真的充要条件2：主体s有对y的r权限边，主体s和<strong>主体x</strong>在一些由桥连接的岛上。</p></blockquote><blockquote><p>为真的充要条件3：主体s有对y的r权限边，存在主体x‘&#x3D;x或x’初始扩展为x，存在主体s‘&#x3D;s或s’最终扩展为s，主体s‘和主体x’在一些由桥连接的岛上。</p></blockquote><p>任何两个点x，y的can·share(r,x,y,G)可用时间复杂度有限的算法判定。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="访问控制策略类型"><a href="#访问控制策略类型" class="headerlink" title="访问控制策略类型"></a>访问控制策略类型</h2></div><p>按照主体对ACM的权限进行的分类：</p><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">自主型访问控制DAC</button><button type="button" class="tab " data-href="2-2">强制访问控制MAC</button><button type="button" class="tab " data-href="2-3">创建者控制访问机制ORCON</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><p>基于身份的访问控制。<br>主体能自主地将访问权授予其他主体。<br>局限：主体不能控制信息的流动。<br>攻击：<br><img src="/study/muma.png" alt="木马"></p></div><div class="tab-item-content" id="2-2"><p>基于规则的访问控制。<br>系统机制控制对客体的访问，一般用户不能改变访问控制矩阵。<br>需要一个中心控制权威。</p></div><div class="tab-item-content" id="2-3"><p>DAC和MAC的结合。<br>没有创建者的许可，客体不会被泄露；<strong>客体的任何副本也遵循同样的限制</strong>。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="访问控制机制"><a href="#访问控制机制" class="headerlink" title="访问控制机制"></a>访问控制机制</h2></div><div class="tabs" id="3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="3-1">访问控制列表ACL</button><button type="button" class="tab " data-href="3-2">能力表</button><button type="button" class="tab " data-href="3-3">基于角色的访问控制RBAC</button><button type="button" class="tab " data-href="3-4">基于属性的访问控制ABAC</button></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><p>ACM的列，去除空表项，表和客体绑定。<br>应用：文件目录，网络防火墙。<br>易于集中管理，管理员可知道哪些主体拥有权限。</p></div><div class="tab-item-content" id="3-2"><p>ACM的行，去除空表项，表和主体绑定。<br>应用：分布式系统，微内核。<br>易于传递权限，无需管理员审批；不易于查找某一权限。<br>问题：<br>撤销权限时，要遍历所有主体。<span class="hide-inline"><button type="button" class="hide-button" style="">Click<br>  </button><span class="hide-content">构造一个全局客体表，主体引用全局客体表的表号代表客体(解决了撤销权限的问题，寻找权限的问题没解决)</span></span></p></div><div class="tab-item-content" id="3-3"><p>RBAC根据用户所拥有的角色进行访问控制和授权。<br>管理员角色管理权限的授予和撤销，用户的访问权限不可以主动转交。(非自主的访问控制)<br>应用：数据库、分布式系统。<br>一个用户可以发起几次会话，在不同会话中承担不同角色。<br>角色间的层次关系：角色A的权限包含角色B的所有权限。<br>约束：角色互斥、角色的实例限制等</p><blockquote><p>静态职责分离SSD：系统设计之初就定义好了的互斥角色<br>动态职责分离DSD：系统运行期间，动态地限制用户拥有的角色 </p></blockquote><p>优点：</p><blockquote><p>提高了管理员的管理能力(简化了授权模型，可方便实现权力分割、互斥)<br>模型与组织机构自然对应(使用起来很自然)</p></blockquote></div><div class="tab-item-content" id="3-4"><p>优点：<br>细粒度的访问控制；<br>灵活，适合动态访问控制；<br>减少用户和角色数量；<br>描述专业系统的防控策略。<br>属性分为主体属性，客体属性，环境属性。<br>ABAC在判断用户能否权限时，组合各类属性，代入规则以计算权限。<br>可实现DAC,RBAC,MAC等。</p><h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><p><img src="/study/abac.png" alt="策略"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="安全策略类型"><a href="#安全策略类型" class="headerlink" title="安全策略类型"></a>安全策略类型</h2></div><div class="tabs" id="3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="3-1">保密性策略</button><button type="button" class="tab " data-href="3-2">完整性策略</button><button type="button" class="tab " data-href="3-3">混合策略</button></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><p>用于军事安全策略。<br>基础：Bell-La Padula模型</p><h4 id="Bell-La-Padula模型"><a href="#Bell-La-Padula模型" class="headerlink" title="Bell-La Padula模型"></a>Bell-La Padula模型</h4><p>访问权限：执行、附加(追加写)、读、写。<br>Bell-La Padula模型约束信息的流动，信息不能由高安全级流向低安全级。<br>主体只能向下读(主体要有客体的DAC读权限)，向上附加(主体要有客体的DAC附加权限)，同级写(主体要有客体的DAC写权限)。<br>问题：有时候并不是所有的向下读等都是有必要的。<br>优化：给主体贴上“安全等级“的标签，安全等级由安全级别、类别构成。如{Too Secret，{Nuc，Eur，Asi}}</p><h4 id="关系优化"><a href="#关系优化" class="headerlink" title="关系优化"></a>关系优化</h4><p><img src="/study/zhipei.png" alt="支配"><br>支配关系dom，是部分序关系。基于需要知道原则，即便是同级的主体，也可能无法互相访问。<br>理解：{Too Secret，{Nuc，Eur，Asi}} dom {Too Secret，{Eur，Asi}}，意思为拥有前一个标签的主体，能访问拥有后一个标签的主体。</p><h4 id="对DAC木马问题的解决"><a href="#对DAC木马问题的解决" class="headerlink" title="对DAC木马问题的解决"></a>对DAC木马问题的解决</h4><p><img src="/study/mumaa.png" alt="木马"></p><h4 id="局限和结论"><a href="#局限和结论" class="headerlink" title="局限和结论"></a>局限和结论</h4><p>局限：没有涉及完整性，级别是静态的，包含隐形道(可能泄露高级对象的名字)。<br>重要结论：基本安全定理-状态迁移是安全的，初始状态是安全的，则其后的每一个状态都是安全的。</p></div><div class="tab-item-content" id="3-2"><p>用于商业安全策略。<br>著名模型：Biba完整性模型。</p><h4 id="Biba完整性模型"><a href="#Biba完整性模型" class="headerlink" title="Biba完整性模型"></a>Biba完整性模型</h4><p>完整性级别越高，数据越可信。<br>Biba完整性模型约束信息的改变，对信息的写会破坏完整性。<br><font color=red>Low-Water-Mark策略</font></p><blockquote><p>主体能向下写(主体的完整性等级高于客体的完整性等级)，向上读。<br>当一个主体读了一个低完整性客体，那么主体的完整性等级下降到该客体。<br>可以invoke(调用)低级别的客体。</p></blockquote><p><font color=red>环策略</font></p><blockquote><p>主体完整性等级都相同。<br>任意主体能read任意客体。<br>主体能向下写(主体的完整性等级高于客体的完整性等级)。<br>可以invoke(调用)低级别的客体。</p></blockquote><p>忽略了间接修改的问题，导致信息可以向上流。<br><font color=red>严格完整性策略</font></p><blockquote><p>主体能向下写(主体的完整性等级高于客体的完整性等级)，向上读。<br>可以invoke(调用)低级别的客体。</p></blockquote></div><div class="tab-item-content" id="3-3"><p>代表：中国墙模型，创建者控制访问机制ORCON，基于角色、属性的访问控制。</p><h4 id="中国墙模型"><a href="#中国墙模型" class="headerlink" title="中国墙模型"></a>中国墙模型</h4><p>解决商业中的利益冲突问题。<br>将信息对象分为“利益冲突”类。<br>CD：与一个公司有关的信息的集合。<br>COI：有利益冲突的公司的CD的集合，每个CD只属于一个COI。<br><img src="/study/coi.png" alt="COI"></p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p>s可以读o，当s读过o所属的CD的客体，或s没有读过其他冲突CD，或o是无毒客体。主体在一个COI中只能访问一个CD。<br>s可以写o，当s能够读的全部未消毒客体(即有毒个体，也即信息需要保密的个体。无毒：信息可以被任何主体读。)，与<strong>可读的</strong>o在一个CD中。</p><h4 id="联系和区别"><a href="#联系和区别" class="headerlink" title="联系和区别"></a>联系和区别</h4><p>与BLP本质区别：BLP用了安全标签，CW用了访问历史。<br>BLP能够模拟CW任意时刻的状态(不能跟踪变化)，而CW能模拟BLP整体。<br><img src="/study/youdu.png" alt="CW模拟"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>参考资料：<br>1.<a href="https://blog.csdn.net/sinat_41135487/article/details/105443141?fromshare=blogdetail&sharetype=blogdetail&sharerId=105443141&sharerefer=PC&sharesource=lemonsed&sharefrom=from_link" title="" target="">信息安全模型</a><br>2.<a href="https://blog.csdn.net/waqqy/article/details/127803086?fromshare=blogdetail&sharetype=blogdetail&sharerId=127803086&sharerefer=PC&sharesource=lemonsed&sharefrom=from_link" title="" target="">Bell-Lapudula模型</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：量子密钥协商</title>
      <link href="/posts/29d1b803.html"/>
      <url>/posts/29d1b803.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note info flat"><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2></div><p>在量子理论中，用向量表示0比特和1比特。<br>量子比特qubit的叠加可能性：a<em>0+b</em>1，其中a²+b²&#x3D;1。测量此比特，得到1比特的可能性。(a,b为几率幅，结果为0的可能性为a²，结果为1的可能性为b²。a，b是复数)<br>测量对qubit的影响：使叠加态<strong>不可逆地</strong>坍缩到测出的态。<br>不可克隆：不能精确复制量子态，但能移动。<br>光子通过光栅，是对光子的测量。光子通过光栅后，光子偏振方向与光栅方向相同。<br>如果偏振方向和光栅方向的角度为a，则该光子通过光栅的可能性为cos²a。<br><img src="/study/qiet.png" alt="窃听"></p><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">BB84协议实现密钥分配</button><button type="button" class="tab " data-href="1-2">B92协议(更优)</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p><img src="/study/guangzi.png" alt="BB84"><br>光子的编码方式：以一个方向代表1，与其<strong>垂直</strong>的方向代表0。BB84只采用两种：x或者＋。(垂直的或45°倾斜的)</p><blockquote><p>1.A选择一个比特b。</p></blockquote><blockquote><p>2.A选择一个发送方式：x或者＋。</p></blockquote><blockquote><p>3.B选择一个接收方式：x或者＋。</p></blockquote><blockquote><p>4.A公布发送方式，B公布接收方式。如果两个方式不同，则抛弃接收结果。</p></blockquote><p>重复以上过程4N次，最终，A有2N比特，B有2N比特，随机选择N比特作为秘密(如果两方的N比特完全一致，则大概率认为没有窃听者存在(如果窃听者选择了错误的接收方式，则会破坏信息，使接收方有一定的概率接收到错误结果))。</p></div><div class="tab-item-content" id="1-2"><p>使用非正交基，-表示0，&#x2F;表示1。</p><blockquote><p>1.A选择一个比特b。</p></blockquote><blockquote><p>2.编码后，发给B。</p></blockquote><blockquote><p>3.B随机地使用×或者+来测量b，如果用+测得|，则是1(用＋测量-时，测得0，用+测量&#x2F;时，测得0或者1。故出现|则说明是1)，如果用×测得\，则是0。其他情况即为不确定的测量结果。</p></blockquote><blockquote><p>4.B公布不确定的测量结果，用BB84方法检查窃听者。</p></blockquote><table><thead><tr><th></th><th>-</th><th>&#x2F;</th></tr></thead><tbody><tr><td>+</td><td>-</td><td>+</td></tr><tr><td>×</td><td>×</td><td>&#x2F;</td></tr></tbody></table></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：算法优化</title>
      <link href="/posts/5f4e56a6.html"/>
      <url>/posts/5f4e56a6.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note primary flat"><h2 id="公钥算法的优化"><a href="#公钥算法的优化" class="headerlink" title="公钥算法的优化"></a>公钥算法的优化</h2></div><p>加密算法的两个重要指标是加密强度和速度。在实现上，可以用各种技术来提高算法速度。<br>加密算法分为密钥生成和加解密，主要优化加解密部分。<br>Amdahl定律：优化一段代码的效果，取决于其执行时间占全部执行时间的比例。</p><h4 id="优化工作的方向"><a href="#优化工作的方向" class="headerlink" title="优化工作的方向"></a>优化工作的方向</h4><blockquote><p>充分利用CPU特性，如流水线和指令并行</p></blockquote><blockquote><p>针对加密算法本身做一些优化</p></blockquote><blockquote><p>编译器也会做一些优化：编译器的优化很保守(保证正确性)，且一些优化对于程序员来说简单，对编译器来说很难</p></blockquote><h4 id="软件优化一般方法"><a href="#软件优化一般方法" class="headerlink" title="软件优化一般方法"></a>软件优化一般方法</h4><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">代码移动</button><button type="button" class="tab " data-href="1-2">预计算</button><button type="button" class="tab " data-href="1-3">指令替换</button><button type="button" class="tab " data-href="1-4">共享子表达式</button><button type="button" class="tab " data-href="1-5">减少多余过程调用</button><button type="button" class="tab " data-href="1-6">限制变量</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>利用指令并行：调整代码顺序，使相近的两条指令的数据不相关<br>将条件分支指令按照概率和计算量排列次序</p></div><div class="tab-item-content" id="1-2"><p>如先计算一个定值，先计算一个字符串的长度</p></div><div class="tab-item-content" id="1-3"><p>避免使用耗时的指令：如左右移指令不能与任何其他指令配对形成流水，阻断了流水线<br>在循环中避免使用条件跳转指令：条件跳转指令会产生不可预见的指令流，容易分支预测失败</p></div><div class="tab-item-content" id="1-4"></div><div class="tab-item-content" id="1-5"><p>展开加密循环和函数：减少了条件指令和计算指令，将变量转化为常量，减少流水线的阻断和指令预取的作废</p></div><div class="tab-item-content" id="1-6"><p>限制变量的数量：寄存器有限<br>变量长度与CPU内部寄存器长度相同:否则，需要用别的指令来辅助存取，增加了指令周期数</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h4 id="优化举例"><a href="#优化举例" class="headerlink" title="优化举例"></a>优化举例</h4><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">IDEA算法优化</button><button type="button" class="tab " data-href="2-2">AES算法优化</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><p>问题<br>乘法时，若输入是0，该怎么办？ <span class="hide-inline"><button type="button" class="hide-button" style="">Click<br>  </button><span class="hide-content">乘法输入为0，则将其替换为2的16次方(<strong>17</strong>位数)，如果乘法输出是2的16次方，则将其替换为0。 正确性：0和2的16次方，在进行异或和加法时，结果一致；但是0没有乘法逆元，2的16次方为17位，故可以定义一个数，以2的16次方的性质(存在逆元)存在，但又能以16位的大小(数0)传递。</span></span><br>乘法的取模操作太耗时！<br>解决：高低算法：设p的高16是a，低16是b，则<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>p</mi><mo>&#x3D;</mo><mi>a</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">⟹</mo><mi>p</mi><mo>≡</mo><mi>b</mi><mo>−</mo><mi>a</mi><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>,</mo><mo>即计算</mo><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mo>&gt;&gt;</mo><mn>16</mn><mo stretchy="false">]</mo></math> </p><h4 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h4><p>查表法(指令周期大大减少)：预计算和存储一个生成元e的指数对数表，则a*b可表示为:<br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mi>e</mi></mrow></msub><mi>a</mi><mo>+</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mi>e</mi></mrow></msub><mi>b</mi><mo>&#x3D;</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mi>e</mi></mrow></msub><mi>a</mi><mi>b</mi><mo>,</mo><mo>查表得</mo><mi>a</mi><mi>b</mi></math></p></div><div class="tab-item-content" id="2-2"><p>提供128比特寄存器，直接操作128比特块</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="字节顺序控制"><a href="#字节顺序控制" class="headerlink" title="字节顺序控制"></a>字节顺序控制</h2></div><p>类型：大端寻址，小段寻址</p><h4 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h4><p>问题：不规定哪种顺序，会导致错误<br>解决：网络字节顺序按大端地址，主机字节顺序任意<br>问题：字节反转时，如果一个比特一个比特重排，则需n(n为比特数目)次操作<br>解决：利用指令并行来加速；或用特定快速比特算法。</p><p>注意：对于大端寻址而言，高位放在低地址，但单个字节内部的顺序不变</p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：安全协议</title>
      <link href="/posts/24329b97.html"/>
      <url>/posts/24329b97.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note primary flat"><h2 id="身份证明协议"><a href="#身份证明协议" class="headerlink" title="身份证明协议"></a>身份证明协议</h2></div><blockquote><p>两个参与者：证明者，验证者。</p></blockquote><blockquote><p>采用方式：挑战-响应协议-证明者向验证者通过展示与身份相关的秘密知识，证明自己的身份。</p></blockquote><blockquote><p>关键：不泄露秘密，且能够抵抗攻击。</p></blockquote><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">双向认证(基于共享密钥)</button><button type="button" class="tab " data-href="1-2">基于整数模p的阶为q的乘法循环群</button><button type="button" class="tab " data-href="1-3">基于公钥的认证</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><blockquote><p>挑战：一方传送给对方一个随机数</p></blockquote><blockquote><p>响应：对方对这个数进行特定处理再返回</p></blockquote><p><font color=red>双向认证协议(1)</font><br><img src="/study/xieyi0.png" alt="协议1"></p><blockquote><p>假设A也是可接受多个会话的通用计算机</p></blockquote><blockquote><p>考虑当攻击者伪装B的身份</p></blockquote><p>受到反射攻击：<br><img src="/study/gonji0.png" alt="反射攻击"></p><blockquote><p>关键：1.攻击者伪装B，建立一个同A的会话；2.攻击者拦截一个A向B的会话；3.攻击者利用A的自动加密，分别套出两个随机数的加密值。</p></blockquote><p><font color=red>双向认证协议(2)</font><br><img src="/study/xieyi1.png" alt="协议2"></p><p>受到反射攻击：<br><img src="/study/fanshe.png" alt="反射攻击"></p><blockquote><p>改进方式：在每个加密消息里加入发送者、接收者在协议中的角色(这样攻击者就无法利用消息2)。</p></blockquote><p><font color=red>双向认证协议(3)</font><br>基于HMAC，对HMAC的 攻击难于对<strong>对称密钥算法</strong>的攻击。<br><img src="/study/hmac.png" alt="协议3"></p><p><font color=red>双向认证协议(4)</font><br>Andrew安全RPC协议。<br><img src="/study/RPC.png" alt="协议4"></p><p>攻击：</p><blockquote><p>重放攻击：重放4给A；4中没有注明这个会话密钥和此次通信的关联。</p></blockquote><blockquote><p>类型缺陷攻击：攻击者在第四步重放2给A：虽然攻击者不一定知道RA+1，但猜测nonce比猜测密钥简单。</p></blockquote><p>解决类型缺陷攻击：</p><blockquote><p>Nonce只被要求每次不同即可，不包含随机性。</p></blockquote></div><div class="tab-item-content" id="1-2"><p><font color=red>Schnorr协议</font></p><blockquote><p>挑战：一方传送给对方一个随机数e</p></blockquote><blockquote><p>响应：对方对这个数进行特定处理再返回</p></blockquote><p>全局变量：p(大素数)、q(素数，p-1的因数)、g(生成元，0&lt;g&lt;p)、v(公钥，v&#x3D;g^(-a) mod p)<br>私钥：a(0&lt;a&lt;q)</p><p>过程：</p><blockquote><p>A 生成随机 r(0&lt;r&lt;q)，将 g^{r} mod p 发给B(防止暴露a)</p></blockquote><blockquote><p>B 向 A 发送随机数 e(防止A伪造a,e&lt;2^{t}&lt;q)[挑战]</p></blockquote><blockquote><p>A 计算 y &#x3D; r + ae mod <strong>q</strong>，将 y发给B，(B无法求离散对数得到r，进而得到e)(为什么mod q：q是阶)[响应]</p></blockquote><blockquote><p>B 计算 g^{y} (g^{-a})^{e} mod p 是否等于g^{r} mod p, 判定A的身份(如果A没有a，很难伪造私钥以通过验证)</p></blockquote><p>问题:<br>将Schnorr协议的过程1，2反序。协议是否安全？<span class="hide-inline"><button type="button" class="hide-button" style="">Click<br>  </button><span class="hide-content">不安全，A可第三步构造t，第一步发送g^{t}g^{-a}^e来欺骗B</span></span><br>若A使用相同的r进行两次验证，监听者能否获得a？ <span class="hide-inline"><button type="button" class="hide-button" style="">Click<br>  </button><span class="hide-content">能，B将e设为r，即可获得a</span></span></p></div><div class="tab-item-content" id="1-3"><p>对于公钥算法来说，身份认证非常简洁。</p><blockquote><p>基于加密的认证：用X的公钥加密消息M</p></blockquote><blockquote><p>基于签名的认证：用X的私钥加密消息M</p></blockquote><p>注意：不要将密钥用于多个目的，比如使用不同的密钥对进行签名和加密</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note warning flat"><h2 id="认证协议设计一般原则"><a href="#认证协议设计一般原则" class="headerlink" title="认证协议设计一般原则"></a>认证协议设计一般原则</h2></div><blockquote><p>安全协议设计是困难的,需要不断设计，分析，改进。</p></blockquote><blockquote><p>协议中报文不能被重复使用。</p></blockquote><blockquote><p>通信的发起者先提供自己的身份的证明，然后才是响应者。</p></blockquote><blockquote><p>发起者和响应者使用不同的共享密钥。</p></blockquote><blockquote><p>发起者和响应者的挑战数来源于不同的集合。如发起者用偶数，响应者用奇数。</p></blockquote><blockquote><p>并行会话无法被利用。</p></blockquote><div class="note primary flat"><h2 id="密钥建立协议"><a href="#密钥建立协议" class="headerlink" title="密钥建立协议"></a>密钥建立协议</h2></div><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">密钥传输</button><button type="button" class="tab " data-href="1-2">密钥协商</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>一方建立，安全地传给另一方。</p><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">无预先共享密钥的密钥传输</button><button type="button" class="tab " data-href="2-2">使用密钥分发中心的密钥传输</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><p>目的：密钥 K 保密地（但无身份验证）从 A 传输到 B。<br>系统参数: 素数 p；A和B分别选择秘密随机数 a、b(1 ≤ a、b ≤ p − 2),均与p − 1互素(保证a逆 mod p-1存在)。</p><p>过程：</p><blockquote><p>A → B ： K^{a} mod p</p></blockquote><blockquote><p>A ← B ： (K^{a})^{b} mod p</p></blockquote><blockquote><p>A → B ： (K^{ab})^{a^(-1)} mod p</p></blockquote></div><div class="tab-item-content" id="2-2"><p>每个用户与KDC共享一个秘密密钥，KDC存储并管理所有密钥。</p><div class="tabs" id="3"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="3-1">宽蛙嘴协议</button><button type="button" class="tab " data-href="3-2">简单票协议</button><button type="button" class="tab " data-href="3-3">Needham-Schroeder 协议</button><button type="button" class="tab " data-href="3-4">Kerberos协议</button></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><blockquote><p><img src="/study/kuanwa.png" alt="宽蛙嘴"></p></blockquote><p>攻击：</p><blockquote><p>重放2。</p></blockquote><p>解决：</p><blockquote><p>加入时间戳或nonce</p></blockquote></div><div class="tab-item-content" id="3-2"><blockquote><p><img src="/study/jiandan.png" alt="简单票"></p></blockquote><p>攻击：</p><blockquote><p>重放攻击：如果一个旧密钥 Ks及其KB(KS)泄露，则攻击者可假冒任何人的身份与Bob对话</p></blockquote><blockquote><p>中间人攻击1：Alice可在最后一步假冒任何人的身份与Bob对话</p></blockquote><blockquote><p>中间人攻击2：攻击方C申请和A、B对话，拿到KC(KS)，KA(KS),KC(KS‘),KB(KS’)，进而监听和篡改A、B之间的通信</p></blockquote><p>解决：<br>解决重放攻击：<br><img src="/study/chongf.png" alt="重放"></p><blockquote><p>Alice能保证得到的Ks是新鲜的</p></blockquote><p>解决中间人攻击：<br><img src="/study/jiejue.png" alt="简单票2"></p><blockquote><p>Alice无法假冒别的身份与Bob对话</p></blockquote><blockquote><p>Eva可以得到 KA(Ks，B)和 KB(Ks，A)， 但无法解密Ks，也无法伪造身份(因为身份信息受到KDC的加密)</p></blockquote></div><div class="tab-item-content" id="3-3"><p><img src="/study/Need.png" alt="协议"><br>4,5是B向A证明身份，确认收到密钥，同时确认A的身份。注意：消息2对KB(A,KS)的加密是没有必要的。</p><p>攻击：</p><blockquote><p>Trudy得到了一个旧的 ks，则可以重放消息3。而B必须记住所有旧ks才能抵抗这种攻击。</p></blockquote><p>解决：</p><blockquote><p>在2、3中加入时间戳，或者在3之前加入认证。</p></blockquote><p><font color=red>改进：Otway-Rees 协议</font><br><img src="/study/Ot.png" alt="协议"></p><blockquote><p>不需要复杂的同步机制</p></blockquote><blockquote><p>通信双方都与KDC进行了一次挑战-应答</p></blockquote><blockquote><p>RA加入到4，保证了KS的新鲜性</p></blockquote><blockquote><p>接收方B不在线时，不能使用</p></blockquote></div><div class="tab-item-content" id="3-4"><p>对Needham-Schroeder 协议的改进。</p><p><img src="/study/K5.png" alt="协议"></p><blockquote><p>TGS票重用，一次登录可访问多个服务</p></blockquote><blockquote><p>可视为两部分：第一部分，AS充当KDC，TGS充当另一用户；第二部分TGS充当KDC，Bob为另一用户</p></blockquote><p>过程：</p><blockquote><p>1.用户向AS提供用户名和密码，获取ticket(一个登录期间一次)</p></blockquote><blockquote><p>2.用户将此ticket发往TGS，获取另一个ticket(一种类型的服务一次)</p></blockquote><blockquote><p>3.用户将此ticket发往服务器，获取服务</p></blockquote><p>优点：</p><blockquote><p>身份验证只需一次，降低了风险</p></blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tab-item-content" id="1-2"><p>共同参与计算一个共享密钥，任何一方不能预先确定结果。</p><div class="tabs" id="4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="4-1">DH密钥协商</button><button type="button" class="tab " data-href="4-2">完美前向保密PFS</button></ul><div class="tab-contents"><div class="tab-item-content active" id="4-1"><blockquote><p>A 选择随机数 a，发送给B：g^{a} mod p</p></blockquote><blockquote><p>B 选择随机数  b，发送给A：g^{b} mod p</p></blockquote><blockquote><p>会话密钥 Ks &#x3D; g^{ab} mod p</p></blockquote></div><div class="tab-item-content" id="4-2"><blockquote><p>长期共享密钥K,当K被截获，不会造成Ks被破译:</p></blockquote><blockquote><p>A公开：EK(g^{a} mod p)</p></blockquote><blockquote><p>B公开：EK(g^{b} mod p)</p></blockquote><blockquote><p>会话密钥:Ks &#x3D; g^{ab} mod p</p></blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note warning flat"><h2 id="解决重放攻击的一般方式"><a href="#解决重放攻击的一般方式" class="headerlink" title="解决重放攻击的一般方式"></a>解决重放攻击的一般方式</h2></div><p>消息重放的实质是消息的新鲜性（Freshness）不能得到保证。</p><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">时间戳</button><button type="button" class="tab " data-href="1-2">挑战－应答机制</button><button type="button" class="tab " data-href="1-3">序列号</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>对消息盖上本地时戳，只有当消息上的时戳与当前本地时间的差值在意定范围之内，才接受该消息。<br>要求有一个全局同步时钟，但是如果双方时钟偏差过大或者允许的范围过大，则可以被攻击者利用。</p></div><div class="tab-item-content" id="1-2"><p>通过发送挑战值（Nonce）来确保消息的新鲜性。</p></div><div class="tab-item-content" id="1-3"><p>通信双方通过消息中的序列号来判断消息的新鲜性。要求通信双方必须事先协商一个初始序列号，并协商递增方法。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="传输层的安全协议SSL-TLS"><a href="#传输层的安全协议SSL-TLS" class="headerlink" title="传输层的安全协议SSL&#x2F;TLS"></a>传输层的安全协议SSL&#x2F;TLS</h2></div><p><img src="/study/woshou.png" alt="协议"><br>分为记录层(编码协议、报文顺序等)、握手层。</p><p>重要概念：</p><blockquote><p>会话：会话是指客户机和服务器之间的关联。一个会话包含多个连接。SSL 会话使用了公钥算法，开销大。</p></blockquote><blockquote><p>连接：连接是客户和服务器之间的逻辑链路，用于提供合适的传输服务和操作环境。SSL连接使用SSL会话生成的<strong>pre-master secret</strong>生成密钥，不再使用公钥算法。</p></blockquote><blockquote><p>SSL&#x2F;TLS握手协议负责协调客户机和服务器之间的<strong>会话</strong>的状态：当前操作状态和未决状态（在握手协议期间）。</p></blockquote><p>服务：</p><blockquote><p>身份认证。认证用户和服务器，确保数据发送到正确的客户机和服务器；</p></blockquote><blockquote><p>保密性。加密数据以防止数据中途被窃取；</p></blockquote><blockquote><p>完整性。维护数据的完整性，确保数据在传输过程中不被改变。</p></blockquote><div class="tabs" id="6"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="6-1">简化的SSL会话建立</button><button type="button" class="tab " data-href="6-2">有共享秘密pre-master secret后的SSL连接建立</button></ul><div class="tab-contents"><div class="tab-item-content active" id="6-1"><p><img src="/study/ssl.png" alt="协议"><br>使用了<strong>公钥算法</strong>，大大降低了效率。</p><blockquote><p>S ：<strong>pre-master secret</strong>，A生成的随机值。</p></blockquote><blockquote><p>K &#x3D; h(S||RA||RB)</p></blockquote><blockquote><p>“msgs”是前边全部消息，用来证明前边消息已经正确接收。</p></blockquote><blockquote><p>CLNT，SRVR 是固定字符串。</p></blockquote><blockquote><p>Ek(h(msgs||CLNT||K))用于向Bob证明Alice的身份，可以不需要。</p></blockquote><blockquote><p>第四步，Bob向Alice证明自己的身份。</p></blockquote><p>问题<br>并没有认证A的身份。<span class="hide-inline"><button type="button" class="hide-button" style="">Click<br>  </button><span class="hide-content">服务员在此后用其他手段认证A的身份。</span></span></p></div><div class="tab-item-content" id="6-2"><p>不需要公钥算法。<br><img src="/study/lianjie.png" alt="协议"></p><blockquote><p>SSL会话已建立，用session-ID表示</p></blockquote><blockquote><p>K &#x3D; h(S||RA||RB)</p></blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>参考资料：<br>1.<a href="http://t.csdnimg.cn/QDNGJ" title="" target="">Schnorr身份识别方案</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：快速比特操纵算法</title>
      <link href="/posts/7511bdb5.html"/>
      <url>/posts/7511bdb5.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note info flat"><h2 id="快速比特操纵算法含义"><a href="#快速比特操纵算法含义" class="headerlink" title="快速比特操纵算法含义"></a>快速比特操纵算法含义</h2></div><p>使用机器字操作(算术、逻辑运算)实现机器字中的比特的计算和变换，是一种时间复杂度与机器字长无关的算法。</p><div class="note primary flat"><h2 id="计算1的个数"><a href="#计算1的个数" class="headerlink" title="计算1的个数"></a>计算1的个数</h2></div><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">朴素方法</button><button type="button" class="tab " data-href="1-2">移位加法方法</button><button type="button" class="tab " data-href="1-3">乘法方法</button><button type="button" class="tab " data-href="1-4">乘法和加法的综合使用</button><button type="button" class="tab " data-href="1-5">更快的方法</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v; <span class="comment">//c的值即1的个数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> c; </span><br><span class="line"><span class="keyword">for</span> (c = <span class="number">0</span>; v; c++)</span><br><span class="line">    v &amp;= v - <span class="number">1</span>; </span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="1-2"><h4 id="分块和"><a href="#分块和" class="headerlink" title="分块和"></a>分块和</h4><blockquote><p>对于一个二进制数x（总位数为w），将其划分为多段相同长度u的区间，将每个区间内的<strong>1的个数</strong>转化为二进制，首尾相接得到y：y称为x的u分块和。</p></blockquote><blockquote><p>例如：101010的1分块和是1,0,1,0,1,0,101010的2分块和是01,01,01，101010的6分块和是000011。</p></blockquote><blockquote><p>因为u位能表示的最大个数，大于等于u的长度，故该方式能正确表达出分块和而不发生溢出。</p></blockquote><h4 id="递推表达式"><a href="#递推表达式" class="headerlink" title="递推表达式"></a>递推表达式</h4><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>x</mi><mrow><mo stretchy="false">[</mo><mn>2</mn><mi>u</mi><mo stretchy="false">]</mo></mrow></msup><mo>&#x3D;</mo><mi>y</mi><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi></mrow></msup><msup><mn>1</mn><mrow><mi>u</mi></mrow></msup><msup><mo stretchy="false">)</mo><mrow><mi>w</mi><mrow><mo>&#x2F;</mo></mrow><mn>2</mn><mi>u</mi></mrow></msup><mo>+</mo><mo stretchy="false">(</mo><msup><mi>x</mi><mrow><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo></mrow></msup><mo>&gt;&gt;</mo><mi>u</mi><mo stretchy="false">)</mo><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi></mrow></msup><msup><mn>1</mn><mrow><mi>u</mi></mrow></msup><msup><mo stretchy="false">)</mo><mrow><mi>w</mi><mrow><mo>&#x2F;</mo></mrow><mn>2</mn><mi>u</mi></mrow></msup></math><br>说明</p><blockquote><p>简单来说，便是将奇数个u区间和偶数个u区间相加。</p></blockquote><blockquote><p>例如上面01010101的例子：<br>先将01010101和00110011按位与，只保留奇数位u区间得到00010001；<br>再将01010101右移u位，得到00010101，与00110011按位与，只保留偶数个u区间得到00010001。</p></blockquote><blockquote><p>再将两数相加，完成合并。</p></blockquote><p>这种方法参照了递归方式，计算1的个数的时间复杂度是O(log w)，小于上一方法的O(w)。</p></div><div class="tab-item-content" id="1-3"><h4 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h4><blockquote><p>若一个数，每个区间除了最后一位为0&#x2F;1，其他位都为0：换而言之，最低位的数表示这个u区间有多少个1：</p></blockquote><blockquote><p>形如001001001001、000000001001，将其与001001001001相乘，结果的从右往左数的第m-1&#x3D;w&#x2F;u-1（从0开始计数）个u区间的值为此二进制数的1的个数。</p></blockquote><blockquote><p>对于这个例子，001001001001与001001001001相乘，结果为1010011<strong>100</strong>011010001，得到001001001001中1的个数是4。</p></blockquote><h4 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h4><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>所有</mo><mi>u</mi><mo>区间的第</mo><mi>i</mi><mo>个比特中</mo><mn>1</mn><mo>的数量</mo><msub><mi>C</mi><mrow><mi>i</mi></mrow></msub><mo>&#x3D;</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&gt;&gt;</mo><mi>i</mi><mo stretchy="false">)</mo><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>m</mi></mrow></msup><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>m</mi></mrow></msup></math><br>即：通过移位和按位与，强制将每一部分的数变成“每个区间除了最后一位为0&#x2F;1，其他位都为0”的形式。</p><blockquote><p>如110110，分块为110，110，求第0,1,2位的1的个数的操作分别为000000*001001，001001*001001，001001*001001。</p></blockquote><blockquote><p>将上面的结果相加，取从右往左数的第w&#x2F;u-1（从0开始计数）个u区间的值，便是110110中1的个数，得到4。注意：分块长度至少为<strong>lgw</strong>，否则相加时会产生进位(即需满足w&lt;2^{u})。</p></blockquote><p>总结：如果设区间长度为lgw，则需要做[0,lgw）次乘法，并将乘法得到的结果<strong>相加</strong>，最后取第m-1(从0开始计数)个u区间的值。</p></div><div class="tab-item-content" id="1-4"><blockquote><p>加法方法进行到区间长度 u &#x3D; lgw 时；</p></blockquote><blockquote><p>用一次乘法，<strong>结果的第 m - 1 个 u 区间的值等于 x 中 1 的个数</strong>。</p></blockquote><blockquote><p>时间复杂 O(loglog w)</p></blockquote><p>此时虽然<strong>y</strong>的每个分块不满足“每个区间除了最后一位为0&#x2F;1，其他位都为0”,但满足“表示的数的大小为x的对应分块的1的个数”。即结果的第 m - 1 个 u 区间的值并非为y中1的个数，<strong>而是x的1的个数</strong>。</p><p>额外的：</p><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>x</mi><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>g</mi><mi>w</mi><mo stretchy="false">]</mo></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mrow><mi>l</mi><mi>g</mi><mi>w</mi></mrow></msup><mo>–</mo><mn>1</mn><mo stretchy="false">)</mo><mo>等于所有</mo><mi>u</mi><mo>区间的和</mo></math></p></blockquote><p>例子：</p><blockquote><p>0001001010001111，分块为4，则x[lgw]为0001,0001,0001,0100(十进制为4372)。</p></blockquote><blockquote><p>其乘以0001000100010001的结果的第3个数为0111，值为7。同时，4372模15的值也为7。</p></blockquote></div><div class="tab-item-content" id="1-5"><h4 id="前导知识"><a href="#前导知识" class="headerlink" title="前导知识"></a>前导知识</h4><blockquote><p>log*(n)的定义：满足log( log( ··· log(n) ··· ) ) ＜1 的最小log个数。</p></blockquote><blockquote><p>lg*(32) &#x3D; lg*(64) &#x3D; lg*(128) &#x3D; ··· &#x3D; lg*(2^16) &#x3D; 4</p></blockquote><blockquote><p>u个比特能表示2的u次方-1大小，也即(2的u次方-1)&#x2F;u个u区间的1的个数之和。</p></blockquote><blockquote><p>思想：让每次乘法尽最大可能扩张区间长度。</p></blockquote><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>设</mo><msup><mi>u</mi><mo>′</mo></msup><mo>是用一次乘法能得到的最大区间长度，则</mo><msup><mi>u</mi><mrow><mo>′</mo></mrow></msup><mo>&#x3D;</mo><mi>u</mi><mo stretchy="false">⌊</mo><mfrac><mrow><msup><mn>2</mn><mi>u</mi></msup><mo>−</mo><mn>1</mn></mrow><mi>u</mi></mfrac><mo stretchy="false">⌋</mo></math></p></blockquote><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>定义</mo><mi>L</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&#x3D;</mo><mi>l</mi><mi>g</mi><mi>w</mi><mo>,</mo><mi>L</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>&#x3D;</mo><mi>l</mi><mi>g</mi><mi>l</mi><mi>g</mi><mi>w</mi><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>&#x3D;</mo><mi>l</mi><mi>g</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mi>w</mi><mo>.</mo><mo>则:</mo><msup><mi>x</mi><mrow><mo stretchy="false">[</mo><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow></msup><mo>&#x3D;</mo><mo stretchy="false">(</mo><msup><mi>x</mi><mrow><mo stretchy="false">[</mo><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow></msup><mo>∗</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mfrac><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow></msup><mo stretchy="false">)</mo><mo>&gt;&gt;</mo><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mi>L</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></math></p></blockquote><blockquote><p>说明：从L(i)区间开始，每次将区间放大为原来的2次幂倍，直到区间长度为lgw。此时运用一次分块乘法，便能得到结果。</p></blockquote><blockquote><p>原理：存在y，x[u] * y &#x3D; z，对于 z 的每个u’区间，其最高 u 比特的值是x[ u’]对应区间的值。通过移位等处理，可得到x [u’]</p></blockquote><p><strong>具体公式课堂略过</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="LSB计算"><a href="#LSB计算" class="headerlink" title="LSB计算"></a>LSB计算</h2></div><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">Leiserson方法</button><button type="button" class="tab " data-href="2-2">Fich方法 O(1)</button><button type="button" class="tab " data-href="2-3">求最高位的置1比特（MSB）(O(1))</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><h4 id="前导知识"><a href="#前导知识" class="headerlink" title="前导知识"></a>前导知识</h4><blockquote><p>二元de Bruijn序列是一种特殊的周期为2的n次方的序列，满足任意一个二元n长向量都在de Brujn序列的一个周期中恰出现一次。</p></blockquote><blockquote><p>如n取3时，序列为00010111<strong>00</strong>，也即00010111的循环：其中000,001,010,011,100,101,110,111只出现了一次。</p></blockquote><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><blockquote><p>构造哈希函数h(x)：其中x是2的幂次方，最大值<strong>小于</strong>2的w次方，h(x)为0到w-1的任意一个数。<br>h(x) &#x3D;B * x &gt;&gt; (w – lg w)，lgw整除w(why?)。</p></blockquote><p>这个操作相当于对B进行移位后取高lgw(即上文中的n)位，因为B的特殊性，所以h(x)和x是一一对应的。</p><blockquote><p>构造表D：对于长度为lgw的数(或者说0&lt;&#x3D;x&lt;w)x，找到lgw维de Bruijn的第x位，取lgw个，得到的数记为y，D[y]&#x3D;x。(y互不相同；O(w)时间，O(wlgw)空间)</p></blockquote><p>这一步实际上就是由x确定h(x),<strong>不同的是，这里的x是LSB的值，而上文的的x是2的幂次方。h(x)的作用是，作为枢纽，连接这两个值</strong>。</p><blockquote><p>将word的除了最低置位bit之外的bit置 0(一个方式：(~word+1) AND word,~即按位取反)</p></blockquote><blockquote><p>结果与De Bruijn序列相乘，取乘积的前lgw bit得到数x’(这一步实际上就是进行h(x))</p></blockquote><blockquote><p>用结果查表D，得到D[x’]，即为LSB的位置</p></blockquote><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><blockquote><p>LSB的值根据de Bruijn序列，映射成了唯一的长度为lgw的值，而这长度为lgw的值又通过de Bruijn序列映射成了唯一的2的幂次方。当de Bruijn序列确定时，这两个映射关系是唯一确定的。</p></blockquote></div><div class="tab-item-content" id="2-2"><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><blockquote><p>将 x分为 u bit区间。</p></blockquote><blockquote><p>将LSB隔离出来，其他bit都是0。(一个方式：(~word+1) AND word,~即按位取反)</p></blockquote><p>注意：其中 u 应该大于根号w,否则做乘法时，00..1串无法覆盖所有的u区间。<br>计算LSB所在的区间号i</p><blockquote><p>生成一个机器字<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>F</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>将第</mo><mi>i</mi><mo>位之后的</mo><mi>u</mi><mo>区间的最低位比特置</mo><mn>1</mn><mo>：</mo><mi>y</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&lt;&lt;</mo><mn>1</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>A</mi><mi>N</mi><mi>D</mi><mi>F</mi></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>通过如下操作将所有</mo><mi>i</mi><mo>之后</mo><mi>u</mi><mo>区间的最后的比特相加到一个区间里:</mo><mi>y</mi><mo>&#x3D;</mo><mi>y</mi><mo>∗</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>在机器字</mo><mi>Y</mi><mo>的最高</mo><mi>u</mi><mo>比特中存放的数值就是</mo><mi>L</mi><mi>S</mi><mi>B</mi><mo>所在的</mo><mi>u</mi><mo>区间的编号:(截断为w位)</mo><mi>i</mi><mo>&#x3D;</mo><mi>y</mi><mo>&gt;&gt;</mo><mo stretchy="false">(</mo><mi>w</mi><mo>−</mo><mi>u</mi><mo stretchy="false">)</mo></math></p></blockquote><p>原理</p><blockquote><p>LSB后面的所有u区间的最低位为1，故在LSB及其后面有多少个u区间，便有多少个1被加。<strong>注意：这里的01串的重复次数是u，而非w&#x2F;u</strong></p></blockquote><p>计算LSB在区间中的位置j</p><blockquote><p>将x的i区间复制成u份：<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>y</mi><mo>&#x3D;</mo><mi>x</mi><mo>&gt;&gt;</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>i</mi><mo>–</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>u</mi><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup></math><br>只将第j个u区间保留下来：<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>y</mi><mo>&#x3D;</mo><mi>y</mi><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup></math><br>采用计算区间号i的方法，得到j</p></blockquote><p>则y &#x3D; u*(i-1)+j。</p><p>例子：</p><blockquote><p>100(u为3):</p></blockquote><blockquote><p>计算i：(0111&amp;(001001001))*(001001001)&#x3D;001001001,取高u位，即i&#x3D;1。</p></blockquote><blockquote><p>计算j：100复制三次：100100100，再与上000100010001得100000000,利用计算i的方法，得到j&#x3D;3。</p></blockquote><blockquote><p>最终：(1-1)*3+3&#x3D;3。</p></blockquote><p>反例：</p><blockquote><p>100 000 000 000…(u为3)：</p></blockquote><blockquote><p>此时不管后面有多少个000，最后都会得到LSB在第三个区间，而这是错误的。那为什么不动态改变机器字F来使得其正确:耗时。</p></blockquote></div><div class="tab-item-content" id="2-3"><h4 id="前导知识"><a href="#前导知识" class="headerlink" title="前导知识"></a>前导知识</h4><p>SetR(x,u)</p><blockquote><p>此操作根据机器字x中u区间是否为0对u区间进行设置，如果为0，则u区间不变，否则最低位置为1。</p></blockquote><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>1</mn><mo>）将每个</mo><mi>u</mi><mo>区间最高位置为</mo><mn>1</mn><mo>。</mo><mi>x</mi><mo>&#x3D;</mo><mi>x</mi><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>10</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup><mo>。</mo></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>2</mn><mo>）</mo><mi>y</mi><mo>&#x3D;</mo><mi>x</mi><mo>−</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>3</mn><mo>）将等于</mo><msup><mn>10</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>的</mo><mi>u</mi><mo>区间的最高为置为</mo><mn>1</mn><mo>。</mo><mi>x</mi><mo>&#x3D;</mo><mi>y</mi><mrow><mo stretchy="false">|</mo></mrow><mo stretchy="false">(</mo><mi>x</mi><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>10</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup><mo stretchy="false">)</mo><mo>.</mo></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>4</mn><mo>）</mo><mi>x</mi><mo>&#x3D;</mo><mi>x</mi><mo>&gt;&gt;</mo><mi>u</mi></math></p></blockquote><p>反向聚合操作compr(x,u)</p><blockquote><p>此操作将每个区间的最后一个比特聚合在一个u区间中，但顺序相反。</p></blockquote><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>1</mn><mo>）</mo><mi>y</mi><mo>&#x3D;</mo><mi>S</mi><mi>e</mi><mi>t</mi><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>u</mi><mo stretchy="false">)</mo></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>2</mn><mo>）将每个</mo><mi>u</mi><mo>区间的最低位比特反向聚集在</mo><mi>y</mi><mo>的最高</mo><mi>u</mi><mo>区间。</mo><mi>y</mi><mo>&#x3D;</mo><mi>y</mi><mo>∗</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi></mrow></msup><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>u</mi></mrow></msup></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>3</mn><mo>）</mo><mi>x</mi><mo>&#x3D;</mo><mi>y</mi><mo>&gt;&gt;</mo><mo stretchy="false">(</mo><mi>w</mi><mo>−</mo><mi>u</mi><mo stretchy="false">)</mo></math></p></blockquote><p>扩散操作diffu(x,u)</p><blockquote><p>此操作将一个u区间的每个比特放置到每个u区间的最低比特上，顺序不变。</p></blockquote><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>1</mn><mo>）将</mo><mn>0</mn><mo>区间复制</mo><mi>u</mi><mo>份</mo><mi>y</mi><mo>&#x3D;</mo><mi>x</mi><mo>∗</mo><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi><mo>−</mo><mn>1</mn></mrow></msup><mn>1</mn><mo stretchy="false">)</mo><mi>u</mi></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>2</mn><mo>）保留第</mo><mi>i</mi><mo>区间的第</mo><mi>i</mi><mo>个比特</mo><mi>y</mi><mo>&#x3D;</mo><mi>y</mi><mi>A</mi><mi>N</mi><mi>D</mi><mo stretchy="false">(</mo><msup><mn>0</mn><mrow><mi>u</mi></mrow></msup><mn>1</mn><mo stretchy="false">)</mo><mi>u</mi></math><br><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>（</mo><mn>3</mn><mo>）</mo><mi>S</mi><mi>e</mi><mi>t</mi><mi>R</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mi>u</mi><mo stretchy="false">)</mo></math></p></blockquote><h4 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h4><p>首先计算MSB所在的u区间的号</p><blockquote><p>（1）y &#x3D; SetR(x)</p></blockquote><blockquote><p>（2）y &#x3D; Compr(y,u)</p></blockquote><blockquote><p>（3）y &#x3D; diffu(y,u)</p></blockquote><blockquote><p>（4）计算y中的MSB的位置 i，因此MSB在x中所在区间为 i’&#x3D; u-i</p></blockquote><p>计算i’区间中MSB位置</p><blockquote><p>（5）y &#x3D; x&gt;&gt;(i’u)</p></blockquote><blockquote><p>（6）y &#x3D; diffu(y,u)</p></blockquote><blockquote><p>（7）计算y中的MSB的位置 j，因此MSB所在区间为 j’&#x3D; u-j</p></blockquote><p>最终可得到MSB的位置为 i’u+j’<br><strong>此部分在课堂略过</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="比特置换"><a href="#比特置换" class="headerlink" title="比特置换"></a>比特置换</h2></div><h4 id="递归方法实现完全比特反转O-lgw"><a href="#递归方法实现完全比特反转O-lgw" class="headerlink" title="递归方法实现完全比特反转O(lgw)"></a>递归方法实现完全比特反转O(lgw)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = (((x &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((x &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    x = (((x &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((x &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>));</span><br><span class="line">    x = (((x &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((x &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>));</span><br><span class="line">    x = (((x &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((x &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>((x &gt;&gt; <span class="number">16</span>) | (x &lt;&lt; <span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Benes置换网络"><a href="#Benes置换网络" class="headerlink" title="Benes置换网络"></a>Benes置换网络</h4><blockquote><p>可实现任意置换，只需在方块中填写交叉或直连(X或&#x3D;)。</p></blockquote><p> <img src="/study/zhihuan.png" alt="置换网络"></p><blockquote><p>输入个数是2的幂次方，该置换网络使用多个 2*2 <strong>基本交换单元</strong>实现置换，输出也为2的幂次方个元素的序列。</p></blockquote><blockquote><p>BN网络运用了<strong>递归</strong>的思想，即相邻(奇偶性不同)的输入，分别前往两组，而在某一组中，又再进行分组；而在输出时，每两个输出合并到一个输出，直到两个输出合并成最终输出，完成置换过程。</p></blockquote><blockquote><p>所需层数：2lgw-1。时间复杂度：O(lgw)，空间复杂度：O(lgw)(记录直连还是交换)</p></blockquote><h4 id="断点图"><a href="#断点图" class="headerlink" title="断点图"></a>断点图</h4><blockquote><p>输入中的相邻用实线连接，输出中的相邻用虚线连接。（作图为俩列）</p></blockquote><blockquote><p>调整断点图：交换相邻点的位置，使得虚线相连的两个数不在同一列。</p></blockquote><blockquote><p>获得输入符号：如果一组相邻点换序，则为“×”，否则为“&#x3D;”。</p></blockquote><blockquote><p>获得输出符号：在输出中如果一组相邻点为上下关系，在断点图中不为左右关系，则为“×”，否则为“&#x3D;”。</p></blockquote><blockquote><p>重复以上过程，直到所有空填上。</p></blockquote><p>例子：<br>输入从上到下是01234567，输出从上到下是64203571，(初始输入分组是01&#x2F;23&#x2F;45&#x2F;67，初始输出分组是64&#x2F;20&#x2F;35&#x2F;71。)则作图如下：<br><img src="/study/duandian.png" alt="断点"></p><blockquote><p>输入符号从上到下为“x&#x3D;x&#x3D;”，输出符号从上到下为“&#x3D;&#x3D;xx”。进一步地，获得新的分组。</p></blockquote><p>对输出符号的解释：64是一组且在输出分组中6在上4在下，在输入的调整后的断点图中6在左4在右，故不交换；71是一组且在输出分组中7在上1在下，在输入的调整后的断点图中7在右而1在左，故交换。</p><h4 id="断点图实例"><a href="#断点图实例" class="headerlink" title="断点图实例"></a>断点图实例</h4><blockquote><p><img src="/study/zhih.png" alt="置换网络"><br>注意：线条在方块“背面”经过，意为不进入这一置换单元。</p></blockquote><p>试着将以上例子对应的符号填入方块中。得到：</p><blockquote><p><img src="/study/zhih1.png" alt="断点"></p></blockquote><h4 id="一般情况m置换单元"><a href="#一般情况m置换单元" class="headerlink" title="一般情况m置换单元"></a>一般情况m置换单元</h4><blockquote><p>输入、输出按顺序分为m个块，每块k个元素。</p></blockquote><blockquote><p>将每块中的元素分到k个不同组中，使得每组中元素属于输入的不同块。</p></blockquote><blockquote><p>归结为K正规图着色问题。(why?)<br><strong>此部分课堂略过</strong></p></blockquote><p>参考资料：</p><a href="https://blog.csdn.net/u012028275/article/details/108895271?fromshare=blogdetail&sharetype=blogdetail&sharerId=108895271&sharerefer=PC&sharesource=lemonsed&sharefrom=from_link" title="" target="">【位操作笔记】详解一种高效位反转算法</a></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：安全计算</title>
      <link href="/posts/bc7c7b.html"/>
      <url>/posts/bc7c7b.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note warning flat"><h2 id="协议双方互不信任，都有可能欺骗"><a href="#协议双方互不信任，都有可能欺骗" class="headerlink" title="协议双方互不信任，都有可能欺骗"></a>协议双方互不信任，都有可能欺骗</h2></div><p>Semi-honest 半诚实，遵守协议流程，在过程中获得尽可能的信息</p><div class="note primary flat"><h2 id="承诺方案"><a href="#承诺方案" class="headerlink" title="承诺方案"></a>承诺方案</h2></div><p>即在一次信息交换中，A和B需要“同时”获得对方的一个信息。假设A先给出信息a，B后给出信息b。则B需要先给出b的证明c，A再给出信息a，B再给出信息b。这样，A能够核验信息证明c，来确保B没有在接收信息a后更改信息b【绑定】；同时，A也无法从信息证明c中获取b，来改变信息a【隐藏】。</p><h4 id="基于Hash函数的实现"><a href="#基于Hash函数的实现" class="headerlink" title="基于Hash函数的实现"></a>基于Hash函数的实现</h4><blockquote><p>A 计算承诺 c &#x3D; H (随机数,a)，将 c 发送给 B</p></blockquote><blockquote><p>隐藏性：存在 H ( R’, a’ ) &#x3D;  H ( R, a )，B找不到真实的R，a</p></blockquote><blockquote><p>绑定性： A 找不到 R’, a’，满足：H ( R’, a’ ) &#x3D; H ( R, a )</p></blockquote><p>不存在对有无限计算能力的敌手同时具有隐藏性和绑定性的承诺方案。</p><div class="note primary flat"><h2 id="百万富翁问题"><a href="#百万富翁问题" class="headerlink" title="百万富翁问题"></a>百万富翁问题</h2></div><p>A有一个0-9的数a，B有一个0-9的数b，A和B不想让对方知道自己的数字，但想知道a和b的大小。</p><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">基于DH实现</button><button type="button" class="tab " data-href="2-2">茫然传输方案</button><button type="button" class="tab " data-href="2-3">混淆电路方案</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><blockquote><p>A和B生成 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>α</mi><mo>,</mo><msup><mi>g</mi><mrow><mi>α</mi></mrow></msup><mo>,</mo><mi>β</mi><mo>,</mo><msup><mi>g</mi><mrow><mi>β</mi></mrow></msup></math></p></blockquote><blockquote><p>A进行操作后发给B：<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>若</mo><mi>α</mi><mo>&#x3D;</mo><mi>i</mi><mo>，则</mo><mi>H</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&#x3D;</mo><msup><mi>g</mi><mrow><mi>α</mi></mrow></msup><mo>∗</mo><mn>3.</mn><mo>.</mo><mo>.</mo><mo>,</mo><mo>若</mo><mi>α</mi><mo>&lt;</mo><mi>i</mi><mo>，则</mo><mi>H</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&#x3D;</mo><msup><mi>g</mi><mrow><mi>α</mi></mrow></msup><mo>∗</mo><mn>2.</mn><mo>.</mo><mo>.</mo><mo>,</mo><mo>若</mo><mi>α</mi><mo>&gt;</mo><mi>i</mi><mo>，则</mo><mi>H</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&#x3D;</mo><msup><mi>g</mi><mrow><mi>α</mi></mrow></msup><mo>∗</mo><mn>1.</mn><mo>.</mo><mo>.</mo><mo>,</mo><mo>,</mo><msup><mi>g</mi><mrow><mi>α</mi></mrow></msup><mo>.</mo></math>(“…”互不相同是为了防止B通过判断相同元素个数，50%概率猜出a)</p></blockquote><blockquote><p>B对H[b]进行加密，并抹除下标，将其发送给A。</p></blockquote><blockquote><p>A对H[?]进行解密，并将其发送给B。(防止A知道下标b，而猜出具体数字)</p></blockquote><blockquote><p>B解密，获得结果。</p></blockquote><blockquote><p>B发送密钥给A，A解密，获得结果。</p></blockquote></div><div class="tab-item-content" id="2-2"><blockquote><p>B 生成大数字 x，用 A 的公钥加密 x 得到 [x]A，将 [x]A – b 发送给A</p></blockquote><blockquote><p>A收到后：</p><blockquote><p>计算九个数字：[x]A – b + 1,  [x]A – b + 2 ,  …  ,  [x]A – b + 9.<br>并用自己的私有密钥解密这个些数字： { [x]A – b + 1 }A ,  { [x]A - b + 2 }A ,  …  ,  { [x]A - b + 9 }A<br>并将第 1 到第 a 结果 +1，其余不变</p></blockquote></blockquote><blockquote><p>A将 9 个结果按序发送给 Ｂ</p></blockquote><blockquote><p>Ｂ检测第 b 个数字，如果是 x，则 a &lt; b，否则 a &gt;&#x3D; b.(原理：若成功解密，说明第b项没有+1，即a＜b)</p></blockquote></div><div class="tab-item-content" id="2-3"><p>即将函数f(a,b)(比较a和b大小的函数)电路化，再对每个门电路进行加密。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="茫然传输协议"><a href="#茫然传输协议" class="headerlink" title="茫然传输协议"></a>茫然传输协议</h2></div><p>A 拥有 m1、m2，B需要知道指定的一个，而不知道另一个；A不知道B指定了哪个。</p><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">EGL协议</button><button type="button" class="tab " data-href="2-2">Naor-Pinkis协议</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><p>采用了姚期智解决百万富翁问题的方案。</p><blockquote><p>A，B 共享 y0，y1</p></blockquote><blockquote><p>B 选择 x，用 A 的公钥加密，得到 [x]A, 将 [x]A - yb 发送给 A</p></blockquote><blockquote><p>A计算 [x]A – yb + y0, [x]A – yb + y1，并用A的私钥解密这两个结果，得到 { [x]A – yb + y0 }A，{ [x]A – yb + y1 }A。因为b是确定的，故其中一个等于x，但A并不知道哪个是x。</p></blockquote><blockquote><p>A将 { [x]A - yb + y0 }A + m0，{ [x]A – yb + y1 }A + m1 发送给 B</p></blockquote><blockquote><p>B 计算 { [x]A - yb+ yb }A + mb - x 得到 mb。因为另一个数不等于x，B无从知道另一个m是什么，除非B知道A的私钥。</p></blockquote></div><div class="tab-item-content" id="2-2"><p>基于Elgamal加密算法实现。<br><img src="/study/mangran.png" alt="茫然传输"><br>若B知道C的离散对数，设其为t，则有<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo stretchy="false">(</mo><mi>C</mi><mrow><mo>&#x2F;</mo></mrow><msup><mi>g</mi><mrow><mrow><mo>β</mo></mrow></mrow></msup><msup><mo stretchy="false">)</mo><mrow><mi>a</mi></mrow></msup><mo>&#x3D;</mo><mfrac><msup><mi>g</mi><mrow><mi>a</mi><mi>t</mi></mrow></msup><msup><mi>g</mi><mrow><mi>a</mi><mrow><mo>β</mo></mrow></mrow></msup></mfrac><mo>&#x3D;</mo><mfrac><msup><mi>g</mi><mrow><mo stretchy="false">(</mo><mi>a</mi><mrow><mo>β</mo></mrow><msup><mo stretchy="false">)</mo><mrow><mfrac><mi>t</mi><mrow><mo>β</mo></mrow></mfrac></mrow></msup></mrow></msup><msup><mi>g</mi><mrow><mi>a</mi><mrow><mo>β</mo></mrow></mrow></msup></mfrac><mo>&#x3D;</mo><msubsup><mi>P</mi><mrow><mn>1</mn><mo>−</mo><mi>b</mi></mrow><mrow><mi>a</mi></mrow></msubsup><mo>。</mo></math></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="多方安全计算协议"><a href="#多方安全计算协议" class="headerlink" title="多方安全计算协议"></a>多方安全计算协议</h2></div><div class="tabs" id="2"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="2-1">两方安全计算</button><button type="button" class="tab " data-href="2-2">混淆电路</button></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><blockquote><p>问题：A，B各自拥有秘密 a，b。A，B 希望计算函数 f ( a, b )，同时不泄漏 a，b。值域定义域均为 [n]。</p></blockquote><blockquote><p>解决1：A 生成函数表 f ( a, * )，B 和 A 运行 1 &#x2F; n 茫然传输，B 输入 b(表在A方，B查询输入b时候的输出值，且不让A知道查询的值，得到f(a,b))，B 得到 f ( a, b )。</p></blockquote><blockquote><p>解决2：混淆电路，更便于实现多方安全计算，开销更小。</p></blockquote></div><div class="tab-item-content" id="2-2"><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>多个</strong>参与方提供输入，计算一个函数值，同时不泄露各自的输入。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><blockquote><p>设现有电路模块M，两个0&#x2F;1输入，一个0&#x2F;1输出。A将0&#x2F;1输入映射为B0，B1，将0&#x2F;1输出映射为T0，T1，并在对应的真值表中，用输入的映射值对输出的映射值进行加密。A选取a的映射值作为输入。</p></blockquote><blockquote><p>B选取一个输入b(0&#x2F;1),并通过<strong>茫然传输</strong>从A那里获得输入的映射值。</p></blockquote><blockquote><p>A将a的映射发给B，因为B<strong>不知道对应关系</strong>，故不知道A的输入原本是什么；B用两个映射值对四个被加密的输出值进行解密，得到正确的输出映射值。(解密函数 D 具有可分辨性质，即能通过解密结果判定解密是否正确。)因为A给B的四个盒子被<strong>混淆</strong>，故B不能通过顺序关系找到A的输入是0还是1。</p></blockquote><blockquote><p>B将输出的映射值发给A，A查表后得到输出的原本值，再发给B。</p></blockquote><blockquote><p>现有多个M，通过逻辑线路相连（但B不应该知道是与门还是或门)，B应当通过对多个M的解密获得多个输出，再把这些输出当做其他M的输入，进而得到最终输出。(最终输出无需加密和映射)</p></blockquote><p>一个电路的所有门的混淆表集合称为电路的混淆电路。<br>混淆电路实现了安全计算的目标。<br><strong>这部分运用比理论简单，建议看回放</strong></p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><blockquote><p>A 拥有AES密钥 k</p></blockquote><blockquote><p>B 希望得到用 k 加密的 m, 即 AES ( k, m )</p></blockquote><blockquote><p>此过程结束后 B 得到 AES ( k, m )，但不知道 k。A 不知道 m。(实现方式：将AES加密逻辑转化为电路，并将输入值转换为0&#x2F;1比特)</p></blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note warning flat"><h2 id="安全计算目标"><a href="#安全计算目标" class="headerlink" title="安全计算目标"></a>安全计算目标</h2></div><h4 id="隐私保护"><a href="#隐私保护" class="headerlink" title="隐私保护"></a>隐私保护</h4><blockquote><p>计算无法通过协议得知对方的参数</p></blockquote><h4 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h4><blockquote><p>能正确地传递信息</p></blockquote><h4 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h4><blockquote><p>双方都可以得到结果</p></blockquote><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><blockquote><p>混淆电路协议对诚实但好奇(观察分析)的攻击者是安全的</p></blockquote><p>参考：<br>1.<a href="http://t.csdnimg.cn/mfXre" title="" target="">CSDN：【隐私计算篇】混淆电路深入浅出</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：俄国农民指数算法</title>
      <link href="/posts/db01f830.html"/>
      <url>/posts/db01f830.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note primary flat"><h2 id="俄国农民指数算法"><a href="#俄国农民指数算法" class="headerlink" title="俄国农民指数算法"></a>俄国农民指数算法</h2></div><div class="tabs" id="1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="1-1">正向快速幂(R-L算法)</button><button type="button" class="tab " data-href="1-2">逆向快速幂(L-R算法)</button><button type="button" class="tab " data-href="1-3">比较</button></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">FastPow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> g,<span class="type">long</span> <span class="type">long</span> e,<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> m)</span> <span class="comment">//求g的e次方模m的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(e)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span>(e&amp;<span class="number">1</span>)</span><br><span class="line">        ans=(ans*g)%m;</span><br><span class="line">        g=(g*g)%m;</span><br><span class="line">        e&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="1-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">FastPow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> g,<span class="type">long</span> <span class="type">long</span> e,<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> m)</span> <span class="comment">//求g的e次方模m的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(e)  <span class="comment">//e采用反向存储</span></span><br><span class="line">        &#123;</span><br><span class="line">        ans=(ans*ans)%m;</span><br><span class="line">        <span class="keyword">if</span>(e&amp;<span class="number">1</span>)</span><br><span class="line">        ans=(ans*g)%m;</span><br><span class="line">        e&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>a</mi><mi>n</mi><mi>s</mi><mo>∗</mo><mi>a</mi><mi>n</mi><mi>s</mi><mo>&#x3D;</mo><msup><mi>g</mi><mrow><msub><mi>e</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>e</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><msub><mi>e</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>e</mi><mrow><mn>2</mn></mrow></msub><msub><mi>e</mi><mrow><mn>1</mn></mrow></msub><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mn>0</mn><mo data-mjx-texclass="CLOSE">]</mo></mrow></mrow></msup><mo>,</mo><mo>如果</mo><msub><mi>e</mi><mrow><mn>0</mn></mrow></msub><mo>&#x3D;</mo><mn>1</mn><mo>,</mo><mo>则再乘以</mo><mi>g</mi><mo>，否则不变。</mo></math></p></div><div class="tab-item-content" id="1-3"><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><blockquote><p>两种算法都需要平均1.5∗(n −1) 次乘法。</p></blockquote><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><blockquote><p>第二种是用固定的g值作乘法，第一种的g值是变化的，因此在硬件实现时，需要增加一个寄存器。</p></blockquote><blockquote><p>第一种算法中，平方和模乘是独立的，可以并行运算。但在第二种算法中不能。</p></blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note primary flat"><h2 id="俄国农民乘法算法"><a href="#俄国农民乘法算法" class="headerlink" title="俄国农民乘法算法"></a>俄国农民乘法算法</h2><p>图片见下：<br><img src="/study/nongm.png" alt="俄国农民"></p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;  <span class="comment">//当a是2的倍数时，加上b的2次幂；否则不加</span></span><br><span class="line">    <span class="type">int</span> ans=b&amp;(a%<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span>(a!=<span class="number">0</span>)&#123;</span><br><span class="line">        b=b*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        ans+=b;</span><br><span class="line">    &#125;</span><br><span class="line">    a=a/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><h2 id="笔纸算法"><a href="#笔纸算法" class="headerlink" title="笔纸算法"></a>笔纸算法</h2></div><p>简单来说，就是用程序模拟手算乘法时的<strong>竖式</strong>计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[], <span class="type">int</span> c[])</span> </span>&#123; <span class="comment">//OI WIKI</span></span><br><span class="line">  <span class="built_in">clear</span>(c);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 这里直接计算结果中的从低到高第 i 位，且一并处理了进位</span></span><br><span class="line">    <span class="comment">// 第 i 次循环为 c[i] 加上了所有满足 p + q = i 的 a[p] 与 b[q] 的乘积之和</span></span><br><span class="line">    <span class="comment">// 这样做的效果和直接进行上图的运算最后求和是一样的，只是更加简短的一种实现方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) c[i] += a[j] * b[i - j];</span><br><span class="line">    <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">      c[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><h2 id="比笔纸算法更快的算法"><a href="#比笔纸算法更快的算法" class="headerlink" title="比笔纸算法更快的算法"></a>比笔纸算法更快的算法</h2></div><p>用递归的方式优化乘法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multiply</span>(u, v) <span class="comment">//快速计算uv；</span></span><br><span class="line">Input: 正整数 u、 v, in binary</span><br><span class="line">Output: uv</span><br><span class="line">n = <span class="built_in">max</span>(size of u, size of v)</span><br><span class="line"><span class="keyword">if</span> n = <span class="number">1</span>  <span class="keyword">return</span> xy</span><br><span class="line">U1=u的高n/<span class="number">2</span>位， U0 =  u的低 n/<span class="number">2</span> 位</span><br><span class="line">V1 =v的高n/<span class="number">2</span>位, V0= v的低 n/<span class="number">2</span> 位</span><br><span class="line">P1 = <span class="built_in">multiply</span>(U1, V1)</span><br><span class="line">P2 = <span class="built_in">multiply</span>(U0 , V0)</span><br><span class="line">P3 = <span class="built_in">multiply</span>(U1-U0, V0-V1)</span><br><span class="line"><span class="keyword">return</span> =(<span class="number">2</span>^n<span class="number">+2</span>^n/<span class="number">2</span>)P1<span class="number">+2</span>^n/<span class="number">2</span>*P2+(<span class="number">2</span>^n/<span class="number">2</span><span class="number">+1</span>)P3</span><br></pre></td></tr></table></figure><p>递归表达式：<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>T</mi><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo><mo>≤</mo><mn>3</mn><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>c</mi><mi>n</mi></math><br>最终，算法复杂度约为n的1.5次方。</p><div class="note primary flat"><h2 id="复数乘法"><a href="#复数乘法" class="headerlink" title="复数乘法"></a>复数乘法</h2></div><p>两个复数相乘时，减少乘法的次数为3次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">复数乘法(a+bi)*(c+di): <span class="comment">//四次乘法改三次乘法</span></span><br><span class="line">A=a*d</span><br><span class="line">B=b*c</span><br><span class="line">C=(a+b)*(c-d)</span><br><span class="line">(a+bi)*(c+di)=(C-A+B)+(A+B)i</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全：蒙哥马利约减</title>
      <link href="/posts/11252e67.html"/>
      <url>/posts/11252e67.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><div class="note primary flat"><h2 id="蒙哥马利约减"><a href="#蒙哥马利约减" class="headerlink" title="蒙哥马利约减"></a>蒙哥马利约减</h2></div><p>目前使用最广泛的模指数运算方法</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote><p>求y mod N，N为质数。y称为x模N关于R的Montgomery约减,即y&#x3D;xR’ mod N</p></blockquote><blockquote><p>附加条件：不使用除法（除法速度慢）</p><blockquote><p>尽量避免使用取模运算<br>用移位、减法运算替代取模运算</p></blockquote></blockquote><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><blockquote><p>1.取R为2的n次方(如果 N表示为n个b进制数，则 R取b的幂次方)，这样&#x2F; R即右移，*R即左移，mod R即与（R-1）按位与，大大提高了速度。</p></blockquote><blockquote><p>2.N&lt;R,R和N互质，即存在R’和N’，使得RR’ + NN’＝1(保证对任意的x＜R，有k＜R，使得kN&#x3D;x＜R。这保证<strong>表达式</strong>(见下文)的后半部分有解，且大小不超过R&#x2F;R&#x3D;1)。同时，加上y&#x2F;R＜N，故<strong>表达式</strong>的前半部分大小不超过N。综上可得，表达式整体大小不超过2N(故取模可以用减法做)。</p></blockquote><h4 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h4><p>设T&#x3D;Qm+r，欲求T mod m<br>将T分为n的两部分，高n位为T’，低n位为T’’<br>则：<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mfrac><mi>T</mi><mi>R</mi></mfrac><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi><mo>&#x3D;</mo><msup><mi>T</mi><mo>′</mo></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi><mo>+</mo><mn>0.</mn><msup><mi>T</mi><mo>″</mo></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math><br>前半部分只需要移位和最多一次减法。<br>对于后半部分，需要找到0.km，使其与表达式后半部分相加，能将小数部分变成0。即T’’+km&#x3D;cR(R的低位全为0)。加之m和R互素，故这样的k一定存在。实际上，k&#x3D;-1&#x2F;m*T’’ mod R<br>综合可得，T+km是R的倍数。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∗</mo><mi>N</mi><mrow><mo>′</mo></mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>R</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>N</mi><mo stretchy="false">)</mo><mrow><mo>&#x2F;</mo></mrow><mi>R</mi><mo>≡</mo><mi>x</mi><mo>∗</mo><msup><mi>R</mi><mo>′</mo></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>N</mi></math></p></blockquote><blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∗</mo><mi>N</mi><mrow><mo>′</mo></mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>R</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>N</mi><mo stretchy="false">)</mo><mrow><mo>&#x2F;</mo></mrow><mi>R</mi><mo>&lt;</mo><mn>2</mn><mi>R</mi></math></p></blockquote><p>x模 N 关于 R 的Montgomery 约减用2次乘法、1次加法(把-k换成k)、2次移位、1次减法(最后取模时使用)。<br><strong>注意：xmod R和x’’ modR结果一致，因为x’mod R结果为0。同时，结论的x*N‘ modR等于推导式中的-k</strong></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><blockquote><p>取N &#x3D; 3457，R &#x3D; 2^16，得到N’＝12929，R’＝682。求y mod N：</p></blockquote><blockquote><blockquote><p>计算得<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>3310</mn><mo>≡</mo><mi>R</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>N</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>由结论得，<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>y</mi><mo>≡</mo><mo stretchy="false">(</mo><mi>y</mi><mo>∗</mo><mi>R</mi><mo>−</mo><mo stretchy="false">(</mo><mi>y</mi><mo>∗</mo><mi>R</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>N</mi><mrow><mo>′</mo></mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>R</mi><mo>∗</mo><mi>N</mi><mo stretchy="false">)</mo><mrow><mo>&#x2F;</mo></mrow><mi>R</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>代入计算得，<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>y</mi><mo>≡</mo><mo stretchy="false">(</mo><mi>y</mi><mo>∗</mo><mn>3310</mn><mo>−</mo><mi>y</mi><mo>∗</mo><mn>3310</mn><mo>∗</mo><mn>12929</mn><mi>m</mi><mi>o</mi><mi>d</mi><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup><mo>∗</mo><mn>3457</mn><mo stretchy="false">)</mo><mrow><mo>&#x2F;</mo></mrow><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup></math></p></blockquote></blockquote><blockquote><blockquote><p>这种方法的另一个优势在于，<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>R</mi><mo>∗</mo><mi>N</mi><mrow><mo>′</mo></mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>R</mi><mo>∗</mo><mi>N</mi></math>也即<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>12929</mn><mi>m</mi><mi>o</mi><mi>d</mi><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup><mo>∗</mo><mn>3457</mn></math> 可提前计算。</p></blockquote></blockquote><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> u;</span><br><span class="line">    u = a * QINV;  <span class="comment">//QINV固定</span></span><br><span class="line">    t = u * CTRU_Q;<span class="comment">//CTRU_Q固定</span></span><br><span class="line">    t = a - t;</span><br><span class="line">    t &gt;&gt;= <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用：模指数"><a href="#应用：模指数" class="headerlink" title="应用：模指数"></a>应用：模指数</h4><blockquote><p>计算 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>x</mi><mrow><mn>5</mn></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote><blockquote><blockquote><p>计算x*R²的M约减  <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>x</mi><mrow><mo stretchy="false">̃</mo></mrow><mo>&#x3D;</mo><mi>x</mi><mi>R</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>计算x̃²的M约减A： <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>x</mi><msup><mrow><mo stretchy="false">̃</mo></mrow><mrow><mn>2</mn></mrow></msup><mrow><mo>&#x2F;</mo></mrow><mi>R</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>计算A平方的M约减 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>A</mi><mrow><mn>2</mn></mrow></msup><mrow><mo>&#x2F;</mo></mrow><mi>R</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi><mo>&#x3D;</mo><mi>x</mi><msup><mrow><mo stretchy="false">̃</mo></mrow><mrow><mn>4</mn></mrow></msup><mrow><mo>&#x2F;</mo></mrow><msup><mi>R</mi><mrow><mn>3</mn></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>A平方的M约减 乘 x̃的M约减，再进行约减，即得。</p></blockquote></blockquote><p>乘方写成函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x̃ = <span class="built_in">MR</span>(x * (R方 mod m)), ã = <span class="built_in">MR</span>(<span class="number">1</span>*(R方 mod m) ) <span class="comment">//逆向快速幂，输出：x^&#123;e&#125; mod m.</span></span><br><span class="line">For i = t downto <span class="number">0</span></span><br><span class="line">ã = <span class="built_in">MR</span>(ã* ã)</span><br><span class="line">If ei = <span class="number">1</span> then ã = <span class="built_in">MR</span>(ã* x̃)</span><br><span class="line">a = <span class="built_in">MR</span>(ã)</span><br><span class="line"><span class="built_in">Return</span>(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="应用：取模乘法"><a href="#应用：取模乘法" class="headerlink" title="应用：取模乘法"></a>应用：取模乘法</h4><blockquote><p>计算 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>c</mi><mo>&#x3D;</mo><mi>x</mi><mo>∗</mo><mi>y</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote><blockquote><blockquote><p>计算x的M变换 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>x</mi><mo>′</mo></msup><mo>&#x3D;</mo><mi>x</mi><mo>∗</mo><msup><mn>2</mn><mrow><mi>n</mi></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>计算y的M变换 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>y</mi><mo>′</mo></msup><mo>&#x3D;</mo><mi>y</mi><mo>∗</mo><msup><mn>2</mn><mrow><mi>n</mi></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>计算x’和y’的积，再进行M约减 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>c</mi><mo>′</mo></msup><mo>&#x3D;</mo><msup><mi>x</mi><mo>′</mo></msup><mo>∗</mo><msup><mi>y</mi><mo>′</mo></msup><mrow><mo>&#x2F;</mo></mrow><msup><mn>2</mn><mrow><mi>n</mi></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote></blockquote><blockquote><blockquote><p>进行约减，即得。</p></blockquote></blockquote><h4 id="优化：用M约减实现M变换"><a href="#优化：用M约减实现M变换" class="headerlink" title="优化：用M约减实现M变换"></a>优化：用M约减实现M变换</h4><blockquote><p>即计算<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>x</mi><mo>′</mo></msup><mo>&#x3D;</mo><mi>x</mi><mo>∗</mo><msup><mn>2</mn><mrow><mn>2</mn><mi>n</mi></mrow></msup><mrow><mo>&#x2F;</mo></mrow><msup><mn>2</mn><mrow><mi>n</mi></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math></p></blockquote><h4 id="优化：多精度M约减"><a href="#优化：多精度M约减" class="headerlink" title="优化：多精度M约减"></a>优化：多精度M约减</h4><p>当T比较大时。<br>T为2n位，N为n位，R为b的n次方。<br>理论：<br><img src="/study/gaojj.png" alt="多精度"><br>实例：<br><img src="/study/gaoj.png" alt="多精度"></p><h4 id="优化：多精度M乘法"><a href="#优化：多精度M乘法" class="headerlink" title="优化：多精度M乘法"></a>优化：多精度M乘法</h4><p>x为n位，y为n位，N为n位，R为b的n次方。<br>理论：<br><img src="/study/gaoj2j.png" alt="多精度"><br>实例：<br><img src="/study/gaoj2.png" alt="多精度"><br><strong>证明方式见回放</strong></p><div class="note primary flat"><h2 id="barrett约减"><a href="#barrett约减" class="headerlink" title="barrett约减"></a>barrett约减</h2></div><p><img src="/study/barrett.png" alt="barrett"><br>其中r1-r2可能为负数，只需要加一次模。(因为−b^{k+1} &lt; r1 − r2 &lt; b^{k+1})<br>其中第四步最多执行2次。(因为Q-q3≤2)<br>设x&#x3D;Qm+r，则x 的高 k+1位与 1&#x2F;m 的高 2k 比特中的低 k+1 位相乘，取整数部分(高k+1位)得到Q的近似值q3(Q-2≤q3≤Q)。Qm+r-q3m对m取模得到r。<br>问题<br>为什么是模b的k+1次方，为什么要求b&gt;3？ <span class="hide-inline"><button type="button" class="hide-button" style="">Click  </button><span class="hide-content">因为r1-r2＜3m，而m占据k位，如果需要r1-r2少于k+1位(极致地压低模的大小有利于计算速度)，则b>3。若b≤3，则r1-r2为负数时，不只需要加一次模。b的k+1次方，是能保证正确性下的，最方便计算的模数。</span></span><br>为什么r1和r2对非m取模，不影响正确性？ <span class="hide-inline"><button type="button" class="hide-button" style="">Click  </button><span class="hide-content">若m＝1，则结果为1；若m=2，则判断奇偶性；m≥3时，因为Q-q3≤2，且b的k+1次方大于2，故r1、r2对b的k+1次方取模后相减，不会影响正确的Q和q3的差值。加之r＜m＜b的k+1次方，故不会影响正确的r的大小。 实际上，我们并不需要关心Q和q3相差了多少和变没变。这个结果无非是m的系数，多减几次m便可以去除。但是，将Q-q3的结果控制在固定大小内，可以优化减m的速度。</span></span><br>为什么要求b&gt;k？ <span class="hide-inline"><button type="button" class="hide-button" style="">Click  </button><span class="hide-content">使q2的 k − 1位的进位最多是1，若 b 远大于 k，则只需包括 k 和 k+1位的计算。 q2 的低 k-1 位不用参与计算。**详细证明见回放**</span></span></p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>b</mi><mo>&#x3D;</mo><mn>4</mn><mo>,</mo><mi>k</mi><mo>&#x3D;</mo><mn>3</mn><mo>,</mo><mi>x</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>313221</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo>,</mo><mi>m</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>233</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo>&#x3D;</mo><msub><mn>3561</mn><mrow><mn>10</mn></mrow></msub><mo>，</mo><mi>m</mi><mo>&#x3D;</mo><msub><mn>47</mn><mrow><mn>10</mn></mrow></msub><mo stretchy="false">)</mo><mo>.</mo></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mfrac><mn>1</mn><mi>m</mi></mfrac><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>0.00111302</mn><mo>·</mo><mo>·</mo><mo>·</mo><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">⟹</mo><mrow><mo>µ</mo></mrow><mo>&#x3D;</mo><mo stretchy="false">⌊</mo><mfrac><msup><mn>4</mn><mrow><mn>6</mn></mrow></msup><mi>m</mi></mfrac><mo stretchy="false">⌋</mo><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>1113</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo>,</mo></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>x</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>313221</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">⟹</mo><mi>q</mi><mn>1</mn><mo>&#x3D;</mo><mo stretchy="false">⌊</mo><mfrac><mi>x</mi><msup><mn>4</mn><mrow><mn>2</mn></mrow></msup></mfrac><mo stretchy="false">⌋</mo><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>3132</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo>,</mo></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>q</mi><mn>2</mn><mo>&#x3D;</mo><mrow><mo>µ</mo></mrow><mo>·</mo><mi>q</mi><mn>1</mn><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>10231302</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">⟹</mo><mi>q</mi><mn>3</mn><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>1023</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>x</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>313221</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">⟹</mo><mi>r</mi><mn>1</mn><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>3221</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>q</mi><mn>3</mn><mo>·</mo><mi>m</mi><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>313011</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">⟹</mo><mi>r</mi><mn>2</mn><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>3011</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo>,</mo></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>r</mi><mo>&#x3D;</mo><mi>r</mi><mn>1</mn><mo>−</mo><mi>r</mi><mn>2</mn><mo>&#x3D;</mo><mo stretchy="false">(</mo><mn>210</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub></math></p><p>故 x mod m &#x3D; 36。</p><p>参考：<br>1.<a href="http://t.csdnimg.cn/prAaS" title="" target="">CSDN：蒙哥马利约减</a><br>2.<a href="https://blog.csdn.net/mutourend/article/details/95613967?fromshare=blogdetail&sharetype=blogdetail&sharerId=95613967&sharerefer=PC&sharesource=lemonsed&sharefrom=from_link" title="" target="">CSDN：Montgomery reduction——多精度模乘法运算算法</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到第九边缘</title>
      <link href="/posts/6b6b7c33.html"/>
      <url>/posts/6b6b7c33.html</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><script>    (function(d, w, c) {        w.ChatraID = 'D5JbrYK4vHavdTNTf';        var s = d.createElement('script');        w[c] = w[c] || function() {            (w[c].q = w[c].q || []).push(arguments);        };        s.async = true;        s.src = 'https://call.chatra.io/chatra.js';        if (d.head) d.head.appendChild(s);    })(document, window, 'Chatra');</script><h2 id="一、什么是第九边缘文化体系"><a href="#一、什么是第九边缘文化体系" class="headerlink" title="一、什么是第九边缘文化体系"></a>一、什么是第九边缘文化体系</h2><p>“第九边缘是什么？相信并不是所有人都能够意识到。包括我们的代理者，也不能轻易做出一个明确的定义。或许，第九边缘并不符合他们的文化倾向。但在我们的世界里，第九边缘意味着“理性的文化”。它作为一个哲学符号，又或者是文明的动态象征，第九边缘的创造物意味着我们整个世界的智慧与现实。创造意味着新生，意味着第九边缘带来与现实截然不同的选择，记录意味着同步，意味着第九边缘的描述符合我们世界的基本认知，感知意味着神觉，意味着第九边缘存在超出我们世界的看法。在我们的世界里，虚构的文化太多，越来越多的人不重视实际存在的文明。随处可见的新文化，正在抹除文明本身的重量，使人们轻薄于学习既有的事物，去了解既有的历史。我们急需一种代表，能够保存我们的实际文明的同时，吸引绝大多数人们接纳我们的现实世界。这就是第九边缘，一个虚拟的科研组织，一个文明的汇聚之核。”（来自第九边缘：创世档案）<br>这是来自《创世档案》中的描述。可见，我们一直在回避这个问题。究其原因，是我们未曾拥有真实的历史。具体而言，第九边缘诞生于初中的一次灵感，又或者发源自一个初中生对虚构式未来的幻想。<br>我们在幻想世界的途中，融入了太多太多的元素。从自然、世界、人生，到风格、测试、涵养，我们融合了我们所认可的人类文化，也在尽我们所能塑造人类文化的一角。<br>但万事万物，如果一旦将其落在纸笔之上，就会拥有一个独属于它的定义。否则，我们无法认识到自己在做什么。<br>简单来说，<strong>第九边缘文化体系是一种理性的、规范的世界哲学体系，是立足于内在自我的，看待世界的一种立场、观点、方法。</strong><br>我们正式地在其后加上“体系”两字，是因为我们已经准备好向大众展示我们的世界。“体系”不仅意味着第九边缘从虚构世界的“科研团体”走出，而且意味着我们打算以一种成体系的方式展示我们的构造之物。<br>下面，我们将介绍第九边缘文化体系的构成。（在不引起争议时，我们将第九边缘文化体系简称为第九边缘）</p><h3 id="（一）-第九边缘理论研究及文章创造（SCHNIE）"><a href="#（一）-第九边缘理论研究及文章创造（SCHNIE）" class="headerlink" title="（一）.第九边缘理论研究及文章创造（SCHNIE）"></a>（一）.第九边缘理论研究及文章创造（SCHNIE）</h3><p>第九边缘的理论包含世界宇宙观，人生价值观，五维能力测试等部分，文章包含灵耀体系，九虹重启，三大规划等部分。<br>SCHNIE既从生活中提炼一些理性规则，也从一些典籍中寻找构建神话体系的力量。我们有批判，有引导，但同时也有激进，有妥协。我们需要不断面对自己的不足，也希望读者能够成为我们不断前行的后备力量。</p><h3 id="（二）-第九边缘内容椽笔及平台建设（SCHNIEBOW）"><a href="#（二）-第九边缘内容椽笔及平台建设（SCHNIEBOW）" class="headerlink" title="（二）.第九边缘内容椽笔及平台建设（SCHNIEBOW）"></a>（二）.第九边缘内容椽笔及平台建设（SCHNIEBOW）</h3><p>理论需要从实践中得到证实。<br>世界也需从运作中不断获取新的活力。第九边缘的平台包含QQ群，QQ频道，QQ发布号，官方网站，官方bilibili账号，微信公众号等。即便我们没有专业的力量协助，也能够构建出一个模糊但缺失专业性的框架。<br>我们迫切地需要外界的帮助，因为我们不擅长宣传自己。即便为了个数而扩展影响与我们的理性理念背道相驰，但我们的体系经过长期的理论积压，很难能够找出其中不断放大的缺陷。<br>世界总是完整的，而我们的体系注定如彩虹一般，只有部分流露在外。这是一种自我保护，也是一种保守底牌的策略。但我们由衷地希望，我们呈现出的那些光彩，能够照亮每一个需要的角落。<br>而这些角落，依赖大家的视线，依赖大家共同撑起的网络。</p><h3 id="（三）-第九边缘体系内核（schrodingerXI）"><a href="#（三）-第九边缘体系内核（schrodingerXI）" class="headerlink" title="（三）.第九边缘体系内核（schrodingerXI）"></a>（三）.第九边缘体系内核（schrodingerXI）</h3><p>极简，精确，相和，理性。<br>不添加多余之物，以最直接的方式逼近事物的内核；不被表象和偏见迷惑，以最关键的力量冲击事物的本质；与世界共生，与同伴共进，保持理性，不断前行。<br>感知，记录，创造。<br>感知是万物存在的标志，记录是万物运行的轨迹，创造是万物变化的结果。三生万物，竞逐方舟。<br>第九边缘，是人与世界共同的体系。</p><h3 id="（四）-第九边缘模组使用协议（DLXII）"><a href="#（四）-第九边缘模组使用协议（DLXII）" class="headerlink" title="（四）.第九边缘模组使用协议（DLXII）"></a>（四）.第九边缘模组使用协议（DLXII）</h3><p>与一般的“小说”不同的是，第九边缘的世界构造并不是由我们独立编辑，而是由探索者共同编辑的。我们共享我们的世界，也需要大家的共同维护。<br>读者们可以在原作的基础上进行修改，并著以第九边缘的标识进行传播。但不得添加其他的限制条件，不得以此谋利，不得申请版权及发布在小说网站，也不得转嫁责任给其他维护者。<br>我们尊重你从中获取灵感的权益，也尊重你作为一个独立创作者的权益。<br>在这种方式下，有一个显著的好处：第九边缘的世界构造，更能够接近我们所追求的“理性”—从最大程度上避免因偏见，知识面不全而造成世界构造的疏漏。这也符合我们追求效率这一原则。<br>我们诚恳地邀请您协助我们构建那个世界。在这里，我们将共享所有的与世界构造有关的内容，您可以查阅后以自己的理解来补充或创造新的内容。</p><hr><h2 id="二、第九边缘的起源和发展"><a href="#二、第九边缘的起源和发展" class="headerlink" title="二、第九边缘的起源和发展"></a>二、第九边缘的起源和发展</h2><p>正如上文所言，第九边缘来自于一个灵感。虽然我们不能够从我们的发展历史中获得自信—我们的实践来自于对内在世界的不断探索，而非体现在对外部世界的探究和改造。我们也缺乏专业的素养，甚至，第九边缘的整个世界，都来自于一份稚嫩的猜想。<br>不过，我们希望保持这种落后性。第九边缘不是某些哲学思想的复制品，也不是一类哲学思想的整合。我们希望这些显有稚嫩的个人偏见，能够成为读者世界观，人生观，价值观参照或批判的一部分。<br>第九边缘在2021年推出了《设定合集》，其主体内容是我们认为的值得分享的美好事物；并在2022年推出了《以神之名》：它的出现意味着我们的哲学内核，即世界观，人生观，自然观趋于成熟。<br>在2023年，大学生活打开了我们走向世界的大门，我们推出了《梦境疗法》，我们第一次以一种伪互动的文体向读者展示我们的构造世界。<br>而2024年所著的《第九边缘文化体系：概论》则采用了思政类“教科书”的特点：分条分点，逐步递进，全文关联。<br>在创作这本书的念头诞生前，我们也曾建立过QQ群，以诸多文件为载体，分享我们的世界。但结果不尽乐观：读者们似乎对这种“莫名其妙”的分类不具有兴趣，而且难以理解高度凝练到过于抽象的思想逻辑。<br>即便第九边缘一直试图在具体的事情中探索抽象，而非在抽象的逻辑中强求具体，但我们选取的被当做“具体”的对象，对于第一次接触我们的人而言，还是过于晦涩抽象。<br>故我们需要一个引导者，一个忠实的、不厌其详的引导者，将我们的创造物分散到各个篇章，以一种更加科学合理的方式，引导读者认识并认知我们的世界。</p><hr><h2 id="三、九大课题"><a href="#三、九大课题" class="headerlink" title="三、九大课题"></a>三、九大课题</h2><p>提出诸多概念，指出多种模型，归根结底是为了回答一些问题。第九边缘认为我们需要回答九个课题。<br>1.开端也是结局：世界，无比真实，回答对世界本质的整体把握的课题。第九边缘认为世界无所谓真实与虚幻，我们希望能够活在属于自己的理念世界里。读者们可以思考：万物客观存在，还是受限于观测者？事物性质是可知的，还是不可明确？事物根本上是统一的，还是各自划分区域？<br>2.稳定但是多变：思维，融于物质，回答对事物逻辑的规范划分的课题。第九边缘认为世界由物质构成，可物质以思维为形式，投递到我们的意识之中。读者们可以思考：事物有哪些存在方式，他们之间的联系是什么？我们能获得哪些信息，他们之间的联系是什么？事物间有哪些关系，这些关系的联系是什么？<br>3.世界起源：能量与时间差，回答发展与起源的课题。第九边缘认为能量不均导致时间流动，而时间流动激化思维，进一步演变成物质。读者们可以思考：发展和更替是无限的，还是存在端点？起源和覆灭是明确的，还是混沌一体？<br>4.矛盾产生：这成必要决断，回答选择与取向的课题。第九边缘认为矛盾的出现，使万物万事凝聚成该有的形状。读者们可以思考：真理和价值是客观规定的，还是个性化选择？理论和认知是逐步完善的，还是虚构的逻辑？<br>5.故事开端：我们为何生活，回答生存与生活的课题。第九边缘认为生活是社会赋予的职责，同时也能填补不平衡的内心。读者们可以思考：在你的世界观里，维持生存有哪些必然因素？在你的世界观里，追求生活有哪些不同方式？<br>6.恪守本分：臣服乃是前提，回答社会与自我的课题。第九边缘认为在有能力质疑或改变一件事之前，必经臣服。读者们可以思考：外界秩序和更优策略发生冲突时，如何处理？社会道德和个人判断发生冲突时，如何评判？<br>7.维系深井：认知存在局限，回答实力和认知的课题。第九边缘认为智慧徒增伤感，没有实力之前，请甘于维护愚昧。读者们可以思考：实力不足以支撑认知时，认知是什么地位？所处环境不认可实力时，实力是什么地位？<br>8.遗忘但是存在：意识，还是事实，回答对自我存在的空泛认知的课题。第九边缘认为承载已发生之事的记忆，决定着“我”是谁。读者们可以思考：自我和他我的界限是什么？不同阶段自我界限是什么？“自我”的概念依赖什么而产生？<br>9.终端也是启程：世界，本成一线，回答对一切概率的均衡判决的课题。第九边缘认为所有可能都在实际发生，我们做出的选择，是一场场自己与自己的争斗。读者们可以思考：万事皆可存在，还是依赖逻辑？事物早已决定，还是无限可能？追求注定随生命而消逝的未来，究竟是为了什么？</p><hr><h2 id="四、如何看待第九边缘世界"><a href="#四、如何看待第九边缘世界" class="headerlink" title="四、如何看待第九边缘世界"></a>四、如何看待第九边缘世界</h2><p>现实存在着混沌、泥泞、内卷、腐败。不如向内看，广泛而自由地肯定自己的精神价值，从认可自我开始，从改变认知方式开始，重新观察世界，探索世界，改变世界。<br>第九边缘文化体系绝不是是什么严肃的文化依托，也不是什么专业的产物。它更像是一种建议，建议我们的读者以某种被建议的方式认识世界，改造世界，从而在探索世界中获得乐趣，在研究世界中获得感触。<br>没有人的偏见是理所当然的，但当我们质疑一种不合理时，自身的理性直觉从未是一种理由。我们希望读者们能够有原因地指出我们的缺点，我们乐于在不断改正中前行。<br>向后看是为了把握外壳，向前看是为了赋予生命。那么，就让我们从这里开始：<br>追溯，启航！</p><hr><h2 id="参考书下载"><a href="#参考书下载" class="headerlink" title="参考书下载"></a>参考书下载</h2><a href="https://picbed.sch-nie.com/SCHNIE/%E7%AC%AC%E4%B9%9D%E8%BE%B9%E7%BC%98%E6%96%87%E5%8C%96%E4%BD%93%E7%B3%BB%EF%BC%9A%E6%A6%82%E8%AE%BA.pdf" title="" target="">第九边缘文化体系概论</a></div>]]></content>
      
      
      <categories>
          
          <category> 世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SCHNIE </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
