---
title: 计算机安全：安全策略
tags: 计算机安全
categories: 计算机
comments: true
swiper_index: 10
hide: true
copyright_author: 薛定谔柠檬
cover: /study/jsjaq.png
abbrlink: a5baeaeb
date: 2024-10-06 11:50:40
updated: 2024-11-2 15:50:40
---
{% note warning flat %}
## 什么是安全策略
{% endnote %}
计算机安全的一般定义：你可以依赖计算机，且计算机如你预料的那样行动。
不同的计算机对安全有更精确的划分，描述这种安全的方式叫做安全策略。
安全机制：实现安全策略的机制。
攻击破坏安全机制，使计算机在预料之外行动。
{% note warning flat %}
## 计算机安全基本问题
{% endnote %}
在什么条件下，一个计算机算法可判定一个计算机系统是否安全？
结论：安全模型表达能力越强，验证安全性越难。简单模型描述能力有限，但存在有效验证安全性的方法。

{% note primary flat %}
## 访问控制模型
{% endnote %}
{% tabs 1 %}
<!-- tab 访问控制矩阵ACM -->
保护状态：涉及安全保护的状态
ACM是描述当前保护状态的最精确的模型，主体与主体之间也存在不同权限。
|           | 文件f     | 文件g |进程p     | 进程q |
| -------- | -------- | ---- | -------- | ---- |
| 进程p        | 读写 | 读写   |读写添加创建 | **写**   |
| 进程q       | 读写 | 读写   |**读** |  读写添加创建   |

ACM的行称为能力表，ACM的列称为访问控制列表(常用)。
<!-- endtab -->

<!-- tab Haarrion-Ruzzo-Ullman模型 -->
基本命令：创建主体客体、删除主客体、增加权限，删除权限。
单步命令：包含一条基本命令(基本命令不可直接调用)的命令。单步命令系统的可靠性问题可判定。
>证明：
> 1.delete操作可忽略：因为状态数固定
> 2.所有create合并成一个：最多增加一个主客体，因为只考虑r权限是否泄漏
> 3.故系统规模是有限的，命令总数k≤命令种类数*(主体+1)*(客体+1)，可用穷举方式判定

条件命令：包含条件控制的命令，实现更合理的安全策略。多条件命令**只能用AND**连接条件。
可靠(安全)的：一个权限r不会被加入到原来不存在r的矩阵元素中。
在最普通、最抽象的情况下，计算机的安全是不可判定的。对于普通的HRU模型一系列操作，不存在算法判断权限是否泄漏。
>证明：
>将图灵机停机问题归约为可靠性问题，而图灵机停机问题不可判定，故可靠性问题不可判定。
>>证明：
>>设D(i,x)返回i号图灵机在输入为x时是否停机。构造图灵机y号如下:
>>if D(i,x)=停 then 不停 else 停
>>则输入的编号为y时，产生悖论，故不存在这样的图灵机y，即判定图灵机是否停机问题的算法是无限的。

#### 图灵机停机问题
图灵机：能模拟任何确定、可行、有限的算法。如果图灵机不能进入任何预设的接受拒绝状态，则图灵机不停机。
图灵机问题指的是，是否存在图灵机能回答,任意图灵机在任意输入下,是否停机的问题?
#### 用ACM矩阵表示图灵机
![ACM](study/acm.png)
其中，纸袋的左移、右移、写，越过边界，可由一系列ACM命令模拟。
own确定了纸带单元的顺序。
k的存在保证同一时刻只有一条命令被触发。
<!-- endtab -->

<!-- tab Take-Grant模型 -->
第一种可判定安全性的访问控制模型，时间是系统规模的线性函数。
#### 规则
>take：主体A可获取B的所有权限。
主体s若能获得y拥有的所有权限，则s可最终扩展为y。
grant：主体A可将自身拥有的任意权限赋给B。
主体s若能把其权限赋给r，则s可初始扩展为r。
create：主体创造对象。
remove：主体移除对象或权限。

只有主体能主动执行一些动作，规则是修改ACM的权限。规则不是对系统的修改，而是对系统描述的修改。

#### 特性
对称性
![对称性](study/take.png)
>即z对x有take权限，x也能通过一系列操作获得z的权限。
和x对z有take权限的区别：需要双方进行操作，而非一方进行操作。

#### 保护状态图
岛：最大的，tg相连的，都是主体的子图。如果tg相连的都是主体，那么take和grant权限是对称的。
桥：连接众多主体、客体的路径(全是take权限；或take权限夹单个grand权限)，但桥的两端都是主体。(证明见回放)
谓词can·share(r,x,y,G)：返回节点x能否获得对y的r权限。
>如果x，y是一个岛上的主体，则返回真。

> 为真的充要条件1：如果x有一条边r连向y，则返回真。

> 为真的充要条件2：主体s有对y的r权限边，主体s和**主体x**在一些由桥连接的岛上。

> 为真的充要条件3：主体s有对y的r权限边，存在主体x‘=x或x’初始扩展为x，存在主体s‘=s或s’最终扩展为s，主体s‘和主体x’在一些由桥连接的岛上。

任何两个点x，y的can·share(r,x,y,G)可用时间复杂度有限的算法判定。
<!-- endtab -->
{% endtabs %}

{% note primary flat %}
## 访问控制策略类型
{% endnote %}
按照主体对ACM的权限进行的分类：
{% tabs 2 %}
<!-- tab  自主型访问控制DAC-->
基于身份的访问控制。
主体能自主地将访问权授予其他主体。
局限：主体不能控制信息的流动。
攻击：
![木马](study/muma.png)
<!-- endtab -->

<!-- tab 强制访问控制MAC -->
基于规则的访问控制。
系统机制控制对客体的访问，一般用户不能改变访问控制矩阵。
需要一个中心控制权威。
<!-- endtab -->

<!-- tab 创建者控制访问机制ORCON -->
DAC和MAC的结合。
没有创建者的许可，客体不会被泄露；**客体的任何副本也遵循同样的限制**。
<!-- endtab -->
{% endtabs %}


{% note primary flat %}
## 访问控制机制
{% endnote %}
{% tabs 3 %}
<!-- tab  访问控制列表ACL-->
ACM的列，去除空表项，表和客体绑定。
应用：文件目录，网络防火墙。
易于集中管理，管理员可知道哪些主体拥有权限。
<!-- endtab -->

<!-- tab 能力表 -->
ACM的行，去除空表项，表和主体绑定。
应用：分布式系统，微内核。
易于传递权限，无需管理员审批；不易于查找某一权限。
问题：
撤销权限时，要遍历所有主体。{% hideInline 构造一个全局客体表，主体引用全局客体表的表号代表客体(解决了撤销权限的问题，寻找权限的问题没解决) %}
<!-- endtab -->


<!-- tab 基于角色的访问控制RBAC-->
RBAC根据用户所拥有的角色进行访问控制和授权。
管理员角色管理权限的授予和撤销，用户的访问权限不可以主动转交。(非自主的访问控制)
应用：数据库、分布式系统。
一个用户可以发起几次会话，在不同会话中承担不同角色。
角色间的层次关系：角色A的权限包含角色B的所有权限。
约束：角色互斥、角色的实例限制等
>静态职责分离SSD：系统设计之初就定义好了的互斥角色
>动态职责分离DSD：系统运行期间，动态地限制用户拥有的角色 

优点：
>提高了管理员的管理能力(简化了授权模型，可方便实现权力分割、互斥)
> 模型与组织机构自然对应(使用起来很自然)

<!-- endtab -->

<!-- tab 基于属性的访问控制ABAC -->
优点：
细粒度的访问控制；
灵活，适合动态访问控制；
减少用户和角色数量；
描述专业系统的防控策略。
属性分为主体属性，客体属性，环境属性。
ABAC在判断用户能否权限时，组合各类属性，代入规则以计算权限。
可实现DAC,RBAC,MAC等。
#### 策略
![策略](study/abac.png)
<!-- endtab -->
{% endtabs %}


{% note primary flat %}
## 安全策略类型
{% endnote %}
{% tabs 3 %}
<!-- tab  保密性策略-->
用于军事安全策略。
基础：Bell-La Padula模型

#### Bell-La Padula模型
访问权限：执行、附加(追加写)、读、写。
Bell-La Padula模型约束信息的流动，信息不能由高安全级流向低安全级。
主体只能向下读(主体要有客体的DAC读权限)，向上附加(主体要有客体的DAC附加权限)，同级写(主体要有客体的DAC写权限)。
问题：有时候并不是所有的向下读等都是有必要的。
优化：给主体贴上“安全等级“的标签，安全等级由安全级别、类别构成。如{Too Secret，{Nuc，Eur，Asi}}
#### 关系优化
![支配](study/zhipei.png)
支配关系dom，是部分序关系。基于需要知道原则，即便是同级的主体，也可能无法互相访问。
理解：{Too Secret，{Nuc，Eur，Asi}} dom {Too Secret，{Eur，Asi}}，意思为拥有前一个标签的主体，能访问拥有后一个标签的主体。
#### 对DAC木马问题的解决

![木马](study/mumaa.png)

#### 局限和结论
局限：没有涉及完整性，级别是静态的，包含隐形道(可能泄露高级对象的名字)。
重要结论：基本安全定理-状态迁移是安全的，初始状态是安全的，则其后的每一个状态都是安全的。
<!-- endtab -->

<!-- tab 完整性策略 -->
用于商业安全策略。
著名模型：Biba完整性模型。
#### Biba完整性模型
完整性级别越高，数据越可信。
Biba完整性模型约束信息的改变，对信息的写会破坏完整性。
<font color=red>Low-Water-Mark策略</font>
>主体能向下写(主体的完整性等级高于客体的完整性等级)，向上读。
>当一个主体读了一个低完整性客体，那么主体的完整性等级下降到该客体。
>可以invoke(调用)低级别的客体。

<font color=red>环策略</font>
>主体完整性等级都相同。
> 任意主体能read任意客体。
> 主体能向下写(主体的完整性等级高于客体的完整性等级)。
> 可以invoke(调用)低级别的客体。

忽略了间接修改的问题，导致信息可以向上流。
<font color=red>严格完整性策略</font>

>主体能向下写(主体的完整性等级高于客体的完整性等级)，向上读。
> 可以invoke(调用)低级别的客体。
<!-- endtab -->

<!-- tab 混合策略 -->
代表：中国墙模型，创建者控制访问机制ORCON，基于角色、属性的访问控制。

#### 中国墙模型
解决商业中的利益冲突问题。
将信息对象分为“利益冲突”类。
CD：与一个公司有关的信息的集合。
COI：有利益冲突的公司的CD的集合，每个CD只属于一个COI。
![COI](study/coi.png)
#### 规则
s可以读o，当s读过o所属的CD的客体，或s没有读过其他冲突CD，或o是无毒客体。主体在一个COI中只能访问一个CD。
s可以写o，当s能够读的全部未消毒客体(即有毒个体，也即信息需要保密的个体。无毒：信息可以被任何主体读。)，与**可读的**o在一个CD中。
#### 联系和区别
与BLP本质区别：BLP用了安全标签，CW用了访问历史。
BLP能够模拟CW任意时刻的状态(不能跟踪变化)，而CW能模拟BLP整体。
![CW模拟](study/youdu.png)
<!-- endtab -->
{% endtabs %}


参考资料：
1.{%link 信息安全模型 https://blog.csdn.net/sinat_41135487/article/details/105443141?fromshare=blogdetail&sharetype=blogdetail&sharerId=105443141&sharerefer=PC&sharesource=lemonsed&sharefrom=from_link%}
2.{%link Bell-Lapudula模型 https://blog.csdn.net/waqqy/article/details/127803086?fromshare=blogdetail&sharetype=blogdetail&sharerId=127803086&sharerefer=PC&sharesource=lemonsed&sharefrom=from_link%}
