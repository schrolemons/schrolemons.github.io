---
title: 计算机安全：蒙哥马利约减
tags: 计算机安全
categories: 计算机
comments: true
hide: true
swiper_index: 10
cover: /study/jsjaq.png
copyright_author: 薛定谔柠檬
abbrlink: '11252e67'
date: 2024-09-15 15:50:40
updated: 2024-10-20 15:50:40
---
{% note primary flat %}
## 蒙哥马利约减
{% endnote %}
目前使用最广泛的模指数运算方法
#### 问题

>求y mod N，N为质数。y称为x模N关于R的Montgomery约减,即y=xR' mod N

>附加条件：不使用除法（除法速度慢）
>>尽量避免使用取模运算
>>用移位、减法运算替代取模运算




#### 设计

>1.取R为2的n次方(如果 N表示为n个b进制数，则 R取b的幂次方)，这样/ R即右移，*R即左移，mod R即与（R-1）按位与，大大提高了速度。

>2.N<R,R和N互质，即存在R'和N'，使得RR' + NN'＝1(保证对任意的x＜R，有k＜R，使得kN=x＜R。这保证**表达式**(见下文)的后半部分有解，且大小不超过R/R=1)。同时，加上y/R＜N，故**表达式**的前半部分大小不超过N。综上可得，表达式整体大小不超过2N(故取模可以用减法做)。

#### 推导
设T=Qm+r，欲求T mod m
将T分为n的两部分，高n位为T'，低n位为T''
则：<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mfrac><mi>T</mi><mi>R</mi></mfrac><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi><mo>=</mo><msup><mi>T</mi><mo>′</mo></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi><mo>+</mo><mn>0.</mn><msup><mi>T</mi><mo>″</mo></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math>
前半部分只需要移位和最多一次减法。
对于后半部分，需要找到0.km，使其与表达式后半部分相加，能将小数部分变成0。即T''+km=cR(R的低位全为0)。加之m和R互素，故这样的k一定存在。实际上，k=-1/m*T'' mod R
综合可得，T+km是R的倍数。



#### 结论

><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∗</mo><mi>N</mi><mrow><mo>′</mo></mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>R</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>N</mi><mo stretchy="false">)</mo><mrow><mo>/</mo></mrow><mi>R</mi><mo>≡</mo><mi>x</mi><mo>∗</mo><msup><mi>R</mi><mo>′</mo></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>N</mi></math>

><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∗</mo><mi>N</mi><mrow><mo>′</mo></mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>R</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>N</mi><mo stretchy="false">)</mo><mrow><mo>/</mo></mrow><mi>R</mi><mo>&lt;</mo><mn>2</mn><mi>R</mi></math>

x模 N 关于 R 的Montgomery 约减用2次乘法、1次加法(把-k换成k)、2次移位、1次减法(最后取模时使用)。
**注意：xmod R和x'' modR结果一致，因为x'mod R结果为0。同时，结论的x*N‘ modR等于推导式中的-k**

#### 例子

>取N = 3457，R = 2^16，得到N'＝12929，R'＝682。求y mod N：

>>计算得<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>3310</mn><mo>≡</mo><mi>R</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>N</mi></math>



>>由结论得，<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>y</mi><mo>≡</mo><mo stretchy="false">(</mo><mi>y</mi><mo>∗</mo><mi>R</mi><mo>−</mo><mo stretchy="false">(</mo><mi>y</mi><mo>∗</mo><mi>R</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>N</mi><mrow><mo>′</mo></mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>R</mi><mo>∗</mo><mi>N</mi><mo stretchy="false">)</mo><mrow><mo>/</mo></mrow><mi>R</mi></math>

>>代入计算得，<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>y</mi><mo>≡</mo><mo stretchy="false">(</mo><mi>y</mi><mo>∗</mo><mn>3310</mn><mo>−</mo><mi>y</mi><mo>∗</mo><mn>3310</mn><mo>∗</mo><mn>12929</mn><mi>m</mi><mi>o</mi><mi>d</mi><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup><mo>∗</mo><mn>3457</mn><mo stretchy="false">)</mo><mrow><mo>/</mo></mrow><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup></math>



>>这种方法的另一个优势在于，<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>R</mi><mo>∗</mo><mi>N</mi><mrow><mo>′</mo></mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>R</mi><mo>∗</mo><mi>N</mi></math>也即<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>12929</mn><mi>m</mi><mi>o</mi><mi>d</mi><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup><mo>∗</mo><mn>3457</mn></math> 可提前计算。



#### 函数
```c++
int f(int a)
{
int t;
int u;
    u = a * QINV;  //QINV固定
    t = u * CTRU_Q;//CTRU_Q固定
    t = a - t;
    t >>= 16;
    return t;
}
```

#### 应用：模指数

>计算 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>x</mi><mrow><mn>5</mn></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math>

>>计算x*R²的M约减  <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>x</mi><mrow><mo stretchy="false">̃</mo></mrow><mo>=</mo><mi>x</mi><mi>R</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math>

>>计算x̃²的M约减A： <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>x</mi><msup><mrow><mo stretchy="false">̃</mo></mrow><mrow><mn>2</mn></mrow></msup><mrow><mo>/</mo></mrow><mi>R</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math>

>>计算A平方的M约减 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>A</mi><mrow><mn>2</mn></mrow></msup><mrow><mo>/</mo></mrow><mi>R</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi><mo>=</mo><mi>x</mi><msup><mrow><mo stretchy="false">̃</mo></mrow><mrow><mn>4</mn></mrow></msup><mrow><mo>/</mo></mrow><msup><mi>R</mi><mrow><mn>3</mn></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math>

>>A平方的M约减 乘 x̃的M约减，再进行约减，即得。

乘方写成函数如下：
```c++
x̃ = MR(x * (R方 mod m)), ã = MR(1*(R方 mod m) ) //逆向快速幂，输出：x^{e} mod m.
For i = t downto 0
ã = MR(ã* ã)
If ei = 1 then ã = MR(ã* x̃)
a = MR(ã)
Return(a)

```

#### 应用：取模乘法
>计算 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>c</mi><mo>=</mo><mi>x</mi><mo>∗</mo><mi>y</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math>

>>计算x的M变换 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>x</mi><mo>′</mo></msup><mo>=</mo><mi>x</mi><mo>∗</mo><msup><mn>2</mn><mrow><mi>n</mi></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math>

>>计算y的M变换 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>y</mi><mo>′</mo></msup><mo>=</mo><mi>y</mi><mo>∗</mo><msup><mn>2</mn><mrow><mi>n</mi></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math>

>>计算x'和y'的积，再进行M约减 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>c</mi><mo>′</mo></msup><mo>=</mo><msup><mi>x</mi><mo>′</mo></msup><mo>∗</mo><msup><mi>y</mi><mo>′</mo></msup><mrow><mo>/</mo></mrow><msup><mn>2</mn><mrow><mi>n</mi></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math>

>>进行约减，即得。



#### 优化：用M约减实现M变换
>即计算<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>x</mi><mo>′</mo></msup><mo>=</mo><mi>x</mi><mo>∗</mo><msup><mn>2</mn><mrow><mn>2</mn><mi>n</mi></mrow></msup><mrow><mo>/</mo></mrow><msup><mn>2</mn><mrow><mi>n</mi></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></math>

#### 优化：多精度M约减
当T比较大时。
T为2n位，N为n位，R为b的n次方。
理论：
![多精度](/study/gaojj.png)
实例：
![多精度](/study/gaoj.png)

#### 优化：多精度M乘法
x为n位，y为n位，N为n位，R为b的n次方。
理论：
![多精度](/study/gaoj2j.png)
实例：
![多精度](/study/gaoj2.png)
**证明方式见回放**


{% note primary flat %}
## barrett约减
{% endnote %}



![barrett](/study/barrett.png)
其中r1-r2可能为负数，只需要加一次模。(因为−b^{k+1} < r1 − r2 < b^{k+1})
其中第四步最多执行2次。(因为Q-q3≤2)
设x=Qm+r，则x 的高 k+1位与 1/m 的高 2k 比特中的低 k+1 位相乘，取整数部分(高k+1位)得到Q的近似值q3(Q-2≤q3≤Q)。Qm+r-q3m对m取模得到r。
问题
为什么是模b的k+1次方，为什么要求b>3？ {% hideInline 因为r1-r2＜3m，而m占据k位，如果需要r1-r2少于k+1位(极致地压低模的大小有利于计算速度)，则b>3。若b≤3，则r1-r2为负数时，不只需要加一次模。b的k+1次方，是能保证正确性下的，最方便计算的模数。 %}
为什么r1和r2对非m取模，不影响正确性？ {% hideInline 若m＝1，则结果为1；若m=2，则判断奇偶性；m≥3时，因为Q-q3≤2，且b的k+1次方大于2，故r1、r2对b的k+1次方取模后相减，不会影响正确的Q和q3的差值。加之r＜m＜b的k+1次方，故不会影响正确的r的大小。
实际上，我们并不需要关心Q和q3相差了多少和变没变。这个结果无非是m的系数，多减几次m便可以去除。但是，将Q-q3的结果控制在固定大小内，可以优化减m的速度。
%}
为什么要求b>k？ {% hideInline  使q2的 k − 1位的进位最多是1，若 b 远大于 k，则只需包括 k 和 k+1位的计算。 q2 的低 k-1 位不用参与计算。**详细证明见回放**%}
#### 例子
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>b</mi><mo>=</mo><mn>4</mn><mo>,</mo><mi>k</mi><mo>=</mo><mn>3</mn><mo>,</mo><mi>x</mi><mo>=</mo><mo stretchy="false">(</mo><mn>313221</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo>,</mo><mi>m</mi><mo>=</mo><mo stretchy="false">(</mo><mn>233</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo>=</mo><msub><mn>3561</mn><mrow><mn>10</mn></mrow></msub><mo>，</mo><mi>m</mi><mo>=</mo><msub><mn>47</mn><mrow><mn>10</mn></mrow></msub><mo stretchy="false">)</mo><mo>.</mo></math>

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mfrac><mn>1</mn><mi>m</mi></mfrac><mo>=</mo><mo stretchy="false">(</mo><mn>0.00111302</mn><mo>·</mo><mo>·</mo><mo>·</mo><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">⟹</mo><mrow><mo>µ</mo></mrow><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><msup><mn>4</mn><mrow><mn>6</mn></mrow></msup><mi>m</mi></mfrac><mo stretchy="false">⌋</mo><mo>=</mo><mo stretchy="false">(</mo><mn>1113</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo>,</mo></math>


<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>x</mi><mo>=</mo><mo stretchy="false">(</mo><mn>313221</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">⟹</mo><mi>q</mi><mn>1</mn><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><mi>x</mi><msup><mn>4</mn><mrow><mn>2</mn></mrow></msup></mfrac><mo stretchy="false">⌋</mo><mo>=</mo><mo stretchy="false">(</mo><mn>3132</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo>,</mo></math>

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>q</mi><mn>2</mn><mo>=</mo><mrow><mo>µ</mo></mrow><mo>·</mo><mi>q</mi><mn>1</mn><mo>=</mo><mo stretchy="false">(</mo><mn>10231302</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">⟹</mo><mi>q</mi><mn>3</mn><mo>=</mo><mo stretchy="false">(</mo><mn>1023</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub></math>

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>x</mi><mo>=</mo><mo stretchy="false">(</mo><mn>313221</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">⟹</mo><mi>r</mi><mn>1</mn><mo>=</mo><mo stretchy="false">(</mo><mn>3221</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub></math>

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>q</mi><mn>3</mn><mo>·</mo><mi>m</mi><mo>=</mo><mo stretchy="false">(</mo><mn>313011</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo stretchy="false">⟹</mo><mi>r</mi><mn>2</mn><mo>=</mo><mo stretchy="false">(</mo><mn>3011</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub><mo>,</mo></math>


<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>r</mi><mo>=</mo><mi>r</mi><mn>1</mn><mo>−</mo><mi>r</mi><mn>2</mn><mo>=</mo><mo stretchy="false">(</mo><mn>210</mn><msub><mo stretchy="false">)</mo><mrow><mi>b</mi></mrow></msub></math>

故 x mod m = 36。



参考：
1.{% link CSDN：蒙哥马利约减 http://t.csdnimg.cn/prAaS%}
2.{% link CSDN：Montgomery reduction——多精度模乘法运算算法 https://blog.csdn.net/mutourend/article/details/95613967?fromshare=blogdetail&sharetype=blogdetail&sharerId=95613967&sharerefer=PC&sharesource=lemonsed&sharefrom=from_link%}