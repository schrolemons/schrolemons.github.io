---
title: 计算机安全：安全协议
tags: 计算机安全
categories: 计算机
comments: true
swiper_index: 10
hide: true
copyright_author: 薛定谔柠檬
cover: /study/jsjaq.png
abbrlink: 24329b97
date: 2024-09-17 22:50:40
updated: 2024-10-9 15:50:40
---
{% note primary flat %}
## 身份证明协议
{% endnote %}

>两个参与者：证明者，验证者。

>采用方式：挑战-响应协议-证明者向验证者通过展示与身份相关的秘密知识，证明自己的身份。

>关键：不泄露秘密，且能够抵抗攻击。

{% tabs 1 %}
<!-- tab 双向认证(基于共享密钥) -->
>挑战：一方传送给对方一个随机数

>响应：对方对这个数进行特定处理再返回

<font color=red>双向认证协议(1)</font>
![协议1](/study/xieyi0.png)
>假设A也是可接受多个会话的通用计算机

>考虑当攻击者伪装B的身份

受到反射攻击：
![反射攻击](/study/gonji0.png)

>关键：1.攻击者伪装B，建立一个同A的会话；2.攻击者拦截一个A向B的会话；3.攻击者利用A的自动加密，分别套出两个随机数的加密值。

<font color=red>双向认证协议(2)</font>
![协议2](/study/xieyi1.png)

受到反射攻击：
![反射攻击](/study/fanshe.png)

> 改进方式：在每个加密消息里加入发送者、接收者在协议中的角色(这样攻击者就无法利用消息2)。

<font color=red>双向认证协议(3)</font>
基于HMAC，对HMAC的 攻击难于对**对称密钥算法**的攻击。
![协议3](/study/hmac.png)

<font color=red>双向认证协议(4)</font>
Andrew安全RPC协议。
![协议4](/study/RPC.png)

攻击：
> 重放攻击：重放4给A；4中没有注明这个会话密钥和此次通信的关联。

> 类型缺陷攻击：攻击者在第四步重放2给A：虽然攻击者不一定知道RA+1，但猜测nonce比猜测密钥简单。

解决类型缺陷攻击：
> Nonce只被要求每次不同即可，不包含随机性。

<!-- endtab -->

<!-- tab 基于整数模p的阶为q的乘法循环群 -->
<font color=red>Schnorr协议</font>
>挑战：一方传送给对方一个随机数e

>响应：对方对这个数进行特定处理再返回


全局变量：p(大素数)、q(素数，p-1的因数)、g(生成元，0<g<p)、v(公钥，v=g^(-a) mod p)
私钥：a(0<a<q)

过程：
>A 生成随机 r(0<r<q)，将 g^{r} mod p 发给B(防止暴露a)

>B 向 A 发送随机数 e(防止A伪造a,e<2^{t}<q)\[挑战]

>A 计算 y = r + ae mod **q**，将 y发给B，(B无法求离散对数得到r，进而得到e)(为什么mod q：q是阶)\[响应]

>B 计算 g^{y} (g^{-a})^{e} mod p 是否等于g^{r} mod p, 判定A的身份(如果A没有a，很难伪造私钥以通过验证)

问题:
将Schnorr协议的过程1，2反序。协议是否安全？{% hideInline 不安全，A可第三步构造t，第一步发送g^{t}g^{-a}^e来欺骗B %}
若A使用相同的r进行两次验证，监听者能否获得a？ {% hideInline 能，B将e设为r，即可获得a %}
<!-- endtab -->

<!-- tab  基于公钥的认证-->
对于公钥算法来说，身份认证非常简洁。
>基于加密的认证：用X的公钥加密消息M

>基于签名的认证：用X的私钥加密消息M

注意：不要将密钥用于多个目的，比如使用不同的密钥对进行签名和加密
<!-- endtab -->
{% endtabs %}


{% note warning flat %}
## 认证协议设计一般原则
{% endnote %}

>安全协议设计是困难的,需要不断设计，分析，改进。

>协议中报文不能被重复使用。

>通信的发起者先提供自己的身份的证明，然后才是响应者。

>发起者和响应者使用不同的共享密钥。

>发起者和响应者的挑战数来源于不同的集合。如发起者用偶数，响应者用奇数。

>并行会话无法被利用。


{% note primary flat %}
## 密钥建立协议
{% endnote %}



{% tabs 1 %}
<!-- tab 密钥传输 -->
一方建立，安全地传给另一方。

{% tabs 2 %}
<!-- tab 无预先共享密钥的密钥传输 -->
目的：密钥 K 保密地（但无身份验证）从 A 传输到 B。
系统参数: 素数 p；A和B分别选择秘密随机数 a、b(1 ≤ a、b ≤ p − 2),均与p − 1互素(保证a逆 mod p-1存在)。

过程：
> A → B ： K^{a} mod p

>A ← B ： (K^{a})^{b} mod p

>A → B ： (K^{ab})^{a^(-1)} mod p
<!-- endtab -->

<!-- tab 使用密钥分发中心的密钥传输 -->
每个用户与KDC共享一个秘密密钥，KDC存储并管理所有密钥。
{% tabs 3 %}
<!-- tab 宽蛙嘴协议 -->
>![宽蛙嘴](/study/kuanwa.png)

攻击：
>重放2。

解决：
>加入时间戳或nonce
<!-- endtab -->
<!-- tab 简单票协议 -->
>![简单票](/study/jiandan.png)

攻击：
>重放攻击：如果一个旧密钥 Ks及其KB(KS)泄露，则攻击者可假冒任何人的身份与Bob对话

>中间人攻击1：Alice可在最后一步假冒任何人的身份与Bob对话

>中间人攻击2：攻击方C申请和A、B对话，拿到KC(KS)，KA(KS),KC(KS‘),KB(KS’)，进而监听和篡改A、B之间的通信

解决：
解决重放攻击：
![重放](/study/chongf.png)
> Alice能保证得到的Ks是新鲜的


解决中间人攻击：
![简单票2](/study/jiejue.png)
>Alice无法假冒别的身份与Bob对话

>Eva可以得到 KA(Ks，B)和 KB(Ks，A)， 但无法解密Ks，也无法伪造身份(因为身份信息受到KDC的加密)
<!-- endtab -->
<!-- tab Needham-Schroeder 协议 -->
![协议](/study/Need.png)
4,5是B向A证明身份，确认收到密钥，同时确认A的身份。注意：消息2对KB(A,KS)的加密是没有必要的。

攻击：
> Trudy得到了一个旧的 ks，则可以重放消息3。而B必须记住所有旧ks才能抵抗这种攻击。

解决：
>在2、3中加入时间戳，或者在3之前加入认证。

<font color=red>改进：Otway-Rees 协议</font>
![协议](/study/Ot.png)

>不需要复杂的同步机制

>通信双方都与KDC进行了一次挑战-应答

>RA加入到4，保证了KS的新鲜性

>接收方B不在线时，不能使用


<!-- endtab -->
<!-- tab Kerberos协议 -->
对Needham-Schroeder 协议的改进。

![协议](/study/K5.png)
>TGS票重用，一次登录可访问多个服务

>可视为两部分：第一部分，AS充当KDC，TGS充当另一用户；第二部分TGS充当KDC，Bob为另一用户

过程：
>1.用户向AS提供用户名和密码，获取ticket(一个登录期间一次)

>2.用户将此ticket发往TGS，获取另一个ticket(一种类型的服务一次)

>3.用户将此ticket发往服务器，获取服务

优点：
>身份验证只需一次，降低了风险
<!-- endtab -->
{% endtabs %}
<!-- endtab -->

{% endtabs %}

<!-- endtab -->

<!-- tab  密钥协商-->
共同参与计算一个共享密钥，任何一方不能预先确定结果。
{% tabs 4 %}
<!-- tab  DH密钥协商-->
>A 选择随机数 a，发送给B：g^{a} mod p

>B 选择随机数  b，发送给A：g^{b} mod p

>会话密钥 Ks = g^{ab} mod p
<!-- endtab -->
<!-- tab  完美前向保密PFS-->
>长期共享密钥K,当K被截获，不会造成Ks被破译:

>A公开：EK(g^{a} mod p)

>B公开：EK(g^{b} mod p)

>会话密钥:Ks = g^{ab} mod p
<!-- endtab -->
{% endtabs %}
<!-- endtab -->

{% endtabs %}





{% note warning flat %}
## 解决重放攻击的一般方式
{% endnote %}
消息重放的实质是消息的新鲜性（Freshness）不能得到保证。
{% tabs 1 %}
<!-- tab 时间戳 -->
对消息盖上本地时戳，只有当消息上的时戳与当前本地时间的差值在意定范围之内，才接受该消息。
要求有一个全局同步时钟，但是如果双方时钟偏差过大或者允许的范围过大，则可以被攻击者利用。

<!-- endtab -->

<!-- tab 挑战－应答机制 -->
通过发送挑战值（Nonce）来确保消息的新鲜性。
<!-- endtab -->

<!-- tab 序列号 -->
通信双方通过消息中的序列号来判断消息的新鲜性。要求通信双方必须事先协商一个初始序列号，并协商递增方法。
<!-- endtab -->
{% endtabs %}


{% note primary flat %}
## 传输层的安全协议SSL/TLS
{% endnote %}

![协议](/study/woshou.png)
分为记录层(编码协议、报文顺序等)、握手层。

重要概念：
>会话：会话是指客户机和服务器之间的关联。一个会话包含多个连接。SSL 会话使用了公钥算法，开销大。

>连接：连接是客户和服务器之间的逻辑链路，用于提供合适的传输服务和操作环境。SSL连接使用SSL会话生成的**pre-master secret**生成密钥，不再使用公钥算法。

>SSL/TLS握手协议负责协调客户机和服务器之间的**会话**的状态：当前操作状态和未决状态（在握手协议期间）。

服务：
>身份认证。认证用户和服务器，确保数据发送到正确的客户机和服务器；

>保密性。加密数据以防止数据中途被窃取；

>完整性。维护数据的完整性，确保数据在传输过程中不被改变。

{% tabs 6 %}
<!-- tab 简化的SSL会话建立 -->
![协议](/study/ssl.png)
使用了**公钥算法**，大大降低了效率。
>S ：**pre-master secret**，A生成的随机值。

>K = h(S||RA||RB)

>“msgs”是前边全部消息，用来证明前边消息已经正确接收。

>CLNT，SRVR 是固定字符串。

>Ek(h(msgs||CLNT||K))用于向Bob证明Alice的身份，可以不需要。

>第四步，Bob向Alice证明自己的身份。

问题
并没有认证A的身份。{% hideInline 服务员在此后用其他手段认证A的身份。 %}


<!-- endtab -->

<!-- tab 有共享秘密pre-master secret后的SSL连接建立 -->
不需要公钥算法。
![协议](/study/lianjie.png)
>SSL会话已建立，用session-ID表示

>K = h(S||RA||RB)

<!-- endtab -->


{% endtabs %}


参考资料：
1.{%link Schnorr身份识别方案 http://t.csdnimg.cn/QDNGJ%}