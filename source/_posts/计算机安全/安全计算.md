---
title: 计算机安全：安全计算
tags: 计算机安全
categories: 计算机
comments: true
swiper_index: 10
hide: true
copyright_author: 薛定谔柠檬
cover: /study/jsjaq.png
abbrlink: bc7c7b
date: 2024-09-15 18:50:40
updated: 2024-10-9 15:50:40
---
{% note warning flat %}
## 协议双方互不信任，都有可能欺骗

{% endnote %}
Semi-honest 半诚实，遵守协议流程，在过程中获得尽可能的信息
{% note primary flat %}
## 承诺方案
{% endnote %}
即在一次信息交换中，A和B需要“同时”获得对方的一个信息。假设A先给出信息a，B后给出信息b。则B需要先给出b的证明c，A再给出信息a，B再给出信息b。这样，A能够核验信息证明c，来确保B没有在接收信息a后更改信息b【绑定】；同时，A也无法从信息证明c中获取b，来改变信息a【隐藏】。

#### 基于Hash函数的实现
>A 计算承诺 c = H (随机数,a)，将 c 发送给 B

>隐藏性：存在 H ( R’, a’ ) =  H ( R, a )，B找不到真实的R，a

>绑定性： A 找不到 R’, a’，满足：H ( R’, a’ ) = H ( R, a )

不存在对有无限计算能力的敌手同时具有隐藏性和绑定性的承诺方案。


{% note primary flat %}
## 百万富翁问题
{% endnote %}
A有一个0-9的数a，B有一个0-9的数b，A和B不想让对方知道自己的数字，但想知道a和b的大小。
{% tabs 2 %}
<!-- tab  基于DH实现-->
>A和B生成 <math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>α</mi><mo>,</mo><msup><mi>g</mi><mrow><mi>α</mi></mrow></msup><mo>,</mo><mi>β</mi><mo>,</mo><msup><mi>g</mi><mrow><mi>β</mi></mrow></msup></math>

>A进行操作后发给B：<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>若</mo><mi>α</mi><mo>=</mo><mi>i</mi><mo>，则</mo><mi>H</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><msup><mi>g</mi><mrow><mi>α</mi></mrow></msup><mo>∗</mo><mn>3.</mn><mo>.</mo><mo>.</mo><mo>,</mo><mo>若</mo><mi>α</mi><mo>&lt;</mo><mi>i</mi><mo>，则</mo><mi>H</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><msup><mi>g</mi><mrow><mi>α</mi></mrow></msup><mo>∗</mo><mn>2.</mn><mo>.</mo><mo>.</mo><mo>,</mo><mo>若</mo><mi>α</mi><mo>&gt;</mo><mi>i</mi><mo>，则</mo><mi>H</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><msup><mi>g</mi><mrow><mi>α</mi></mrow></msup><mo>∗</mo><mn>1.</mn><mo>.</mo><mo>.</mo><mo>,</mo><mo>,</mo><msup><mi>g</mi><mrow><mi>α</mi></mrow></msup><mo>.</mo></math>(“...”互不相同是为了防止B通过判断相同元素个数，50%概率猜出a)

>B对H\[b]进行加密，并抹除下标，将其发送给A。

> A对H\[?]进行解密，并将其发送给B。(防止A知道下标b，而猜出具体数字)

> B解密，获得结果。

> B发送密钥给A，A解密，获得结果。
<!-- endtab -->
<!-- tab  茫然传输方案-->

>B 生成大数字 x，用 A 的公钥加密 x 得到 \[x]A，将 \[x]A – b 发送给A

>A收到后：
>>计算九个数字：\[x]A – b + 1,  \[x]A – b + 2 ,  …  ,  \[x]A – b + 9.
>>并用自己的私有密钥解密这个些数字： { \[x]A – b + 1 }A ,  { \[x]A - b + 2 }A ,  …  ,  { \[x]A - b + 9 }A
>>并将第 1 到第 a 结果 +1，其余不变

>A将 9 个结果按序发送给 Ｂ

>Ｂ检测第 b 个数字，如果是 x，则 a < b，否则 a >= b.(原理：若成功解密，说明第b项没有+1，即a＜b)
<!-- endtab -->
<!-- tab  混淆电路方案-->

即将函数f(a,b)(比较a和b大小的函数)电路化，再对每个门电路进行加密。
<!-- endtab -->
{% endtabs %}


{% note primary flat %}
## 茫然传输协议
{% endnote %}
A 拥有 m1、m2，B需要知道指定的一个，而不知道另一个；A不知道B指定了哪个。
{% tabs 2 %}
<!-- tab  EGL协议-->
采用了姚期智解决百万富翁问题的方案。
>A，B 共享 y0，y1

>B 选择 x，用 A 的公钥加密，得到 \[x]A, 将 \[x]A - yb 发送给 A

>A计算 \[x]A – yb + y0, \[x]A – yb + y1，并用A的私钥解密这两个结果，得到 { \[x]A – yb + y0 }A，{ \[x]A – yb + y1 }A。因为b是确定的，故其中一个等于x，但A并不知道哪个是x。

>A将 { \[x]A - yb + y0 }A + m0，{ \[x]A – yb + y1 }A + m1 发送给 B

>B 计算 { \[x]A - yb+ yb }A + mb - x 得到 mb。因为另一个数不等于x，B无从知道另一个m是什么，除非B知道A的私钥。
<!-- endtab -->
<!-- tab  Naor-Pinkis协议-->
基于Elgamal加密算法实现。
![茫然传输](/study/mangran.png)
若B知道C的离散对数，设其为t，则有<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo stretchy="false">(</mo><mi>C</mi><mrow><mo>/</mo></mrow><msup><mi>g</mi><mrow><mrow><mo>β</mo></mrow></mrow></msup><msup><mo stretchy="false">)</mo><mrow><mi>a</mi></mrow></msup><mo>=</mo><mfrac><msup><mi>g</mi><mrow><mi>a</mi><mi>t</mi></mrow></msup><msup><mi>g</mi><mrow><mi>a</mi><mrow><mo>β</mo></mrow></mrow></msup></mfrac><mo>=</mo><mfrac><msup><mi>g</mi><mrow><mo stretchy="false">(</mo><mi>a</mi><mrow><mo>β</mo></mrow><msup><mo stretchy="false">)</mo><mrow><mfrac><mi>t</mi><mrow><mo>β</mo></mrow></mfrac></mrow></msup></mrow></msup><msup><mi>g</mi><mrow><mi>a</mi><mrow><mo>β</mo></mrow></mrow></msup></mfrac><mo>=</mo><msubsup><mi>P</mi><mrow><mn>1</mn><mo>−</mo><mi>b</mi></mrow><mrow><mi>a</mi></mrow></msubsup><mo>。</mo></math>
<!-- endtab -->
{% endtabs %}


{% note primary flat %}
## 多方安全计算协议
{% endnote %}
{% tabs 2 %}
<!-- tab  两方安全计算-->
>问题：A，B各自拥有秘密 a，b。A，B 希望计算函数 f ( a, b )，同时不泄漏 a，b。值域定义域均为 \[n]。

>解决1：A 生成函数表 f ( a, * )，B 和 A 运行 1 / n 茫然传输，B 输入 b(表在A方，B查询输入b时候的输出值，且不让A知道查询的值，得到f(a,b))，B 得到 f ( a, b )。

>解决2：混淆电路，更便于实现多方安全计算，开销更小。
<!-- endtab -->
<!-- tab  混淆电路-->
#### 概述
**多个**参与方提供输入，计算一个函数值，同时不泄露各自的输入。

#### 实现
>设现有电路模块M，两个0/1输入，一个0/1输出。A将0/1输入映射为B0，B1，将0/1输出映射为T0，T1，并在对应的真值表中，用输入的映射值对输出的映射值进行加密。A选取a的映射值作为输入。

> B选取一个输入b(0/1),并通过**茫然传输**从A那里获得输入的映射值。

> A将a的映射发给B，因为B**不知道对应关系**，故不知道A的输入原本是什么；B用两个映射值对四个被加密的输出值进行解密，得到正确的输出映射值。(解密函数 D 具有可分辨性质，即能通过解密结果判定解密是否正确。)因为A给B的四个盒子被**混淆**，故B不能通过顺序关系找到A的输入是0还是1。

>B将输出的映射值发给A，A查表后得到输出的原本值，再发给B。

> 现有多个M，通过逻辑线路相连（但B不应该知道是与门还是或门)，B应当通过对多个M的解密获得多个输出，再把这些输出当做其他M的输入，进而得到最终输出。(最终输出无需加密和映射)

一个电路的所有门的混淆表集合称为电路的混淆电路。
混淆电路实现了安全计算的目标。
**这部分运用比理论简单，建议看回放**
#### 应用
>A 拥有AES密钥 k

>B 希望得到用 k 加密的 m, 即 AES ( k, m )

>此过程结束后 B 得到 AES ( k, m )，但不知道 k。A 不知道 m。(实现方式：将AES加密逻辑转化为电路，并将输入值转换为0/1比特)
<!-- endtab -->
{% endtabs %}

{% note warning flat %}
## 安全计算目标
{% endnote %}

#### 隐私保护
>计算无法通过协议得知对方的参数

#### 正确性
>能正确地传递信息

#### 公平性
>双方都可以得到结果

#### 安全性
>混淆电路协议对诚实但好奇(观察分析)的攻击者是安全的


参考：
1.{%link CSDN：【隐私计算篇】混淆电路深入浅出 http://t.csdnimg.cn/mfXre%}